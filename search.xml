<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>NEXT主题使用说明</title>
    <url>/2022/12/29/NEXT%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a><center>MarkDown</center></h1><span id="more"></span>

<h2 id="基本信息配置"><a href="#基本信息配置" class="headerlink" title="基本信息配置"></a>基本信息配置</h2><p>Markdown最上方<code>---</code>分割区域Next预定义参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td>博客名</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
<td>更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类</td>
<td></td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章网址</td>
<td></td>
</tr>
<tr>
<td>excerpt</td>
<td></td>
<td></td>
</tr>
<tr>
<td>disableNunjucks</td>
<td></td>
<td></td>
</tr>
<tr>
<td>lang</td>
<td>语言</td>
<td></td>
</tr>
</tbody></table>
<p>tags和categories等可以设置多个值：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag2</span>	</span><br></pre></td></tr></table></figure>

<p>该方法会使tag2成为tag1的子标签，要设置同级标签，应用一下方式，其中父标签1,2,3是同级标签，categories分类标签同理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签1</span>, <span class="string">子标签1</span>]</span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签2</span>, <span class="string">子标签2</span>]</span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签3</span>]</span><br></pre></td></tr></table></figure>

<h1 id="日程表"><a href="#日程表" class="headerlink" title="日程表"></a>日程表</h1><p>由于使用type&#x3D;”schedule”	时无法正确显示Markdown，所以将type改为about</p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>使用本地插入时，绝对路径和相对路径都无法加载图片，所以采用图床的方式插入图片，<a href="https://sm.ms/">SM.MS</a>，上传图片后以网络链接的形式插入图片</p>
]]></content>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟与高精度</title>
    <url>/2022/12/29/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="A-B-Problem"><a href="#A-B-Problem" class="headerlink" title="A*B Problem"></a><center>A*B Problem</center></h1><span id="more"></span>

<p>题目：输入A，B，求A*B的值</p>
<p>若A的长度为n，B的长度为m，则A*B的长度&lt;&#x3D;n+m,由此确定结果数组的长度。模拟进行A*B运算，B由低到高每一位与A的每一位相乘，由于I，j从0开始，故可以用i+j确定每位相乘的结果是结果数组的第几位。</p>
<p>进行运算前先把输入的A，B逆序以便于计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* numA = <span class="keyword">new</span> <span class="type">int</span>[a.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="type">int</span>* numB = <span class="keyword">new</span> <span class="type">int</span>[b.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="type">int</span>* res = <span class="keyword">new</span> <span class="type">int</span>[a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">		res[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); ++i) &#123;	<span class="comment">//倒序把字符串转换为数字数组</span></span><br><span class="line">		numA[i] = a[a.<span class="built_in">length</span>() - i - <span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">		numB[i] = b[b.<span class="built_in">length</span>() - i - <span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; b.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">			res[i + j] += numA[i] * numB[j];</span><br><span class="line">			<span class="keyword">if</span> (res[i+j]&gt;<span class="number">9</span>) res[i + j+<span class="number">1</span>] += res[i + j]/<span class="number">10</span>;</span><br><span class="line">			res[i + j] = res[i + j] % <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">false</span>;	<span class="comment">//是否已去除前面的0</span></span><br><span class="line">	<span class="keyword">for</span> (i = a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;	<span class="comment">//输出</span></span><br><span class="line">		<span class="keyword">if</span> (res[i])	flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (flag)	cout &lt;&lt; res[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flag) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;	<span class="comment">//如果全是0，输出一个0</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] numA;</span><br><span class="line">	<span class="keyword">delete</span>[] numB;</span><br><span class="line">	<span class="keyword">delete</span>[] res;</span><br></pre></td></tr></table></figure>

<h1 id="N！之和问题"><a href="#N！之和问题" class="headerlink" title="N！之和问题"></a><center>N！之和问题</center></h1><p>求解阶乘之和</p>
<p>就是把高精乘和高精加结合起来，但在处理高精乘进位时，应该把所有的位数遍历一遍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">90</span>; ++j) &#123;</span><br><span class="line">	<span class="keyword">if</span> (now[j] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">		now[j + <span class="number">1</span>] += now[j] / <span class="number">10</span>;</span><br><span class="line">		now[j] %= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若使用判断的方法，可能会出现这一位不大于9但下面的位大于9的情况，造成出错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(now[count]&gt;<span class="number">9</span>)&#123;	<span class="comment">//进位</span></span><br><span class="line">	now[count + <span class="number">1</span>] += now[count] / <span class="number">10</span>;</span><br><span class="line">	now[count] %=  <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2022/12/29/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><center>二叉树</center></h1><span id="more"></span>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a><center>遍历</center></h2><p>前序遍历 <code>根-左-右</code>		中序遍历 <code>左-根-右</code>		后序遍历 <code>左-右-根</code></p>
<p><img src="https://s2.loli.net/2022/11/06/FrwMeBjslUpYDuH.png" alt="二叉树图.png"></p>
<p>前序遍历A-B-D-F-G-H-I-E-C</p>
<p>中序遍历F-D-H-G-I-B-E-A-C</p>
<p>后序遍历F-H-I-G-D-E-B-C-A</p>
<p>对二叉树进行遍历，前序和中序用栈而后序用两个栈实现从最后开始输出</p>
<p><em>先序遍历代码实现：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历 非递归先序遍历 头=&gt;左=&gt;右</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk;	<span class="comment">//定义一个栈</span></span><br><span class="line">		stk.<span class="built_in">push</span>(head);</span><br><span class="line">		<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			head = stk.<span class="built_in">top</span>();</span><br><span class="line">			stk.<span class="built_in">pop</span>();</span><br><span class="line">			cout &lt;&lt; head-&gt;val &lt;&lt; endl;	<span class="comment">//处理语句</span></span><br><span class="line">			<span class="keyword">if</span> (head-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>中序遍历代码实现</em></p>
<p>中序遍历时先把所有左节点入栈，遇到空指针时出一个左节点并把其右节点入栈，</p>
<p>并在此时进行操作，就可以实现左-中-右的遍历</p>
<p>​	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归中序遍历	左=&gt;头=&gt;右</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk;</span><br><span class="line">		<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()||head!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head);</span><br><span class="line">				head = head-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				head = stk.<span class="built_in">top</span>();</span><br><span class="line">				cout &lt;&lt; head-&gt;val &lt;&lt; endl;</span><br><span class="line">				stk.<span class="built_in">pop</span>();</span><br><span class="line">				head = head-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>后序遍历代码实现：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归后序遍历	左=&gt;右=&gt;头 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">posOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk1;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk2;</span><br><span class="line">		stk1.<span class="built_in">push</span>(head);</span><br><span class="line">		<span class="keyword">while</span> (!stk1.<span class="built_in">empty</span>()) &#123;	<span class="comment">//弹出时不操作而是放入另一个栈中</span></span><br><span class="line">			head = stk1.<span class="built_in">top</span>();</span><br><span class="line">			stk2.<span class="built_in">push</span>(head);</span><br><span class="line">			stk1.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk1.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk1.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!stk2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			cout &lt;&lt; stk2.<span class="built_in">top</span>()-&gt;val &lt;&lt; endl;</span><br><span class="line">			stk2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		对三种遍历结果进行观察，前序的最前边是头节点，而后序的最后一个是头节点，然后根据中序遍历的结果可以进行二叉树复原，但只有前序和后序是无法复原的。</p>
<h2 id="祖先"><a href="#祖先" class="headerlink" title="祖先"></a><center>祖先</center></h2><h4 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h4>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象</title>
    <url>/2022/12/29/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><span id="more"></span>

<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><ul>
<li><p>对象：具体的事物</p>
</li>
<li><p>类：概念，模板，抽象的描述</p>
</li>
</ul>
<h4 id="类的代码定义"><a href="#类的代码定义" class="headerlink" title="类的代码定义"></a>类的代码定义</h4><p><strong>格式：public class 类名 {}</strong></p>
<p>命名规范： 类目必须与所在的文件名一致，要求首字母大写，使用驼峰命名规范</p>
<p>内容：</p>
<p>​	成员属性：数据类型 数据名</p>
<p>​	成员方法：修饰词 返回值类型 方法名（参数类型 参数名） {}</p>
<p>​	任何方法都要放在类的结构中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    String userName;</span><br><span class="line">    String userPwd;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="type">boolean</span> isOnline;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showUserInfo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPassword</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String oldpwd, String newpwd)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="封装属性"><a href="#封装属性" class="headerlink" title="封装属性"></a>封装属性</h2><ul>
<li><p>将成员属性私有化，限制对属性的调用，针对每一个属性对设置对应的 赋值方法和获取方法</p>
</li>
<li><p>优点： </p>
<ul>
<li>set属性时 ，可以对传入参数进行验证，保证数据规范安全 </li>
<li>get属性时，可以对需要返回数据进行整合处理 返回对方需要的格式类型 </li>
<li>结构更清晰  size(w,h); 简化代码 整合数据 </li>
<li>读写分离，存在一些属性，不暴露 读&#x2F;写</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPwd;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isOnline;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserPwd</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserAge</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserScore</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserPwd</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserAge</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserScore</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getUserOnline</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showUserInfo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPassword</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String oldpwd, String newpwd)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化： 构造方法<ul>
<li>格式：类名 （参数列表）{}    没有返回值结构</li>
<li>每个类都自带一个隐式的空参数构造方法 ，一旦自己写了构造方法，不管有无参数 都会覆盖隐式的 </li>
<li>构造方法可以重组</li>
<li>构造方法在创建对象时调用，且只被调用一次</li>
</ul>
</li>
<li>私有化构造方法：<ul>
<li>私有化构造可有令该类不能在类的外部创建对象，对创建对象的权限做了限制</li>
</ul>
</li>
<li>单例：<ul>
<li>单例类只能有一个对象存在</li>
<li>将构造方法私有化后在单例类中创建一个公有 静态 的对象，该对象可以在类外部通过类名直接调用</li>
<li>在类中创建类对象若不添加static 关键字会导致不断递归创建该对象，导致死循环</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPwd;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isOnline;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String userName,String userPwd,<span class="type">int</span> age,<span class="type">int</span> score)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User king= <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;king&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="number">50</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getKing</span><span class="params">()</span>&#123;<span class="keyword">return</span> king&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserPwd</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserAge</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserScore</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserPwd</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserAge</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserScore</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getUserOnline</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showUserInfo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPassword</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String oldpwd, String newpwd)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2022/12/29/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><span id="more"></span>

<ul>
<li>继承格式 ： class 类名 extends 父类名 {}</li>
<li>访问修饰符：<ul>
<li>public 该项目所有文件</li>
<li>protrcted 子类及同包</li>
<li>private 本类及友类</li>
<li>无       同包下</li>
</ul>
</li>
<li>方法重写：<ul>
<li>在子类中重写父类中方法<ul>
<li>访问修饰词  权限不变或小权限变大权限，扩展开放原则</li>
<li>返回值类型  可以返回父类及父类的子类</li>
<li>不能修改参数表</li>
</ul>
</li>
</ul>
</li>
<li>类型转换：<ul>
<li>自动类型转换：基类指针可以指向子类，子类对象可以被自动转化为基类对象</li>
<li>强制类型转化：将基类对象转化子类对象，需要进行强制类型转换，强制向下转型需要验证是否合法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL简介</title>
    <url>/2022/12/30/MySQL1/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="一、启动"><a href="#一、启动" class="headerlink" title="一、启动"></a>一、启动</h1><ul>
<li>使用MySQL终端输入密码后启动</li>
<li>使用CMD，输入 <code>mysql -u 用户名 -p</code>后启动</li>
</ul>
<h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><ul>
<li>关系型数据库：建立在关系模型的基础上，由多张相互连接的二维表组成的数据库</li>
<li>非关系型数据库：</li>
</ul>
<!--more-->

<h1 id="三、SQL"><a href="#三、SQL" class="headerlink" title="三、SQL"></a>三、SQL</h1><h2 id="1-通用语法及分类"><a href="#1-通用语法及分类" class="headerlink" title="1.通用语法及分类"></a>1.通用语法及分类</h2><ul>
<li><p>通用语法</p>
<ol>
<li><p>可以单行或多行书写，以分号结尾</p>
</li>
<li><p>不区分大小写，关键字建议大写</p>
</li>
<li><p>单行注释： <code>--注释内容</code> or # <code>注释内容</code></p>
</li>
<li><p>多行注释：<code> /* 注释内容*/</code></p>
</li>
</ol>
</li>
<li><p>SQL分类</p>
<ol>
<li>DDL：定义语言，定义数据库对象</li>
<li>DML：操作语言，进行增删改查</li>
<li>DQL：查询语言，查询数据库中的记录</li>
<li>DCL：控制语言，创建用户，修改权限</li>
</ol>
</li>
</ul>
<h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li>查询<ul>
<li>查询全部数据库 <code>show databases;</code></li>
<li>查询当前数据库<code>select database();</code></li>
</ul>
</li>
<li>创建<ul>
<li>创建数据库 <code>create database [if no exists] 名称 [default charset 字符集] [collate 排序规则]</code>,使用时去掉括号</li>
</ul>
</li>
<li>删除<ul>
<li><code>drop database [if exists] 名称</code></li>
</ul>
</li>
<li>使用(切换数据库)<ul>
<li><code>use 名称</code></li>
</ul>
</li>
</ul>
<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><ul>
<li><p>查询</p>
<ul>
<li>查询当前所有表	<code>show tables;</code></li>
<li>查询表结构   <code>desc 表名;</code></li>
</ul>
</li>
<li><p>创建</p>
<ul>
<li>&#96;&#96;&#96;<br>create table 表名(<br>字段1 字段1类型[comment 字段1注释]<br>…….<br>)[comment 表注释];<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```sql</span><br><span class="line">create table tb_user(</span><br><span class="line">	id int comment &#x27;编号&#x27;,</span><br><span class="line">	name varchar(50) comment &#x27;姓名&#x27;,</span><br><span class="line">	......</span><br><span class="line">	age int comment &#x27;年龄&#x27;</span><br><span class="line">) comment &#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数据类型</p>
<ul>
<li>整形	名称 整形类型 [unsigned]</li>
<li>浮点    名称 浮点类型(长度,小数位数)</li>
<li>定长字符串  char(最大长度)  长度一直是10,性能好</li>
<li>变长字符串  varchar(最大长度)  根据数据改变长度,性能较差</li>
<li>后缀为 lob 代表是二进制数据</li>
<li>date,time,year,datetime,timestamp</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">	id <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">	workno <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;工号&#x27;</span>,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">	gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">	age tinyint unsigned comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">	entrydate <span class="type">date</span> comment <span class="string">&#x27;入职时间&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;员工表&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<ul>
<li><p>添加字段 <code>alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];</code></p>
</li>
<li><p>修改字段数据类型 <code>alter table 表名 modify 字段名 新数据类型(长度);</code></p>
</li>
<li><p>修改字段名和类型 <code>alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];</code></p>
</li>
<li><p>修改表名 <code>alter table 表名 rename to 新表名;</code></p>
</li>
<li><p>删除字段<code>alter table 表名 drop 字段名;</code></p>
</li>
<li><p>删除表 <code>drop table [if exists] 表名;</code></p>
</li>
<li><p>删除表后并重新创建该表<code>truncate table 表名;</code> 即留下一个空表</p>
</li>
</ul>
</li>
</ul>
<h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><p><strong>DML用来对表中数据记录进行增删改操作</strong></p>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><ul>
<li>给指定字段添加数据 <code>insert into 表名(字段名1,字段名2,...) values(值1,值2,...);</code></li>
<li>给全部字段添加数据 <code>insert into 表名 values(值1,值2,...);</code></li>
<li>批量添加数据<code>insert into 表名(字段名1,...) values(值1,...),(值1,...)...;</code></li>
</ul>
<p>注意:</p>
<p>​	<em>值与字段名一一对应;</em></p>
<p>​	<em>字符串和日期型数据应包含在引号中;</em></p>
<p>​	<em>插入的数据应在字段规定的范围内;</em></p>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li><p><code>update 表名 set 字段名1=值1,...... [where 条件];</code> 若无条件则修改所有字段</p>
<pre><code>   如: `update employee set name = &#39;itheima&#39; where id = 1;`
</code></pre>
</li>
<li><p>若修改后没有where字段或where字段筛选的不是键列,可能会报错,需要退出安全模式再执行</p>
</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li><p><code>dalete from 表名 [where 条件];</code>  </p>
<p>delete不能删除某个字段的值,应使用update把字段的值设为NULL</p>
</li>
</ul>
<h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><h2 id="查询语言"><a href="#查询语言" class="headerlink" title="查询语言"></a>查询语言</h2><ul>
<li><p><strong>基本查询</strong></p>
<ul>
<li>查询多个字段 <code>select 字段1,字段2... from 表名;</code> or <code>select * from 表名;</code>查询所有字段</li>
<li>设置别名 <code>select 字段1 [as 别名],...... from 表名;</code></li>
<li>去除重复记录 <code>select distinct 字段列表 from 表名;</code></li>
</ul>
</li>
<li><p><strong>条件查询</strong>(模糊查询)</p>
<ul>
<li><p><code>select 字段列表 from 表名 where 条件列表;</code>  </p>
<p>like 占位符 模糊匹配(_匹配单个字符,%匹配任意个字符)</p>
<p><code>select * from emp where name like &#39;__&#39;;</code>表示匹配两个字符的</p>
<p><code>select * from emp where idcard like &#39;%X&#39;;</code> 匹配最后一个字符是X的</p>
<p>is null  是空</p>
<p>between … and … 某个范围内,闭区间</p>
<p>in (…)	在in之后列表中的值,多选一</p>
</li>
</ul>
</li>
<li><p><strong>聚合函数</strong></p>
<p>​	将一列数据作为一个整体,进行纵向计算</p>
<p>​	常见聚合函数:  <code>cout</code> ,<code>max</code>,<code>min</code> ,<code>avg</code> ,<code>sum</code>,对有值的数据进行计算,null不参与计算</p>
<ul>
<li><code>select 聚合函数(字段列表) from 表名</code></li>
</ul>
</li>
<li><p><strong>分组查询</strong></p>
<ul>
<li><p><code>select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后的条件]</code></p>
<p>where不能对聚合函数进行判断,而having可以</p>
<p><code>select gender,count(*) from emp group by gender</code>根据性别进行分组</p>
</li>
</ul>
</li>
<li><p><strong>排序查询</strong></p>
<ul>
<li><p><code>select 字段列表 from 表名 order by 字段1 , 排序方式1,...;</code></p>
<p>asc: 升序 (默认)	desc: 降序	</p>
<p>多字段排序时,字段1的值相同后按字段2进行排序</p>
</li>
</ul>
</li>
<li><p><strong>分页查询</strong></p>
<ul>
<li><p><code>select 字段列表 from 表名 limit 起始索引,查询记录数;</code></p>
<p>起始索引从0开始,等于(查询页码-1)*每一页返回的记录数</p>
<p>若查询第一页的数据,起始引索可以省略,直接简写为</p>
<p>查询第一页 <code>select * from emp limit 10;</code></p>
<p>查询第二页 <code>select * from emp limit 10 , 10;</code></p>
</li>
</ul>
</li>
<li><p>联表查询</p>
<ul>
<li>外连接</li>
<li>内连接</li>
</ul>
</li>
</ul>
<h1 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h1><p><strong>数据控制语言,用来管理数据库用户,控制数据库访问权限</strong></p>
<ul>
<li><p>查询用户</p>
<ul>
<li><code>use mysql;</code></li>
<li>select * from user;</li>
</ul>
</li>
<li><p>创建用户</p>
<ul>
<li><p><code>create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;;</code></p>
<p>主机名为 % 表示可以被任意主机访问</p>
</li>
</ul>
</li>
<li><p>修改用户密码</p>
<ul>
<li><code>alter user &#39;用户名&#39;@&#39;主机名&#39; identified with mysql_native_password by &#39;新密码&#39;;</code></li>
</ul>
</li>
<li><p>删除用户</p>
<ul>
<li><code>drop user &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
<li><p>权限控制</p>
<ul>
<li><p><code>all</code> 所有权限 	<code>select</code>	查询数据	<code>insert</code>	插入数据	<code>update</code>	修改数据</p>
<p><code>delete</code> 删除数据	<code>alter</code> 修改表	<code>drop</code> 删除数据库&#x2F;表&#x2F;视图	<code>create</code> 创建数据库</p>
</li>
</ul>
</li>
<li><p>查询权限</p>
<ul>
<li><code>show grants for &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
<li><p>授予权限</p>
<ul>
<li><code>grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
<li><p>撤销权限</p>
<ul>
<li><code>revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>图形化编程</title>
    <url>/2022/12/31/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="图形化编程"><a href="#图形化编程" class="headerlink" title="图形化编程"></a>图形化编程</h1><span id="more"></span>

<h2 id="java图形化包"><a href="#java图形化包" class="headerlink" title="java图形化包"></a>java图形化包</h2><ul>
<li><p>java的图像包有java.awt  和javax.swing </p>
</li>
<li><p>组件: 按钮,输入框,窗体,图片,这些组件在各语言里都已经设计好了</p>
</li>
</ul>
<p>​	<strong>java窗体类 JFrame,使用import导入需要使用的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Login</span>&#123;</span><br><span class="line">	<span class="type">JFrame</span> <span class="variable">jf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line">	jf.setSize(<span class="number">450</span>,<span class="number">550</span>);	</span><br><span class="line">	jf.setTitle(<span class="string">&quot;登录界面&quot;</span>);	</span><br><span class="line">    <span class="comment">//居中</span></span><br><span class="line">	jf.setLocationRelativeTo(<span class="literal">null</span>); </span><br><span class="line">	<span class="comment">//退出进程  查看该方法原代码查看整形参数的含义</span></span><br><span class="line">    jf.setDefaultCloseOperation(<span class="number">3</span>); </span><br><span class="line">    <span class="comment">//流式布局管理器</span></span><br><span class="line">    FlowLayout flow=<span class="keyword">new</span> <span class="title class_">FlowLayout</span>();</span><br><span class="line">    <span class="comment">//设置窗体类为流式布局</span></span><br><span class="line">    jf.setLayout(flow);</span><br><span class="line">    <span class="comment">//按钮</span></span><br><span class="line">    <span class="type">JButton</span> <span class="variable">jbu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line">    jf.add(jbu);</span><br><span class="line">    <span class="comment">//设置可见</span></span><br><span class="line">    jf.setVisible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="type">ButtonListener</span> <span class="variable">listnener1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ButtonListener</span>();</span><br><span class="line">    jbu1.addActionListener(listnener1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JFrame 窗体类</li>
<li>FlowLayout 流式布局</li>
<li>ImageIcon 图片读取</li>
<li>JLabel  标签类,用于承载图片,文字等</li>
<li>Dimension 布局类,除窗体外其他组件都需要使用该对象来设定布局</li>
<li>JButton 按钮类</li>
</ul>
<h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>监听需新建一个类,继承自带的监视器类后重写其中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="comment">//事件处理方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录中...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(Account.findAccount(Login.getUser(),Login.getPwd()))&#123;</span><br><span class="line">            showSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            showFailed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是当按钮被按下时执行的程序</p>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL函数</title>
    <url>/2023/01/02/MySQL%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><span id="more"></span>

<h2 id="一-字符串函数"><a href="#一-字符串函数" class="headerlink" title="一.字符串函数"></a>一.字符串函数</h2><ul>
<li><p><code>concat(s1,s2,...) </code>拼接字符串</p>
</li>
<li><p><code>lower(str)</code> 转换小写</p>
</li>
<li><p><code>upper(str)</code> 转换小写</p>
</li>
<li><p><code>lpad(str,n,pad)</code> 左填充,用字符串pad对str左边进行填充,达到n个字符串长度(总长度)</p>
</li>
<li><p><code>rpad(str,n,pad)</code> 左填充,用字符串pad对str右边进行填充,达到n个字符串长度(总长度)</p>
</li>
<li><p><code>trim(str)</code>去除头部和尾部的空格</p>
</li>
<li><p><code>substring(str,start,len)</code>返回从start起的len个长度的字符串</p>
</li>
</ul>
<h2 id="二-数值函数"><a href="#二-数值函数" class="headerlink" title="二.数值函数"></a>二.数值函数</h2><ul>
<li><p><code>ceil(x)</code> 向上取整</p>
</li>
<li><p><code>floor(x)</code> 向下取整</p>
</li>
<li><p><code>mod(x,y)</code> 返回x&#x2F;y的模</p>
</li>
<li><p><code>rand()</code>返回[0,1]之间的随机数</p>
</li>
<li><p><code>round(x,y)</code> 返回x四舍五入的值,保留y位小数</p>
<p>生成一个六位数的随机验证码</p>
<p><code>select lpad(round( rand()*1000000 , 0),6,&#39;0&#39;);</code></p>
</li>
</ul>
<h2 id="三-日期函数"><a href="#三-日期函数" class="headerlink" title="三.日期函数"></a>三.日期函数</h2><ul>
<li><p><code>curdate()</code>返回当前日期</p>
</li>
<li><p><code>curtime()</code>返回当前时间</p>
</li>
<li><p><code>now()</code>返回当前日期和时间</p>
</li>
<li><p><code>year(data)</code>获取指定date的年份</p>
</li>
<li><p><code>month(data)</code>获取指定data的月份</p>
</li>
<li><p><code>day(data)</code>获取指定data的日期</p>
</li>
<li><p><code>date_add(data,INTERVAL expr type)</code>返回date加上一个时间间隔expr后的时间值</p>
<p><code>select date_add(now(),INTERVAL 70 DAY);</code> 现在时间加上70天</p>
</li>
<li><p><code>datediff(date1,date2)</code>返回date1和date2之间的天数</p>
</li>
</ul>
<h2 id="四-流程函数"><a href="#四-流程函数" class="headerlink" title="四.流程函数"></a>四.流程函数</h2><ul>
<li><code>if(value,t,f)</code> value为true,返回t反之返回f</li>
<li><code>ifnull(v1,v2)</code> v1不为空返回v1,为空返回v2</li>
<li><code>case when [v1] then [res1] ... else [default] end</code>若v1为true,返回res1,…否则返回default</li>
<li><code>case [expr] when [v1] then [res1] ... else [default] end</code> 若expr等于v1,返回res1,….否则返回default</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2023/01/03/%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><span id="more"></span>

<p>格式: <code>interface 接口名 &#123;&#125;</code></p>
<ul>
<li>接口中的变量默认以 statci final 修饰,必须初始化赋值</li>
<li>接口中可以定义抽象方法,静态方法和默认方法</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ol>
<li>创建一个类 实现 接口(继承接口) ,一个类可以实现多个接口但只能继承一个类</li>
<li>类中必须重写接口中的所有抽象方法</li>
<li>类中可以直接使用 接口中的变量,静态方法和默认方法</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">openDoor</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现 接口Lock</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">leyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key 正确,开门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key 正确,关门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">calss Mange&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Door door= <span class="keyword">new</span> <span class="title class_">Door</span>();</span><br><span class="line">        keyLock keylock=<span class="keyword">new</span> <span class="title class_">keyLock</span>();</span><br><span class="line">        door.lock() = keylock; <span class="comment">//传入接口</span></span><br><span class="line">        </span><br><span class="line">        door.open();</span><br><span class="line">        door.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要对锁进行升级或修改,对实现锁这个接口的类进行修改或再次创建一个类对锁进行实现,然后传入接口就可以了,避免了对门和锁的源码进行修改</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li><p>抽象类： </p>
<ul>
<li>定义抽象方法</li>
<li>定义普通方法</li>
</ul>
</li>
<li><p>接口 &gt; 抽象类 &gt; 类： </p>
</li>
<li><p>设计 &gt; 半成品 &gt; 成品 </p>
</li>
<li><p>依赖不能导致： </p>
<ul>
<li>抽象类可以继承非抽象类,但不要这么做</li>
</ul>
</li>
<li><p>只要是抽象的都不可以实例化对象</p>
</li>
</ul>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>约束</title>
    <url>/2023/01/03/MySQL%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><table>
<thead>
<tr>
<th>主键约束</th>
<th>约束数据库中每条记录唯一</th>
<th>primary key</th>
</tr>
</thead>
<tbody><tr>
<td>唯一约束</td>
<td>约束数据内容唯一</td>
<td>unique</td>
</tr>
<tr>
<td>外键约束</td>
<td>表之间引用完整</td>
<td>foreign key</td>
</tr>
<tr>
<td>非空约束</td>
<td>使该字段值不为空</td>
<td>not null</td>
</tr>
<tr>
<td>检查约束</td>
<td>限制值的范围</td>
<td>check(条件)</td>
</tr>
<tr>
<td>默认约束</td>
<td>默认值</td>
<td>default</td>
</tr>
<tr>
<td>自增约束</td>
<td>未指定值时按上一条数据的值加一</td>
<td>auto_increment</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>使两张表建立联系,保证数据的一致性和完整性</p>
<p>具有外键的表成为子表,子表关联的表称为父表(主表)</p>
<ul>
<li><p>添加外键</p>
<ul>
<li><p><code>alter table 表名 add constraint [外键名称] foreign key(外键字段名) references 主表(主表列表名)</code></p>
</li>
<li><p><code>alter table storage add constraint foreign key(ID) references oil(ID);</code></p>
</li>
<li><pre><code class="sql">create table 表名(
    字段名 数据类型,
    ...
    [constraint] [外键名称] foreign key(外键字段名) references 主表(主表列表名)
);
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="删除更新外键"><a href="#删除更新外键" class="headerlink" title="删除更新外键"></a>删除更新外键</h2><ul>
<li><code>no action</code> <code>restrict</code> 父表中删除或更新时,若子表有关联数据则不允许操作</li>
<li><code>cascade</code> 父表中进行删除更新时,若有外键则对外键同步进行删除或更新</li>
<li><code>set null</code>父表中进行删除或更新时,若有外键,则把外键设置为null</li>
<li><code>set default</code>父表中进行删除或更新时,将外键设置为一个默认值</li>
</ul>
<p>​	设置约束条件需要在创建时设置,不能在后续修改,若要修改,要先删除原有的约束再创建新的约束</p>
<p><code>alter table 表名 add constraint 外键名称 foreign key(外键字段) references 主表名(主表字段名) on update 关键字 on delete 关键字;</code></p>
<h1 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h1><ul>
<li>表外添加 <code>alter table 表名 add primary key (字段名);</code></li>
<li>撤销 <code>alter table 表名 drop primary key;</code></li>
</ul>
<h1 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h1><p>添加方式与主键约束相似</p>
<h1 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h1><p>添加方式与主键约束相送</p>
<h1 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h1><ul>
<li>表外添加 <code>alter table 表名 add 字段名 default 默认值</code></li>
<li>撤销 <code>drop defautl</code></li>
</ul>
<h1 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h1><ul>
<li>表外添加 <code>alter table 表名 add 字段名 check(条件列表)</code><ul>
<li>检查约束会约束 值必须使条件列表为真</li>
</ul>
</li>
<li>撤销 <code>drop check 字段名</code></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>五子棋</title>
    <url>/2023/01/07/%E4%BA%94%E5%AD%90%E6%A3%8B/</url>
    <content><![CDATA[<h1 id="java实现五子棋"><a href="#java实现五子棋" class="headerlink" title="java实现五子棋"></a>java实现五子棋</h1><span id="more"></span>

<h2 id="一-结构"><a href="#一-结构" class="headerlink" title="一.结构"></a>一.结构</h2><p>通过图形化编程,实现在15*15的棋盘上进行五子棋游戏,含有悔棋,录制和逐步回放功能,实现以上各功能的类和接口如下</p>
<ol>
<li>GoBangUI  </li>
<li>GoListener</li>
<li>GoData</li>
<li>StartButtonListener</li>
<li>RepetanceButtonListener</li>
<li>EndButtonListener</li>
<li>PlayBackListener</li>
<li>PlayBackUI</li>
<li>NextListener</li>
<li>LastListener</li>
</ol>
<!--more-->

<h2 id="二-功能实现"><a href="#二-功能实现" class="headerlink" title="二.功能实现"></a>二.功能实现</h2><h3 id="1-GoBangUI"><a href="#1-GoBangUI" class="headerlink" title="1.GoBangUI"></a>1.GoBangUI</h3><p> 构建游戏窗口,容纳棋盘,棋子和各按钮,继承<code>JFrame</code>类</p>
<p>在构造函数中绘制棋盘,使用空布局设定”开始游戏”按钮,”悔棋”按钮,”结束游戏”按钮和”回放”按钮的位置,并为各按钮设置监听器</p>
<p>重写<code>JFrame</code>类中的<code>paint()</code>方法,使窗口改变布局时重新显示按钮,棋盘和棋子,其中棋子的数据存放在<code>GoData</code>接口中</p>
<p>在该类中定义静态<code>GoBangUI</code> 对象 ui,以便于在悔棋和结束游戏时在监听器中调用ui对象来进行重新绘制</p>
<p>在该类中定义程序入口,执行<code>ui=new GoBangUI();</code></p>
<p>完整代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoBangUI</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> <span class="keyword">implements</span> <span class="title class_">GoData</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> GoBangUI ui;</span><br><span class="line">    <span class="type">GoListener</span> <span class="variable">gl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoListener</span>();</span><br><span class="line">    <span class="keyword">static</span> JButton start=<span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> JButton repentance=<span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> JButton end=<span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> JButton playBack=<span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> EndButtonListener endListener=<span class="keyword">new</span> <span class="title class_">EndButtonListener</span>();</span><br><span class="line">    <span class="keyword">static</span> RepetanceButtonListener repentanceListener=<span class="keyword">new</span> <span class="title class_">RepetanceButtonListener</span>();</span><br><span class="line">    <span class="keyword">static</span> StartButtonListener startListener=<span class="keyword">new</span> <span class="title class_">StartButtonListener</span>();</span><br><span class="line">    <span class="keyword">static</span> PlayBackListener playBackListener=<span class="keyword">new</span> <span class="title class_">PlayBackListener</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GoBangUI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//初始化棋盘数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ROW;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;COL;++j)&#123;</span><br><span class="line">                Data[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setTitle(<span class="string">&quot;五子棋&quot;</span>);</span><br><span class="line">        setSize(<span class="number">700</span>,<span class="number">750</span>);</span><br><span class="line">        setDefaultCloseOperation(EXIT_ON_CLOSE);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setLayout(<span class="literal">null</span>);</span><br><span class="line">        addMouseListener(gl);</span><br><span class="line">        gl.g=getGraphics(); <span class="comment">//传递了一个引用?</span></span><br><span class="line">        <span class="comment">//开始按钮</span></span><br><span class="line">        start.addActionListener(startListener);</span><br><span class="line">        start.setText(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">        <span class="comment">//Dimension startDimension=new Dimension();</span></span><br><span class="line">        <span class="comment">//startDimension.setSize(80,30);</span></span><br><span class="line">        <span class="comment">//start.setPreferredSize(startDimension);</span></span><br><span class="line">        start.setBounds(<span class="number">100</span>,<span class="number">10</span>,<span class="number">120</span>,<span class="number">30</span>);</span><br><span class="line">        add(start);</span><br><span class="line">        <span class="comment">//悔棋按钮</span></span><br><span class="line">        repentance.addActionListener(repentanceListener);</span><br><span class="line">        repentance.setText(<span class="string">&quot;悔棋&quot;</span>);</span><br><span class="line">        repentance.setBounds(<span class="number">250</span>,<span class="number">10</span>,<span class="number">120</span>,<span class="number">30</span>);</span><br><span class="line">        add(repentance);</span><br><span class="line">        <span class="comment">//结束按钮</span></span><br><span class="line">        end.addActionListener(endListener);</span><br><span class="line">        end.setText(<span class="string">&quot;结束游戏&quot;</span>);</span><br><span class="line">        end.setBounds(<span class="number">400</span>,<span class="number">10</span>,<span class="number">120</span>,<span class="number">30</span>);</span><br><span class="line">        add(end);</span><br><span class="line">        <span class="comment">//回放按钮</span></span><br><span class="line">        playBack.addActionListener(playBackListener);</span><br><span class="line">        playBack.setText(<span class="string">&quot;回放&quot;</span>);</span><br><span class="line">        playBack.setBounds(<span class="number">550</span>,<span class="number">10</span>,<span class="number">120</span>,<span class="number">30</span>);</span><br><span class="line">        add(playBack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span>&#123;</span><br><span class="line">        start.repaint();</span><br><span class="line">        repentance.repaint();</span><br><span class="line">        end.repaint();</span><br><span class="line">        playBack.repaint();</span><br><span class="line">        <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">79</span>, <span class="number">227</span>, <span class="number">165</span>);</span><br><span class="line">        g.setColor(color);</span><br><span class="line">        g.fillRect(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight());</span><br><span class="line">        g.setColor(Color.BLACK);</span><br><span class="line">        <span class="comment">//绘制棋盘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ROW;++i)&#123;</span><br><span class="line">            g.drawLine(X,Y+i*SIZE,X+(ROW-<span class="number">1</span>)*SIZE,Y+i*SIZE);</span><br><span class="line">            g.drawLine(X+i*SIZE,Y,X+i*SIZE,Y+(COL-<span class="number">1</span>)*SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复棋盘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ROW;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;COL;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Data[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    g.setColor(Color.black);</span><br><span class="line">                    g.fillOval(X+i*SIZE-SIZE/<span class="number">2</span>,Y+j*SIZE-SIZE/<span class="number">2</span>,SIZE,SIZE);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Data[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                    g.setColor(Color.white);</span><br><span class="line">                    g.fillOval(X+i*SIZE-SIZE/<span class="number">2</span>,Y+j*SIZE-SIZE/<span class="number">2</span>,SIZE,SIZE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ui = <span class="keyword">new</span> <span class="title class_">GoBangUI</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-GoListener"><a href="#2-GoListener" class="headerlink" title="2.GoListener"></a>2.GoListener</h3><p>​	该类实现MouseListener接口,对鼠标进行监听,当按下重写mousePressed方法,当按下鼠标时获取鼠标指针的位置,根据位置判断出该棋子的行数和列数,将其显示在棋盘上并存储在GoData中的Data二维数组中记录棋子信息,还存储在双向队列 Rows和Cols中,用于录制该棋局的每一步操作用于回放.</p>
<p>​	在该类中实现isEnd(int r,int c)方法,用于判断是否出现五个相同的棋子连在一起的情况,判断输赢</p>
<p>​	完整代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoListener</span> <span class="keyword">implements</span> <span class="title class_">MouseListener</span>, GoData &#123;</span><br><span class="line">    Graphics g;</span><br><span class="line">    <span class="comment">//黑子先走</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">chessFlag</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//0:不能下棋,1:黑棋,2:白棋</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEnd</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> r;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> c;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] x = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] y = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; ) &#123;</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            row = r + x[i];</span><br><span class="line">            col = c + y[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row &gt;= ROW || row &lt; <span class="number">0</span> || col &gt;= COL || col &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Data[row][col] == Data[r][c]) &#123;</span><br><span class="line">                    sum += <span class="number">1</span>;</span><br><span class="line">                    row += x[i];</span><br><span class="line">                    col += y[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            row = r + x[i + <span class="number">1</span>];</span><br><span class="line">            col = c + y[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row &gt;= ROW || row &lt; <span class="number">0</span> || col &gt;= COL || col &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Data[row][col] == Data[r][c]) &#123;</span><br><span class="line">                    sum += <span class="number">1</span>;</span><br><span class="line">                    row += x[i + <span class="number">1</span>];</span><br><span class="line">                    col += y[i + <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum &gt;= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent event)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> event.getX();</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> event.getY();</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算x,y坐标对应的行列</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= X) &#123;</span><br><span class="line">            row = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= ROW * SIZE + X) &#123;</span><br><span class="line">            row = ROW - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row = ((x - X) / SIZE) + ((x - X) % SIZE &gt; SIZE / <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= Y) &#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y &gt;= COL * SIZE + Y) &#123;</span><br><span class="line">            col = COL - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            col = ((y - Y) / SIZE) + ((y - Y) % SIZE &gt; SIZE / <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chessFlag == <span class="number">0</span>) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;请先开始游戏&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该位置没有棋子</span></span><br><span class="line">        <span class="keyword">if</span> (Data[row][col] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//录制棋局</span></span><br><span class="line">            Rows.addLast(row);</span><br><span class="line">            Cols.addLast(col);</span><br><span class="line">            <span class="keyword">if</span> (chessFlag == <span class="number">1</span>) &#123;</span><br><span class="line">                Data[row][col] = chessFlag;</span><br><span class="line">                g.setColor(Color.black);</span><br><span class="line">                g.fillOval(X + row * SIZE - SIZE / <span class="number">2</span>, Y + col * SIZE - SIZE / <span class="number">2</span>, SIZE, SIZE);</span><br><span class="line">                <span class="keyword">if</span> (isEnd(row, col)) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;黑子获胜&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                chessFlag = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chessFlag == <span class="number">2</span>) &#123;</span><br><span class="line">                Data[row][col] = chessFlag;</span><br><span class="line">                g.setColor(Color.white);</span><br><span class="line">                g.fillOval(X + row * SIZE - SIZE / <span class="number">2</span>, Y + col * SIZE - SIZE / <span class="number">2</span>, SIZE, SIZE);</span><br><span class="line">                <span class="keyword">if</span> (isEnd(row, col)) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;白子获胜&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                chessFlag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent event)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseReleased</span><span class="params">(MouseEvent event)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseEntered</span><span class="params">(MouseEvent event)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseExited</span><span class="params">(MouseEvent event)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-GoData"><a href="#3-GoData" class="headerlink" title="3.GoData"></a>3.GoData</h3><p>该接口用于设置棋盘的行列数,间距,棋盘左上角坐标以及存储当局棋子信息和回放棋子信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GoData</span> &#123;</span><br><span class="line">    <span class="type">int</span> X=<span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> Y=<span class="number">110</span>;</span><br><span class="line">    <span class="type">int</span> SIZE=<span class="number">40</span>;</span><br><span class="line">    <span class="type">int</span> ROW=<span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> COL=<span class="number">15</span>;</span><br><span class="line">    <span class="comment">//List&lt;Integer&gt; rows=new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">    <span class="comment">//List&lt;Integer&gt; cols=new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">    Deque&lt;Integer&gt; Rows=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; Cols=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">int</span>[][] Data=<span class="keyword">new</span> <span class="title class_">int</span>[ROW+<span class="number">1</span>][COL+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[][] PlayBackData=<span class="keyword">new</span> <span class="title class_">int</span>[ROW+<span class="number">1</span>][COL+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-StartButtonListener"><a href="#4-StartButtonListener" class="headerlink" title="4.StartButtonListener"></a>4.StartButtonListener</h3><p>用于监听开始按钮,按下开始按钮后设置<code>chessFlag</code>&#x3D;1,即黑子先走,并情况上一局的回放信息以记录本局的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>,GoData &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(GoListener.chessFlag!=<span class="number">0</span>)&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;游戏已经开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//黑子先走</span></span><br><span class="line">        PlayBackUI.round+=<span class="number">1</span>;</span><br><span class="line">        GoListener.chessFlag=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//清空回放记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ROW;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;COL;++j)&#123;</span><br><span class="line">                PlayBackData[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PlayBackUI.cur=<span class="number">0</span>;</span><br><span class="line">        GoData.Rows.clear();</span><br><span class="line">        GoData.Cols.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-RepetanceButtonListener"><a href="#5-RepetanceButtonListener" class="headerlink" title="5.RepetanceButtonListener"></a>5.RepetanceButtonListener</h3><p>监听悔棋按钮,当按下悔棋按钮后通过Rows和Cols获取上一步的信息,将其从棋局中和录制信息中删去,并通过GoBangUI.ui调用paint刷新棋盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepetanceButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>, GoData &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//获取最后一步</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> Rows.getLast();</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> Cols.getLast();</span><br><span class="line">        <span class="comment">//清除最后一步</span></span><br><span class="line">        Data[row][col] = <span class="number">0</span>;</span><br><span class="line">        GoListener.chessFlag=GoListener.chessFlag==<span class="number">1</span>?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">        Rows.removeLast();</span><br><span class="line">        Cols.removeLast();</span><br><span class="line">        <span class="comment">//重新绘制棋盘</span></span><br><span class="line">        GoBangUI.ui.paint(GoBangUI.ui.getGraphics());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-EndButtonListener"><a href="#6-EndButtonListener" class="headerlink" title="6.EndButtonListener"></a>6.EndButtonListener</h3><p>监听结束游戏按钮,当按下结束游戏按钮后清空棋盘,设置chessFlag&#x3D;0等待下局游戏开始,并刷新棋盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>,GoData&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//清空棋盘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ROW;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;COL;++j)&#123;</span><br><span class="line">                Data[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        GoListener.chessFlag=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//重新绘制棋盘</span></span><br><span class="line">        GoBangUI.ui.paint(GoBangUI.ui.getGraphics());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-PlayBackListener"><a href="#7-PlayBackListener" class="headerlink" title="7.PlayBackListener"></a>7.PlayBackListener</h3><p>监听回放按钮,当按下回放按钮后创建<code>PlayBackUI</code>对象并将总步数传递给<code>PlayBackUI</code>中的静态变量<code>sum</code>,用于判断回放时是否还有下一步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayBackListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        PlayBackUI.sum=GoData.Rows.size();</span><br><span class="line">        PlayBackUI.ui= <span class="keyword">new</span> <span class="title class_">PlayBackUI</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-PlayBackUI"><a href="#8-PlayBackUI" class="headerlink" title="8.PlayBackUI"></a>8.PlayBackUI</h3><p>回放棋局的窗口,含有上一步按钮和下一步按钮,通过点击按钮来操作回放,创建静态<code>PlayBackUI</code>对象<code>ui</code>用于在监听器中刷新界面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayBackUI</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> <span class="keyword">implements</span> <span class="title class_">GoData</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">round</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//总步数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Rows.size();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//当前步数</span></span><br><span class="line">    <span class="keyword">static</span> PlayBackUI ui;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">JButton</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">JButton</span> <span class="variable">last</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">NextListener</span> <span class="variable">nextListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NextListener</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">LastListener</span> <span class="variable">lastListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LastListener</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PlayBackUI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化棋盘数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">                Data[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setTitle(<span class="string">&quot;回放&quot;</span>);</span><br><span class="line">        setSize(<span class="number">700</span>, <span class="number">750</span>);</span><br><span class="line">        setDefaultCloseOperation(DISPOSE_ON_CLOSE);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setLayout(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//下一步按钮</span></span><br><span class="line">        <span class="keyword">if</span>(round==<span class="number">1</span>) &#123;</span><br><span class="line">            next.addActionListener(nextListener);</span><br><span class="line">            last.addActionListener(lastListener);</span><br><span class="line">        &#125;</span><br><span class="line">        next.setText(<span class="string">&quot;下一步&quot;</span>);</span><br><span class="line">        next.setBounds(<span class="number">400</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">        add(next);</span><br><span class="line">        <span class="comment">//上一步按钮</span></span><br><span class="line">        last.setText(<span class="string">&quot;上一步&quot;</span>);</span><br><span class="line">        last.setBounds(<span class="number">200</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">        add(last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">                PlayBackData[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">        next.repaint();</span><br><span class="line">        last.repaint();</span><br><span class="line">        <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">79</span>, <span class="number">227</span>, <span class="number">165</span>);</span><br><span class="line">        g.setColor(color);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">        g.setColor(Color.BLACK);</span><br><span class="line">        <span class="comment">//绘制棋盘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">            g.drawLine(X, Y + i * SIZE, X + (ROW - <span class="number">1</span>) * SIZE, Y + i * SIZE);</span><br><span class="line">            g.drawLine(X + i * SIZE, Y, X + i * SIZE, Y + (COL - <span class="number">1</span>) * SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复棋盘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (PlayBackData[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    g.setColor(Color.black);</span><br><span class="line">                    g.fillOval(X + i * SIZE - SIZE / <span class="number">2</span>, Y + j * SIZE - SIZE / <span class="number">2</span>, SIZE, SIZE);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PlayBackData[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    g.setColor(Color.white);</span><br><span class="line">                    g.fillOval(X + i * SIZE - SIZE / <span class="number">2</span>, Y + j * SIZE - SIZE / <span class="number">2</span>, SIZE, SIZE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-NextListener"><a href="#9-NextListener" class="headerlink" title="9.NextListener"></a>9.NextListener</h3><p>监听回放窗口中的下一步按钮,按下按钮后先判断是否还有下一步,然后通过<code>GoData</code>中的<code>Rows</code>和<code>Cols</code>获取下一步棋的位置信息,将其绘制在棋盘中</p>
<p>将双向队列的队头出队后从队尾入队,使在执行上一步操作时获取上一步棋的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NextListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>,GoData&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//获取下一步并录入到回放棋盘中</span></span><br><span class="line">        <span class="keyword">if</span>(PlayBackUI.cur&lt;PlayBackUI.sum)&#123;</span><br><span class="line">            <span class="type">int</span> row=Rows.getFirst();</span><br><span class="line">            <span class="type">int</span> col=Cols.getFirst();</span><br><span class="line">            Rows.addLast(row);</span><br><span class="line">            Cols.addLast(col);</span><br><span class="line">            Rows.removeFirst();</span><br><span class="line">            Cols.removeFirst();</span><br><span class="line">            PlayBackData[row][col]=(PlayBackUI.cur%<span class="number">2</span>)==<span class="number">0</span>?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">            PlayBackUI.cur+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;没有下一步了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PlayBackUI.ui.paint(PlayBackUI.ui.getGraphics());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-LastListener"><a href="#10-LastListener" class="headerlink" title="10.LastListener"></a>10.LastListener</h3><p>监听回放窗口中的上一步按钮,按下按钮后先判断是否还有上一步,然后通过<code>GoData</code>中的<code>Rows</code>和<code>Cols</code>获取上一步棋的位置信息,将其绘制在棋盘中</p>
<p>将双向队列的队尾出队后从队头入队,使在执行下一步操作时获取下一步棋的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LastListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>,GoData&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//获取下一步并录入到回放棋盘中</span></span><br><span class="line">        <span class="keyword">if</span>(PlayBackUI.cur&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> row=Rows.getLast();</span><br><span class="line">            <span class="type">int</span> col=Cols.getLast();</span><br><span class="line">            Rows.removeLast();</span><br><span class="line">            Cols.removeLast();</span><br><span class="line">            Rows.addFirst(row);</span><br><span class="line">            Cols.addFirst(col);</span><br><span class="line">            PlayBackData[row][col]=<span class="number">0</span>;</span><br><span class="line">            PlayBackUI.cur-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;没有上一步了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PlayBackUI.ui.paint(PlayBackUI.ui.getGraphics());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>hello 2023</title>
    <url>/2023/01/10/hello-2023/</url>
    <content><![CDATA[<h1 id="C-Least-Prefix-Sum"><a href="#C-Least-Prefix-Sum" class="headerlink" title="C     Least Prefix Sum"></a>C     Least Prefix Sum</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题:"></a>原题:</h2><p><a href="https://codeforces.com/contest/1779/problem/C"><strong>Least Prefix Sum</strong></a></p>
<span id="more"></span>

<blockquote>
<p>Baltic, a famous chess player who is also a mathematician, has an array a1,a2,…,ana1,a2,…,an, and he can perform the following operation several (possibly 00) times:</p>
<ul>
<li>Choose some index ii (1≤i≤n1≤i≤n);</li>
<li>multiply aiai with −1−1, that is, set ai:&#x3D;−aiai:&#x3D;−ai.</li>
</ul>
<p>Baltic’s favorite number is mm, and he wants a1+a2+⋯+ama1+a2+⋯+am to be the smallest of all non-empty prefix sums. More formally, for each k&#x3D;1,2,…,nk&#x3D;1,2,…,n it should hold that</p>
<p>a1+a2+⋯+ak≥a1+a2+⋯+am.a1+a2+⋯+ak≥a1+a2+⋯+am.</p>
<p>Please note that multiple smallest prefix sums may exist and that it is only required that a1+a2+⋯+ama1+a2+⋯+am is one of them.</p>
<p>Help Baltic find the minimum number of operations required to make a1+a2+⋯+ama1+a2+⋯+am the least of all prefix sums. It can be shown that a valid sequence of operations always exists.</p>
<p>Input</p>
<p>Each test contains multiple test cases. The first line contains the number of test cases tt (1≤t≤100001≤t≤10000). The description of the test cases follows.</p>
<p>The first line of each test case contains two integers nn and mm (1≤m≤n≤2⋅1051≤m≤n≤2⋅105) — the size of Baltic’s array and his favorite number.</p>
<p>The second line contains nn integers a1,a2,…,ana1,a2,…,an (−109≤ai≤109−109≤ai≤109) — the array.</p>
<p>It is guaranteed that the sum of nn over all test cases does not exceed 2⋅1052⋅105.</p>
<p>Output</p>
<p>For each test case, print a single integer — the minimum number of required operations.</p>
</blockquote>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>进行res次操作 ai&#x3D;-ai,使得给出的数列和一个下标m</p>
<p>得到使数列和Sm的值小于或等于其他所有数列和Si(1&lt;&#x3D;i&lt;&#x3D;长度),求最小操作次数</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要使Sm的值小于等于其它数列和</p>
<p>当下标大于m时,am+1…ai(m+1&lt;&#x3D;i&lt;&#x3D;n)的值全部都要小于等于零,使得Sm加上后面的数之后的值都小于等于Sm以满足限制</p>
<p>当下标小于等于m时,am,am-1…a1(1&lt;i**&lt;&#x3D;<strong>m)的值全部都要大于等于零,使得Sm减去以am起始的下标递减的数列和时得到的Si(1&lt;&#x3D;i</strong>&lt;**m)全部小于等于Sm,以满足限制.</p>
<p>向前判断时不能把a1加入判断,因为判断完Sm-a1的值大于等于0后,S1&#x3D;a1&#x3D;Sm-(Sm-a1)已满足限制,若再次判断a1,会使限制增加导致结果错误</p>
<p>使用大根堆来选取向前时的最大值和向后时的最大值,时操作次数最小</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t, n, m,res,min;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">200001</span>];</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">		priority_queue&lt;<span class="type">int</span>&gt; pre, pos;</span><br><span class="line">		cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line">		m = m - <span class="number">1</span>;</span><br><span class="line">		sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			cin &gt;&gt; arr[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;<span class="number">0</span> ; --j) &#123;<span class="comment">//为什么大于0而不是大于等于0</span></span><br><span class="line">			<span class="comment">//因为往前时要保证大于零使Sm小于Sa,即m向前m-a个数的和大于0,不包括a,即结束时不应包括第1个,否则增多了限制使结果出错</span></span><br><span class="line">			sum += arr[j];</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; <span class="number">0</span>) pre.<span class="built_in">push</span>(<span class="number">2</span> * arr[j]);</span><br><span class="line">			<span class="keyword">while</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				sum -= pre.<span class="built_in">top</span>();</span><br><span class="line">				pre.<span class="built_in">pop</span>();</span><br><span class="line">				res++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			sum += arr[j];</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; <span class="number">0</span>) pos.<span class="built_in">push</span>(<span class="number">-2</span> * arr[j]);</span><br><span class="line">			<span class="keyword">while</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				sum += pos.<span class="built_in">top</span>();</span><br><span class="line">				pos.<span class="built_in">pop</span>();</span><br><span class="line">				res += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Boris-and-His-Amazing-Haircut"><a href="#D-Boris-and-His-Amazing-Haircut" class="headerlink" title="D Boris and His Amazing Haircut"></a>D Boris and His Amazing Haircut</h1><p><strong><a href="https://codeforces.com/contest/1779/problem/D">Boris and His Amazing Haircut</a></strong></p>
<h2 id="原题-1"><a href="#原题-1" class="headerlink" title="原题"></a>原题</h2><blockquote>
<p>Boris thinks that chess is a tedious game. So he left his tournament early and went to a barber shop as his hair was a <em>bit</em> messy.</p>
<p>His current hair can be described by an array a1,a2,…,ana1,a2,…,an, where aiai is the height of the hair standing at position ii. His desired haircut can be described by an array b1,b2,…,bnb1,b2,…,bn in a similar fashion.</p>
<p>The barber has mm razors. Each has its own size and can be used <strong>at most</strong> once. In one operation, he chooses a razor and cuts a segment of Boris’s hair. More formally, an operation is:</p>
<ul>
<li>Choose any razor which hasn’t been used before, let its size be xx;</li>
<li>Choose a segment [l,r][l,r] (1≤l≤r≤n1≤l≤r≤n);</li>
<li>Set ai:&#x3D;min(ai,x)ai:&#x3D;min(ai,x) for each l≤i≤rl≤i≤r;</li>
</ul>
<p>Notice that some razors might have equal sizes — the barber can choose some size xx only as many times as the number of razors with size xx.</p>
<p>He may perform as many operations as he wants, as long as any razor is used at most once and ai&#x3D;biai&#x3D;bi for each 1≤i≤n1≤i≤n at the end. He <strong>does not</strong> have to use all razors.</p>
<p>Can you determine whether the barber can give Boris his desired haircut?</p>
<p>Input</p>
<p>Each test contains multiple test cases. The first line contains the number of test cases tt (1≤t≤200001≤t≤20000). The description of the test cases follows.</p>
<p>The first line of each test case contains a positive integer nn (3≤n≤2⋅1053≤n≤2⋅105) — the length of arrays aa and bb.</p>
<p>The second line of each test case contains nn positive integers a1,a2,…,ana1,a2,…,an (1≤ai≤1091≤ai≤109)  — Boris’s current hair.</p>
<p>The third line of each test case contains nn positive integers b1,b2,…,bnb1,b2,…,bn (1≤bi≤1091≤bi≤109)  — Boris’s desired hair.</p>
<p>The fourth line of each test case contains a positive integer mm (1≤m≤2⋅1051≤m≤2⋅105)  — the number of razors.</p>
<p>The fifth line of each test case contains mm positive integers x1,x2,…,xmx1,x2,…,xm (1≤xi≤1091≤xi≤109)  — the sizes of the razors.</p>
<p>It is guaranteed that the sum of nn and the sum of mm over all test cases do not exceed 2⋅1052⋅105.</p>
<p>Output</p>
<p>For each test case, print “YES” if the barber can cut Boris’s hair as desired. Otherwise, print “NO”.</p>
<p>You can output the answer in any case (upper or lower). For example, the strings “yEs”, “yes”, “Yes”, and “YES” will be recognized as positive responses.</p>
</blockquote>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>如果头发比要求的还要短,直接输出”NO”</p>
<p>使用单调栈遍历目标数组,使用哈希表存储各推子的数数量,当栈不为空且栈的头元素小于遍历到的目标元素时不断出栈,当栈为空或栈顶元素不等于遍历到的元素且相应元素需要改变时,将该元素入栈,如果没有正确的推子剩余则输出”NO”,若有剩余则推子数减一</p>
<p>通过遍历所有元素,即可判断是否可以满足条件</p>
<p>因为如果头发的长度比上一个头发小,那么该头发必须消耗相应的推子,遇到长度大于上一个头发的时候,不断出栈直到栈顶不小于该头发,若该两头发值相等,则不需要再消耗推子,若不一样,则需要消耗相应推子,需要使用推子时推子数量需要大于0</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t, n, m,i,j,in,res;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">200001</span>], b[<span class="number">200001</span>];</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mapp;</span><br><span class="line">		stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			cin &gt;&gt; a[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			cin &gt;&gt; b[j];</span><br><span class="line">		&#125;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">			cin &gt;&gt; in;</span><br><span class="line">			mapp[in] += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		res = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; b[j]) &#123;</span><br><span class="line">				res = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() &lt; b[j]) &#123; stk.<span class="built_in">pop</span>(); &#125;</span><br><span class="line">			<span class="keyword">if</span> ((stk.<span class="built_in">empty</span>() || (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() != b[j])) &amp;&amp; a[j] &gt; b[j]) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(b[j]);</span><br><span class="line">				<span class="keyword">if</span> (mapp[b[j]] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					res = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				mapp[b[j]] -= <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (res) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Anya’s-Simultaneous-Exhibition"><a href="#E-Anya’s-Simultaneous-Exhibition" class="headerlink" title="E Anya’s Simultaneous Exhibition"></a>E Anya’s Simultaneous Exhibition</h1>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D脚本应用</title>
    <url>/2023/01/13/Unity3D%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<ol>
<li>场景</li>
<li>异步加载场景</li>
<li>Transform</li>
<li>键鼠监听</li>
<li>虚拟轴</li>
<li>触摸监听</li>
<li>灯光</li>
<li>摄像机</li>
<li>声音</li>
<li>视频</li>
</ol>
<span id="more"></span>

<h1 id="1-场景"><a href="#1-场景" class="headerlink" title="1.场景"></a>1.场景</h1><p>不同场景含有不同物体 </p>
<h3 id="场景类-Scene"><a href="#场景类-Scene" class="headerlink" title="场景类: Scene"></a>场景类: Scene</h3><ul>
<li><p>场景跳转</p>
<ul>
<li>导入UnityEngine.SceneManagement </li>
<li>SceneManager.LoadScene()通过索引或名称加载目标场景</li>
</ul>
</li>
<li><p>获取当前场景 Scene s&#x3D;SceneManager.GetActiveScene()</p>
</li>
<li><p>场景是否已被加载 scene.isLoaded</p>
</li>
</ul>
<h3 id="场景管理类-SceneManager"><a href="#场景管理类-SceneManager" class="headerlink" title="场景管理类 SceneManager"></a>场景管理类 SceneManager</h3><ul>
<li>创建场景 CreateScene(场景名)</li>
<li>卸载场景 UnloadScene()</li>
<li>加载场景 LoadScene()</li>
<li>异步加载场景 LoadSceneAsync()</li>
</ul>
<h1 id="2-异步加载场景"><a href="#2-异步加载场景" class="headerlink" title="2.异步加载场景"></a>2.异步加载场景</h1><p>创建一个协程方法,用来异步加载场景,返回值必须是IEnumerator</p>
<ul>
<li>StartCoroutine(loadScene()); 用来调用自己写的协程方法 loadScene</li>
<li>获取加载进度</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/13/JanedLxI2mXCu4c.png" alt="BY__32S6_F_GYDTN_EAJH_S.png"></p>
<h1 id="3-Transform"><a href="#3-Transform" class="headerlink" title="3.Transform"></a>3.Transform</h1><ul>
<li><p>通过Transform控制物体姿态</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TransFormTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取位置</span></span><br><span class="line">        Debug.Log(transform.position); <span class="comment">//绝对位置</span></span><br><span class="line">        Debug.Log(transform.localPosition); <span class="comment">//相对于父物体的位置</span></span><br><span class="line">        <span class="comment">//获取旋转</span></span><br><span class="line">        Debug.Log(transform.rotation);  <span class="comment">//四元数</span></span><br><span class="line">        Debug.Log(transform.localRotation);</span><br><span class="line">        Debug.Log(transform.eulerAngles);   <span class="comment">//欧拉角</span></span><br><span class="line">        Debug.Log(transform.localEulerAngles);</span><br><span class="line">        <span class="comment">//获取缩放</span></span><br><span class="line">        Debug.Log(transform.localScale);</span><br><span class="line">        <span class="comment">//向量</span></span><br><span class="line">        Debug.Log(transform.forward);</span><br><span class="line">        Debug.Log(transform.right); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一直朝向原点</span></span><br><span class="line">        transform.LookAt(Vector3.zero);</span><br><span class="line">        <span class="comment">//旋转</span></span><br><span class="line">        transform.Rotate(Vector3.up,<span class="number">1</span>); <span class="comment">//沿up方向,每一帧旋转1度</span></span><br><span class="line">        <span class="comment">//绕某个物体旋转</span></span><br><span class="line">        transform.RotateAround(Vector3.zero, Vector3.up, <span class="number">1</span>); <span class="comment">//沿原点up方向每一帧旋转1度</span></span><br><span class="line">        <span class="comment">//移动</span></span><br><span class="line">        transform.Translate(Vector3.forward*<span class="number">0.1f</span>); <span class="comment">//朝前方每一帧移动0.1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Transform控制父子关系</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父子关系</span></span><br><span class="line">        <span class="comment">//获取父物体</span></span><br><span class="line">        Debug.Log(transform.parent.gameObject);</span><br><span class="line">        <span class="comment">//子物体个数</span></span><br><span class="line">        Debug.Log(transform.childCount);</span><br><span class="line">        <span class="comment">//解除所有子物体</span></span><br><span class="line">        transform.DetachChildren();</span><br><span class="line">        <span class="comment">//获取子物体</span></span><br><span class="line">        Transform tanns = transform.Find(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">        Transform tans = transform.GetChild(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//判断是否是某一个物体的子物体</span></span><br><span class="line">        <span class="built_in">bool</span> res = transform.IsChildOf(transform);</span><br><span class="line">		<span class="comment">//设置父物体</span></span><br><span class="line">        tans.SetParent(transform);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-键鼠监听"><a href="#4-键鼠监听" class="headerlink" title="4.键鼠监听"></a>4.键鼠监听</h1><p>对键鼠的监听应在每一帧进行,因此应放在Update中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按下鼠标 0左键,1右键,2滚轮</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;按下鼠标左键&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//持续按下鼠标</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;持续按下鼠标左键&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//抬起鼠标</span></span><br><span class="line">        Input.GetMouseButtonUp(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//键盘按键</span></span><br><span class="line">        <span class="comment">//按下</span></span><br><span class="line">        Input.GetKeyDown(KeyCode.A); <span class="comment">//按下A</span></span><br><span class="line">        Input.GetKey(KeyCode.A); <span class="comment">//持续按下A</span></span><br><span class="line">        Input.GetKeyUp(KeyCode.A); <span class="comment">//松开A</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-虚拟轴"><a href="#5-虚拟轴" class="headerlink" title="5.虚拟轴"></a>5.虚拟轴</h1><p>用虚拟轴可以使用不同的方式来控制,令键盘和手柄都操作虚拟轴,使得游戏可以适配所有设备</p>
<p>虚拟轴的变换为 -1 — 0 — 1 浮点数渐变而不是直接从-1 到 0 或 从0 到 1</p>
<p>虚拟轴设置在设置-输入管理器中</p>
<p>若虚拟轴只有一个按钮(肯定或否定),则构不成虚拟轴,作为虚拟按键</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取水平轴</span></span><br><span class="line">        <span class="built_in">float</span> horizontal = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="comment">//获取虚拟按键</span></span><br><span class="line">        Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>); <span class="comment">//参数为虚拟按键名</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-触摸监听"><a href="#6-触摸监听" class="headerlink" title="6.触摸监听"></a>6.触摸监听</h1><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//开启多点触摸</span></span><br><span class="line">        Input.multiTouchEnabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断单点触摸 判断多点触摸时返回多个Touch对象,一个对象一个触摸点</span></span><br><span class="line">        <span class="keyword">if</span> (Input.touchCount == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Touch touch = Input.touches[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//触摸位置</span></span><br><span class="line">            Debug.Log(touch.position);</span><br><span class="line">            <span class="comment">//触摸阶段</span></span><br><span class="line">            <span class="keyword">switch</span> (touch.phase)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> TouchPhase.Began:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TouchPhase.Moved:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TouchPhase.Stationary:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TouchPhase.Ended:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TouchPhase.Canceled:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-灯光"><a href="#7-灯光" class="headerlink" title="7.灯光"></a>7.灯光</h1><ul>
<li>定向灯光,从无穷远的方向照射过来,平行光,只有灯光的角度会影响灯光效果,位置不会影响</li>
<li>聚光,手电筒式的灯光</li>
<li>点光源</li>
<li>区域灯光 ,从一个平面发射出的平行光,仅支持烘焙灯光</li>
<li>遮罩可以删除或添加某一图层的光照效果</li>
<li>实时灯光 ,消耗性能大</li>
<li>烘焙 ,提前设定好灯光效果,灯光照射信息不再改变,不消耗性能,删除灯光后渲染效果依旧存在<ul>
<li>在物体名称后的三角下选择Contribute GI来设置被烘焙</li>
<li>然后在   窗口—渲染 右下角生成照明</li>
</ul>
</li>
</ul>
<h1 id="8-摄像机"><a href="#8-摄像机" class="headerlink" title="8.摄像机"></a>8.摄像机</h1><ul>
<li>透视摄像机</li>
<li>正交摄像机 没有近大远小的透视效果</li>
<li>相机的深度来设定相机的优先度,深度越大越优先显示</li>
<li>改为仅深度后,深度较高的相机拍摄到的内容就会叠加到深度较低的相机上</li>
<li>视野 即相机显示的范围大小</li>
<li>近平面和远平面限定了摄像机能拍摄到的物体范围,两平面之间的立方体内的物体才能显示</li>
<li>Viewport矩阵 限定了摄像机在游戏屏幕中的显示位置和大小,使屏幕中可以出现多个摄像机的画面</li>
<li>目标显示 类似于信号源,可以设置摄像机显示在哪个窗口中</li>
<li>目标纹理 会覆盖目标显示,将摄像机拍摄到的画面实时加载到一个纹理上,可以将<strong>摄像机画面在游戏物体上显示</strong></li>
<li><em>Ctrl&#x2F;Cmd + Shift + F</em> 将选中的<em>摄像机</em>与Scene视图对齐</li>
</ul>
<h1 id="9-音频"><a href="#9-音频" class="headerlink" title="9.音频"></a>9.音频</h1><ul>
<li>音乐</li>
<li>音效</li>
<li>摄像机使用 Audio Listener 组件 用于播放声音</li>
<li>游戏物体使用 Audio Source 承载声音<ul>
<li>加载组件后会有两个球体,球体的范围即为发出声音的最小距离和最大声音</li>
</ul>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//AudioClip</span></span><br><span class="line">    <span class="keyword">public</span> AudioClip music;</span><br><span class="line">    <span class="keyword">public</span> AudioClip se;</span><br><span class="line">    <span class="comment">//播放器组件</span></span><br><span class="line">    <span class="keyword">private</span> AudioSource player;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        player=GetComponent&lt;AudioSource&gt;();</span><br><span class="line">        <span class="comment">//设定播放的音频</span></span><br><span class="line">        player.clip = music;</span><br><span class="line">        <span class="comment">//循环播放</span></span><br><span class="line">        player.loop = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//音量</span></span><br><span class="line">        player.volume = <span class="number">0.5f</span>;</span><br><span class="line">        <span class="comment">//播放</span></span><br><span class="line">        player.Play(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按下空格切换播放</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (player.isPlaying)</span><br><span class="line">            &#123;</span><br><span class="line">                player.Pause();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                player.UnPause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按鼠标左键播声音(音效)</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            player.PlayOneShot(se);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-视频"><a href="#10-视频" class="headerlink" title="10.视频"></a>10.视频</h1><p>类似于音频播放</p>
<ul>
<li>创建一个渲染器纹理</li>
<li>创建一个游戏物体作为载体</li>
<li>在平面上添加 Video Player组件 ,导入的视频对象类型为 VideoClip</li>
<li>渲染模式选择渲染器纹理</li>
<li>应用纹理就可以显示视频了</li>
</ul>
<h3 id="要使用VideoPlayer需要引入UnityEngine-Video"><a href="#要使用VideoPlayer需要引入UnityEngine-Video" class="headerlink" title="要使用VideoPlayer需要引入UnityEngine.Video"></a>要使用VideoPlayer需要引入UnityEngine.Video</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.Video;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VideoTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> VideoPlayer player;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//和音频一致</span></span><br><span class="line">            player.Play();</span><br><span class="line">            player.Stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D基础</title>
    <url>/2023/01/12/Unity3D%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ol>
<li>脚本生命周期方法				</li>
<li>多脚本执行顺序                   </li>
<li>标识                                       </li>
<li>预设体                                  </li>
<li>vector3</li>
<li>旋转</li>
<li>Debug</li>
<li>物体类</li>
<li>游戏时间</li>
<li>Application</li>
</ol>
<span id="more"></span>

<h1 id="1-脚本生命周期方法"><a href="#1-脚本生命周期方法" class="headerlink" title="1.脚本生命周期方法"></a>1.脚本生命周期方法</h1><p>按调用顺序排序</p>
<ol>
<li>Awake()  最早调用,一般在此实现单例模式</li>
<li>OnEnable()  组件激活后调用,在Awake后会调用一次</li>
<li>Start() 可以在此设置一些初始值</li>
<li>FixedUpdate() 固定频率调用方法,按规定时间间隔重复调用</li>
<li>Update() 帧调用方法,每一帧调用一次</li>
<li>LateUpdate() 在Update后紧接着调用</li>
<li>OnDisabel() 组件取消激活时调用</li>
<li>OnDestroy() 析构函数(移除组件时就会被调用)</li>
</ol>
<h1 id="2-多脚本执行顺序"><a href="#2-多脚本执行顺序" class="headerlink" title="2.多脚本执行顺序"></a>2.多脚本执行顺序</h1><ul>
<li><p>对于使用了相同生命周期方法,后添加的脚本先执行</p>
</li>
<li><p>对于不同生命周期方法,按上述优先级执行</p>
</li>
<li><p>在设置里选择脚本执行顺序,改变执行顺序</p>
</li>
</ul>
<h1 id="3-标识"><a href="#3-标识" class="headerlink" title="3.标识"></a>3.标识</h1><ul>
<li><p>图层,图层最多32层,图层的概念比标签大,通过图层控制相机,碰撞等</p>
</li>
<li><p>标签用来区分游戏物体类别,标签可以重复</p>
</li>
<li><p>名称是唯一的,通过名称来选取某一特定游戏物体</p>
</li>
</ul>
<h1 id="4-预设体"><a href="#4-预设体" class="headerlink" title="4.预设体"></a>4.预设体</h1><p>通过预设体创建变体,变体也受预设体影响,但对变体操作不影响预设体</p>
<h1 id="5-Vector3"><a href="#5-Vector3" class="headerlink" title="5.Vector3"></a>5.Vector3</h1><ul>
<li><p>vector: 结构体,后缀多少就意味着内部有几个变量,即是一个向量</p>
</li>
<li><p>vector3即三维向量,内含x,y,z三个变量,可以代表坐标或旋转量或缩放等</p>
<ul>
<li>vector3.zero即生成一个0,0,0的向量,用作右值,用于初始化</li>
<li>vector3.normalized 规范化为单位向量</li>
</ul>
</li>
</ul>
<h1 id="6-旋转"><a href="#6-旋转" class="headerlink" title="6.旋转"></a>6.旋转</h1><ul>
<li>欧拉角 用三个0-360的值代表旋转量</li>
<li>四元数 quaternion<ul>
<li>Quaternion.identity 创建一个没有旋转角度的四元数</li>
<li>Quaternion.LookRotation() 创建一个朝向目标的四元数</li>
</ul>
</li>
</ul>
<h1 id="7-Debug"><a href="#7-Debug" class="headerlink" title="7.Debug"></a>7.Debug</h1><ul>
<li>debug.log() 	输出信息</li>
<li>debug.logworning() 输出警告信息</li>
<li>debug.logerror() 输出错误信息</li>
<li>debug还可以绘制线段,射线等</li>
</ul>
<p>debug输出的信息或绘制的内容只能在开发者视角看到,游戏中不会显示</p>
<h1 id="8-物体类"><a href="#8-物体类" class="headerlink" title="8.物体类"></a>8.物体类</h1><p>每一个游戏物体都对应一个C#物体类 <a href="https://www.bilibili.com/video/BV1gQ4y1e7SS?p=24">详细视频</a> </p>
<ul>
<li><p>GameObject go&#x3D;this.gameObject 获取当前脚本挂载的游戏物体,也可以直接gameObject.方法来对游戏物体进行操作</p>
</li>
<li><p>可以在一个脚本里创建一个物体,然后通过该物体使得在本物体中改变其他物体 <em>5min</em></p>
</li>
<li><p>获取transfrom组件 this.transform</p>
</li>
<li><p>获取其他组件 GetComponent&lt;类型名称&gt;();</p>
</li>
<li><p>添加组件 AddComponent&lt;组件类型名&gt;();</p>
</li>
<li><p>通过物体名称获取物体 GameObject.find(string name);</p>
</li>
<li><p>通过物体标签获取物体 GameObject.FindWithTag(string tag);</p>
</li>
<li><p>获取预设体 ,可以通过预设体实例化一个游戏物体 <em>20min</em></p>
</li>
<li><p>销毁 Destory(对象);</p>
</li>
</ul>
<h1 id="9-游戏时间"><a href="#9-游戏时间" class="headerlink" title="9.游戏时间"></a>9.游戏时间</h1><ul>
<li>Time.time 从游戏开始到现在的时间</li>
<li>Time.timeScale 时间缩放值,改变游戏速度</li>
<li>Time.fixedDeltaTime 固定时间间隔</li>
<li>Time.deltaTime 上一帧到这一帧的时间间隔<ul>
<li>可以累加来计算以帧为单位的游戏时间</li>
</ul>
</li>
</ul>
<h1 id="10-Application"><a href="#10-Application" class="headerlink" title="10.Application"></a>10.Application</h1><p>Application类,不同平台的路径不一样,使用该类来获取路径</p>
<ul>
<li><p>游戏数据文件夹路径 Application.dataPath 返回一个字符串,后面加上文件名就可以读取相应文件了(只读)</p>
</li>
<li><p>持久化文件路径 Application.persistentDataPath 根据平台不同改变,写数据应写在该路径下(写)</p>
</li>
<li><p>StreamingAssets 文件夹路径  Application.StreamingAssetsPath 指向第一个路径下的StreamingAssets文件夹(配置文件,只读,不需要加密)</p>
</li>
<li><p>临时文件夹 Application.temporaryCachePath</p>
</li>
<li><p>控制是否在后台运行 Application.runlnBackground</p>
</li>
<li><p>打开url Application.OpenURL(“”) 打开一个链接</p>
</li>
<li><p>退出游戏 Application.Quit()</p>
</li>
</ul>
<p>在脚本中使用Transform</p>
<p>游戏物体的父子关系由transform控制</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Uinty3DUI</title>
    <url>/2023/01/16/Uinty3DUI/</url>
    <content><![CDATA[<ol>
<li>画布</li>
<li>锚点和轴心点</li>
<li>文字</li>
<li>按钮</li>
<li>文本框</li>
<li>选项</li>
<li>滚动</li>
<li>面板</li>
<li>UI组件</li>
</ol>
<span id="more"></span>

<h1 id="一-画布"><a href="#一-画布" class="headerlink" title="一.画布"></a>一.画布</h1><ul>
<li><p>右键新建 UI-画布,创建画布会自动创建一个事件系统</p>
</li>
<li><p>画布使用2D模式进行边界,画布比例和显示窗口的比例一致</p>
</li>
<li><p>UI中的内容必须以画布为父物体才能显示</p>
</li>
<li><p>渲染模式</p>
<ul>
<li>设置为覆盖模式,则UI画布一定会显示在游戏最上层</li>
<li>设置为摄像机,则会按实际位置显示</li>
<li>设置为世界空间后,UI画布就可以旋转缩放等操作</li>
</ul>
</li>
<li><p>缩放</p>
<ul>
<li>恒定大小缩放和屏幕比例缩放</li>
<li>按照参考分辨率的比例进行缩放</li>
</ul>
</li>
</ul>
<h1 id="二-锚点和轴心点"><a href="#二-锚点和轴心点" class="headerlink" title="二.锚点和轴心点"></a>二.锚点和轴心点</h1><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><ul>
<li>每个图像都有一个在父物体身上的锚点,即有四个箭头指向的点,图像的坐标是相对于锚点</li>
<li>根据分辨率适配图像大小<ul>
<li>将锚点拉分开,即锚点变成一个矩形,由左下坐标和右上坐标定位</li>
<li>此时图片的大小,坐标就相对于锚框进行变换,当分辨率改变,锚框改变,图像也随之改变</li>
<li>若锚框变成锚线,则锚线垂直方向不会进行适配,平行方向会进行适配</li>
</ul>
</li>
<li>图像的位置由轴心确定,即小圆环,旋转和坐标都以该点确定</li>
</ul>
<h1 id="三-文本"><a href="#三-文本" class="headerlink" title="三.文本"></a>三.文本</h1><h2 id="旧版文本"><a href="#旧版文本" class="headerlink" title="旧版文本"></a>旧版文本</h2><ul>
<li>在UI-旧版-文本 创建的即为旧文本,按钮,文本框等组件都基础文本实现</li>
<li>勾选富文本后,可以使用html对一段文本中的片段改变样式</li>
</ul>
<h2 id="新版字体"><a href="#新版字体" class="headerlink" title="新版字体"></a>新版字体</h2><ul>
<li>依赖TestMeshPro组件实现</li>
<li>在UI-文本 创建</li>
</ul>
<h1 id="四-按钮"><a href="#四-按钮" class="headerlink" title="四.按钮"></a>四.按钮</h1><ul>
<li><p>把按钮的文本子物体删除就不显示文字</p>
</li>
<li><p>在Image组件中更改按钮图像</p>
</li>
<li><p>Button组件</p>
<ul>
<li>Interactable 是否开启按钮</li>
<li>导入的按钮图片需要设置为 Sprite(2D和UI) 才能作为按钮过度图片</li>
</ul>
</li>
<li><p>导航 即将按钮连接起来,使用上下左右键可以切换选中的按钮</p>
</li>
<li><p>鼠标单击</p>
<ul>
<li>创建脚本,可以挂载到任意物体上</li>
<li><code>public void ButtonClick()&#123;&#125;</code> 点击方法</li>
<li>将脚本传入目标按钮,在鼠标单击中选中脚本和点击方法</li>
</ul>
</li>
</ul>
<h1 id="五-文本框"><a href="#五-文本框" class="headerlink" title="五.文本框"></a>五.文本框</h1><ul>
<li>文本框中的文本是占位文本,输入文本后占位文本消失</li>
<li>改变内容类型设定输入</li>
<li>事件<ul>
<li>值改变时,提交时,结束编辑时三个事件,使用方法和按钮一致</li>
<li>引入 UnityEngine.UI,创建 InputField 对象,将脚本挂载到UI上并将输入框添加到脚本的InputFiled上,InputFiled对象就会实时获取输入框内容</li>
</ul>
</li>
</ul>
<h1 id="六-选项"><a href="#六-选项" class="headerlink" title="六.选项"></a>六.选项</h1><ul>
<li>UI-切换 创建选项</li>
<li>添加组件 Toggle Group 组件,将该组件关联到多个选项的Group中,就可以实现多选一等功能</li>
<li>UI-下拉列表框 创建 下拉框<ul>
<li>可以在组件中手动添加选项</li>
<li>可以使用  <a href="https://www.bilibili.com/video/BV1gQ4y1e7SS?p=64&vd_source=5a3868fe69388cd372b51d75baaaca98">脚本添加</a></li>
<li>可以为选项单独添加图像,分为标题图像和项图像</li>
</ul>
</li>
</ul>
<h1 id="七-滚动条"><a href="#七-滚动条" class="headerlink" title="七.滚动条"></a>七.滚动条</h1><ul>
<li>UI-滑动条 <ul>
<li>事件使用和按钮一致</li>
</ul>
</li>
<li>UI-滚动条<ul>
<li>滚动条一般和滑动视图联合使用</li>
</ul>
</li>
<li>UI-滑动视图<ul>
<li>用滑动视图显示较多的内容</li>
<li>Content为要显示的全部内容 Viewport显示Content的部分内容</li>
</ul>
</li>
</ul>
<h1 id="八-面板"><a href="#八-面板" class="headerlink" title="八.面板"></a>八.面板</h1><ul>
<li>UI-面板<ul>
<li>把面板放在需要的位置</li>
<li>将需要的组件放在面板中,此时仅改变面板的锚点就可以应用到面板中的所有组件</li>
</ul>
</li>
</ul>
<h1 id="九-UI组件"><a href="#九-UI组件" class="headerlink" title="九.UI组件"></a>九.UI组件</h1><ul>
<li><p>遮罩</p>
<ul>
<li>添加Content Size Fitter 使文本框等组件随着游戏状态的变换来适配</li>
</ul>
</li>
<li><p>控制间隔一致</p>
<ul>
<li>选中要间隔一致的物体的父物体</li>
<li>添加Vertical Layout Group垂直布局,也可以添加水平布局,网格布局等</li>
<li>网格布局的大小由单元格大小确定</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D动画</title>
    <url>/2023/01/15/Unity3D%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<ol>
<li>角色动画</li>
<li>按键控制</li>
<li>剪辑</li>
<li>曲线和帧事件</li>
<li>混合动画</li>
<li>动画分层</li>
<li>反向动力</li>
<li>导航网格</li>
<li>网格连接和动态障碍物</li>
<li>导航区域</li>
</ol>
<span id="more"></span>

<h1 id="一-角色动画"><a href="#一-角色动画" class="headerlink" title="一.角色动画"></a>一.角色动画</h1><ul>
<li><p><a href="https://www.bilibili.com/video/BV1gQ4y1e7SS?p=48&vd_source=5a3868fe69388cd372b51d75baaaca98">组件控制</a></p>
</li>
<li><p>脚本控制</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.F))</span><br><span class="line">        &#123;</span><br><span class="line">            GetComponent&lt;Animator&gt;().SetTrigger(<span class="string">&quot;条件名&quot;</span>);<span class="comment">//设置一次触发</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在过度中选择退出时间,就会等待上个动画播放完才执行下一个动画</p>
</li>
</ul>
<h1 id="二-按键控制"><a href="#二-按键控制" class="headerlink" title="二.按键控制"></a>二.按键控制</h1><ul>
<li><p>把过度持续时间设置为0或取消固定持续时间,就可以减少动画延时</p>
</li>
<li><p>脚本控制</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Animator animator;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> horizontal = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="built_in">float</span> vertiacl = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        Vector3 dir = <span class="keyword">new</span> Vector3(horizontal, <span class="number">0</span>, vertiacl);</span><br><span class="line">        <span class="comment">//看向向量</span></span><br><span class="line">        transform.rotation = Quaternion.LookRotation(dir);</span><br><span class="line">        <span class="comment">//动作切换 当用户按下方向键,按下键后方向就不好为0来判断</span></span><br><span class="line">        <span class="keyword">if</span> (dir != Vector3.zero)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//移动</span></span><br><span class="line">            transform.rotation=Quaternion.LookRotation(dir);</span><br><span class="line">            transform.Translate(Vector3.forward * <span class="number">2</span> * Time.deltaTime);</span><br><span class="line">            animator.SetBool(<span class="string">&quot;run&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;run&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三-剪辑"><a href="#三-剪辑" class="headerlink" title="三.剪辑"></a>三.剪辑</h1><h2 id="Rig选项"><a href="#Rig选项" class="headerlink" title="Rig选项"></a>Rig选项</h2><ul>
<li>泛型支持所有动画类型</li>
<li>人形特指人物模型的动画</li>
<li>旧版指 可以用Animation组件播放</li>
</ul>
<h2 id="检查器"><a href="#检查器" class="headerlink" title="检查器"></a>检查器</h2><ul>
<li>在检查器中更改的设置必须点击最下方的应用</li>
<li>在检查器中可以对动画进行一个剪辑,播放指定长度的动画</li>
</ul>
<h1 id="四-曲线和帧事件"><a href="#四-曲线和帧事件" class="headerlink" title="四.曲线和帧事件"></a>四.曲线和帧事件</h1><h2 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h2><ul>
<li>曲线默认在整个动画期间全返回为0,更改曲线可以改变返回的值</li>
<li>通过返回值可以判断动作执行的进度,根据进度可以做一些其他操作</li>
<li>在动画器中添加 float 条件 ,以获取数值</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Debug.Log(animator.GetFloat(<span class="string">&quot;条件名&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="帧事件"><a href="#帧事件" class="headerlink" title="帧事件"></a>帧事件</h2><ul>
<li>可以设定在动画播放的某一个时刻,触发一个事件</li>
<li>在检查器中选定某个帧,添加一个函数,如添加一个名为leftFoot的函数</li>
<li>将脚本挂载到动画播放的游戏物体上,设定leftFoot,动画每到该帧执行一次</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftFoot</span>()</span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五-混合动画"><a href="#五-混合动画" class="headerlink" title="五.混合动画"></a>五.混合动画</h1><ul>
<li>在动画控制器中 创建状态-从新混合树 就可以创建混合动画</li>
<li>双击打开混合树,一般用1D通过一个参数来控制混合</li>
<li>通过Parameter选择混合参数,参数需要在动画器中被创建Float类型</li>
<li>在内部加号添加动画或再加一级混合树</li>
<li>动画Threshold 数值代表动画混合阈值,与值相同时不混合,在两值之间进行不同程度的混合</li>
<li>取消Automate Thresholds就可以更改 Thresholds数值</li>
</ul>
<h1 id="六-动画分层"><a href="#六-动画分层" class="headerlink" title="六.动画分层"></a>六.动画分层</h1><ul>
<li>动画有三个状态 入口状态Entry 出口状态Exit 任何状态AnyState<ul>
<li>任何状态创建一个过度,即所有状态下都可以过度到下一个状态</li>
</ul>
</li>
<li>子状态机包含一系列动画,可以把多个动画组合起来形成一个大动画,使用和一般状态一样</li>
<li>可以添加多个图层<ul>
<li>在左侧齿轮改变权重,就可以形成类似融合动画的效果</li>
<li>两图层权重相同,新创建的图层覆盖旧图层</li>
<li>遮罩<ul>
<li>在项目中创建遮罩,修改遮罩来更改权重应用的部分</li>
<li>在遮罩中加载到图层中,可以单独使人体某一部分覆盖上级动画,使身体动画和手部动画不冲突</li>
</ul>
</li>
</ul>
</li>
<li>图层可以替代子状态机</li>
</ul>
<h1 id="七-反向动力学"><a href="#七-反向动力学" class="headerlink" title="七.反向动力学"></a>七.反向动力学</h1><ul>
<li><p>可以使移动中令人物一直朝向某物体或身体某一部分指向某物体</p>
</li>
<li><p>在动画控制器中选中IK</p>
</li>
<li><p>脚本控制</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorIK</span>(<span class="params"><span class="built_in">int</span> layerIndex</span>)</span>&#123; <span class="comment">//传入参数为图层引索</span></span><br><span class="line">    <span class="comment">//设置头部IK  先获取两个物体 animator 和 target </span></span><br><span class="line">    animator.SetLookAtWeight(<span class="number">1</span>);<span class="comment">//设置权重</span></span><br><span class="line">    animator.SetLookAtPosition(target.position); </span><br><span class="line">    <span class="comment">//设置右手IK权重 令身体部分也指向某个物体</span></span><br><span class="line">    animator.SetIkPositionWight(AvatarIKGoal.RightHand,<span class="number">1</span>); <span class="comment">//位置</span></span><br><span class="line">    animator.SetIKRoationWight(AvatarIKGoal.RightHand,<span class="number">1</span>);<span class="comment">//旋转</span></span><br><span class="line">    animator.SetIKPosition(AvatarIKGoal.RightHand,target.position);<span class="comment">//应用IK</span></span><br><span class="line">    animator.SetIKRotation(AvatarIKGoal.RIghtHand,target.rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>商城中有其他IK插件,可能比官方提供的更好用</p>
</li>
</ul>
<h1 id="八-导航网格"><a href="#八-导航网格" class="headerlink" title="八.导航网格"></a>八.导航网格</h1><h2 id="烘焙导航"><a href="#烘焙导航" class="headerlink" title="烘焙导航"></a>烘焙导航</h2><ul>
<li>先选中所有导航涉及的游戏物体,在检查器中将其在id最右侧更改为 Navigation Static</li>
<li>在窗体中打开 AI-导航</li>
<li>烘焙最为重要,通过半径,高度,坡度和步高判断路径是否可以通过来生成导航网格</li>
<li>点击烘焙后生成导航网格,人物可以在蓝色区域中移动</li>
</ul>
<h2 id="导航应用"><a href="#导航应用" class="headerlink" title="导航应用"></a>导航应用</h2><ul>
<li><p>为需要导航的游戏物体添加 Nav Mesh Agent组件</p>
</li>
<li><p>导航代理,即使用不同参数生成的导航网格</p>
</li>
<li><p>在组件中设置导航选项</p>
</li>
<li><p>若多个物体通过一个狭窄的路口,优先级高的先通过</p>
</li>
<li><p>脚本控制移动</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.AI;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerControlTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> NavMeshAgent agent;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取代理组件</span></span><br><span class="line">        agent = GetComponent&lt;NavMeshAgent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//移动到点击位置</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))&#123;</span><br><span class="line">            Ray ray= Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">            RaycastHit hit;</span><br><span class="line">            <span class="keyword">if</span>(Physics.Raycast(ray,<span class="keyword">out</span> hit))</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3 point = hit.point;</span><br><span class="line">                <span class="comment">//设置目标点</span></span><br><span class="line">                agent.SetDestination(point);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="九-网格连接和动态障碍物"><a href="#九-网格连接和动态障碍物" class="headerlink" title="九.网格连接和动态障碍物"></a>九.网格连接和动态障碍物</h1><h2 id="网格连接"><a href="#网格连接" class="headerlink" title="网格连接"></a>网格连接</h2><ul>
<li>导航烘焙选项中 生成分离网格链接</li>
<li>选中要生成网格链接的对象,在对象选项中勾选Generate OffMeshLinks</li>
<li>设置掉率高度和跳跃距离后重新烘焙就可以链接网格(跳跃距离是横向跳跃,步高是纵向跳跃)</li>
<li>设置两个特殊点使两点间可以跳跃<ul>
<li>使用两个立方体(或其他物体)放在两个特殊点</li>
<li>添加组件 Off Mesh Link </li>
<li>添加起始物体和结束物体</li>
<li>自动更新位置,使网格链接随这两点位置变换</li>
</ul>
</li>
</ul>
<h2 id="动态障碍物"><a href="#动态障碍物" class="headerlink" title="动态障碍物"></a>动态障碍物</h2><ul>
<li>选中要设置为动态障碍物的物体,取消Navigation Static,重新烘焙</li>
<li>给动态障碍物添加 Nav Mesh Obstacle组件 <ul>
<li>给动画障碍物添加切割,就会根据障碍物状态动态烘焙网格</li>
<li>添加切割会增加性能消耗,非必要不使用</li>
</ul>
</li>
</ul>
<h1 id="十-导航区域"><a href="#十-导航区域" class="headerlink" title="十.导航区域"></a>十.导航区域</h1><ul>
<li><p>不同区域有不同颜色,名称,权重</p>
</li>
<li><p>导航会优先选取总权重小的路线</p>
</li>
<li><p>创建一个物体来承载不同区域,选中对象,在导航中的对象下选择导航区域</p>
</li>
<li><p>在导航物体中的导航组件中改变区域遮罩,来改变那些区域可以走</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D进阶</title>
    <url>/2023/01/15/Unity3D%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<ol>
<li>角色控制器</li>
<li>重力</li>
<li>碰撞监听</li>
<li>触发</li>
<li>物理关节</li>
<li>物理材质</li>
<li>射线检测</li>
<li>粒子系统</li>
<li>绘制</li>
<li>游戏物体动画</li>
</ol>
<span id="more"></span>

<h1 id="一-角色控制器"><a href="#一-角色控制器" class="headerlink" title="一.角色控制器"></a>一.角色控制器</h1><h2 id="控制器方案"><a href="#控制器方案" class="headerlink" title="控制器方案"></a>控制器方案</h2><ul>
<li>可以在商店中下载角色控制器</li>
<li>可以使用Unity3D提供的角色控制器</li>
<li>可以自己编写角色控制器</li>
</ul>
<h2 id="控制器的使用"><a href="#控制器的使用" class="headerlink" title="控制器的使用"></a>控制器的使用</h2><ul>
<li>给游戏物体添加 <code>Character Controller</code> 组件</li>
<li>WASD会获取一个水平轴和一个垂直轴数值 </li>
<li>使用向量的方向来控制移动方法,向量的大小控制移动速度</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerControlTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CharacterController player;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        player=GetComponent&lt;CharacterController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取虚拟轴数据</span></span><br><span class="line">        <span class="built_in">float</span> horizontal = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="built_in">float</span> vertical = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        <span class="comment">//创建称一个方向向量</span></span><br><span class="line">        Vector3 dir = <span class="keyword">new</span> Vector3(horizontal, <span class="number">0</span>, vertical);</span><br><span class="line">        player.SimpleMove(dir * <span class="number">2</span>);<span class="comment">//该移动方法受重力影响  且移动速度为2倍,用于控制移动速度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-重力"><a href="#二-重力" class="headerlink" title="二.重力"></a>二.重力</h1><ul>
<li><p>添加 <code>Rigidbody</code> 组件,就会使物体受到重力影响</p>
</li>
<li><p><code>Is Kinematic</code> 打开后,该物体就不受物理系统影响了,无法被撞开或下落等</p>
</li>
<li><p>若要判断高速物体的碰撞判断,应该选用连续的碰撞检测,而不是离散的,离散会每隔一段时间检测一次可能会检测不到</p>
</li>
</ul>
<h1 id="三-碰撞监听"><a href="#三-碰撞监听" class="headerlink" title="三.碰撞监听"></a>三.碰撞监听</h1><h2 id="产生碰撞"><a href="#产生碰撞" class="headerlink" title="产生碰撞"></a>产生碰撞</h2><ul>
<li>每个游戏物体上的Collider组件就是碰撞检测器组件</li>
<li>有碰撞器和刚体组件才能产生碰撞</li>
<li>可以改变碰撞判定范围</li>
</ul>
<h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><ul>
<li>将脚本挂载到碰撞两物体的任意一个物体上就可以检测碰撞</li>
<li>传入的参数是碰撞到的物体的信息</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CollisionTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//监听发生碰撞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//持续发生碰撞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionStay</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听结束碰撞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionExit</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四-触发"><a href="#四-触发" class="headerlink" title="四.触发"></a>四.触发</h1><ul>
<li>碰撞和触发的产生条件一致,但一方的碰撞器必须设置为是触发器</li>
<li>当设置为触发器后,就不会发生碰撞,会穿过触发器</li>
<li>把触发器的Mesh Renderer 取消,使其不显示</li>
<li>通过触发器就可以判断游戏物体是否处于或经过某一区域,然后进行一系列操作</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider other</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五-物理关节"><a href="#五-物理关节" class="headerlink" title="五.物理关节"></a>五.物理关节</h1><p>在Physics中的Hinge Joint组件,即铰链关节</p>
<ul>
<li>铰链关键使物体沿铰链轴固定,可以用于门的物理效果等</li>
<li>通过Anchor调整关节中心点,通过轴调整朝向</li>
<li>也可以给关节一个目标速度和力,打开Use Motor就可以使门自动旋转</li>
</ul>
<p>Spring Joint 弹簧关节</p>
<ul>
<li>可以给两个物体间添加一个弹簧</li>
</ul>
<p>Fixed Joint 固定关节</p>
<ul>
<li>相等于给两个物体之间添加一个固定的杆</li>
<li>可以设置一个阈值,当力大于阈值时关节断开</li>
</ul>
<h1 id="六-物理材质"><a href="#六-物理材质" class="headerlink" title="六.物理材质"></a>六.物理材质</h1><p>改变物体表面的物理性质,如摩擦因数等参数</p>
<ul>
<li><p>在文件目录中创建 物理材质(注意不是材质)</p>
</li>
<li><p>在Mesh Collider组件中 添加 材质</p>
</li>
<li><p>在物理材质中调整材质参数</p>
</li>
</ul>
<h1 id="七-射线检测"><a href="#七-射线检测" class="headerlink" title="七. 射线检测"></a>七. 射线检测</h1><p>点击平面上一点后令物体移动到该点,即从摄像机向点击方向射出一条射线,判断射线碰触到的第一个物体的点</p>
<ul>
<li>一般将射线检测脚本挂载到 要进行动作的游戏物体上</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建射线的两种方法</span></span><br><span class="line">        Ray ray = <span class="keyword">new</span> Ray(Vector3.zero, Vector3.up);</span><br><span class="line">        </span><br><span class="line">        Ray cameraRay = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按下鼠标发射射线</span></span><br><span class="line">        Ray cameraRay = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">        <span class="comment">//声明一个碰撞信息类</span></span><br><span class="line">        RaycastHit hit;</span><br><span class="line">        <span class="comment">//碰撞检测</span></span><br><span class="line">        <span class="built_in">bool</span> res = Physics.Raycast(cameraRay, <span class="keyword">out</span> hit);</span><br><span class="line">        <span class="comment">//out是c#的一个输出方法,若产生碰撞,则hit就会有碰撞信息</span></span><br><span class="line">        <span class="keyword">if</span> (res == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(hit.point);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//多物体检测</span></span><br><span class="line">        RaycastHit[] hits = Physics.RaycastAll(cameraRay);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="八-粒子系统"><a href="#八-粒子系统" class="headerlink" title="八. 粒子系统"></a>八. <a href="https://www.bilibili.com/video/BV1gQ4y1e7SS?p=44&spm_id_from=pageDriver&vd_source=5a3868fe69388cd372b51d75baaaca98">粒子系统</a></h1><p>粒子系统组件 <code>Particle System</code></p>
<p>在粒子系统组件中更改粒子设置</p>
<h1 id="九-绘制"><a href="#九-绘制" class="headerlink" title="九. 绘制"></a>九. 绘制</h1><h2 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h2><ul>
<li><p>创建一个空白的物体,添加Line Renderer 组件 用于绘制线段</p>
</li>
<li><p>绘制后线的方向不受物体方向影响,受组件里的位置影响</p>
</li>
<li><p>Materials 中选择材质</p>
</li>
<li><p>在组件中添加点来绘制</p>
</li>
<li><p>点循环可以使头尾相连</p>
</li>
<li><p>用场景工具直接使用鼠标绘制</p>
</li>
<li><p>通过脚本设置线段位置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       LineRenderer lineRenderer = GetComponent&lt;LineRenderer&gt;();</span><br><span class="line">       lineRenderer.positionCount = <span class="number">3</span>; <span class="comment">//设置有几个点</span></span><br><span class="line">       <span class="comment">//设置三个位置</span></span><br><span class="line">       lineRenderer.SetPosition(<span class="number">0</span>,Vector3.zero);</span><br><span class="line">       lineRenderer.SetPosition(<span class="number">0</span>, Vector3.one);</span><br><span class="line">       lineRenderer.SetPosition(<span class="number">0</span>, Vector3.down);</span><br><span class="line">       <span class="comment">//开始颜色 等等</span></span><br><span class="line">       lineRenderer.startColor = Color.white;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="拖尾"><a href="#拖尾" class="headerlink" title="拖尾"></a>拖尾</h2><ul>
<li>Trail Renderer 组件</li>
<li>时间 设定 拖尾的持续时间 </li>
<li>最小顶点距离 即 移动多少距离后生成拖尾</li>
</ul>
<h1 id="十-游戏物体动画"><a href="#十-游戏物体动画" class="headerlink" title="十.游戏物体动画"></a>十.游戏物体动画</h1><h2 id="旧版动画组件-Animation"><a href="#旧版动画组件-Animation" class="headerlink" title="旧版动画组件 Animation"></a>旧版动画组件 Animation</h2><ul>
<li><p>动画内容Clip,也可以添加多个动画</p>
</li>
<li><p>Culling Tpye 选择 Based On Renderers 后看到才做动画,看不到就停止</p>
</li>
<li><p>窗口-动画-动画 打开动画制作面板,然后选中要制作动画的物体 <a href="https://www.bilibili.com/video/BV1gQ4y1e7SS?p=46&vd_source=5a3868fe69388cd372b51d75baaaca98">详细教程</a></p>
</li>
<li><p>脚本控制</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Input.GetMouseButtonDown(<span class="number">0</span>))&#123;</span><br><span class="line">    GetComponent&lt;Animation&gt;().Play(<span class="string">&quot;要播放的动画名&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="新版动画组件-Animator"><a href="#新版动画组件-Animator" class="headerlink" title="新版动画组件 Animator"></a>新版动画组件 Animator</h2><ul>
<li><p>挂载Animator 组件 在项目中创建动画器控制器加载到Animator上</p>
</li>
<li><p>所有动画挂载到控制器中执行</p>
</li>
<li><p>在控制器中对动画进行进一步控制</p>
</li>
<li><p>脚本控制</p>
<p>  if(Input.GetMouseButtonDown(0)){<br>  GetComponent<Animator>().Play(“要播放的动画名”);<br>  }</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛-1</title>
    <url>/2023/01/17/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h1><span id="more"></span>

<ul>
<li>单调队列&#x2F;栈<ul>
<li>即普通的队列或栈,但在进行 <code>入</code> 操作时通过弹出尾部元素来使队列或栈保持单调性</li>
<li>用于滑动窗口,DP优化等</li>
</ul>
</li>
<li>哈夫曼树<ul>
<li>一种二叉树,进行对具有权重的两两对象操作时求权重和最小或最优前缀码等</li>
</ul>
</li>
<li>优先队列<ul>
<li><code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;</code> 小根堆  <code>less&lt;int&gt;</code>  大根堆</li>
<li>可以用于构造哈夫曼树</li>
</ul>
</li>
</ul>
<h1 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h1><h2 id="问题规模"><a href="#问题规模" class="headerlink" title="问题规模"></a>问题规模</h2><p>在1秒时间内可用的算法时间时间复杂度</p>
<table>
<thead>
<tr>
<th>问题规模n</th>
<th>logn</th>
<th>n</th>
<th>nlogn</th>
<th>n^2</th>
<th>2^n</th>
<th>n!</th>
</tr>
</thead>
<tbody><tr>
<td>n&lt;&#x3D;11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>n&lt;&#x3D;25</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>n&lt;&#x3D;5000</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>n&lt;&#x3D;1e6</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>n&lt;&#x3D;1e7</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>n&lt;&#x3D;1e8</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h2 id="尺取法-双指针-快慢指针"><a href="#尺取法-双指针-快慢指针" class="headerlink" title="尺取法(双指针,快慢指针)"></a>尺取法(双指针,快慢指针)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>尺取法可以优化二重循环,将O(n^2)优化为O(n)</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">        <span class="comment">//dosometing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化为----------&gt;</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">    i++;</span><br><span class="line">    j--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>java图片增强</title>
    <url>/2023/02/22/java%E5%9B%BE%E7%89%87%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h1 id="JAVA-IO"><a href="#JAVA-IO" class="headerlink" title="JAVA IO"></a>JAVA IO</h1><span id="more"></span>

<h2 id="图像的读取和保存-GUI"><a href="#图像的读取和保存-GUI" class="headerlink" title="图像的读取和保存(GUI)"></a>图像的读取和保存(GUI)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">&quot;打开&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">JFileChooser</span> <span class="variable">chooser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFileChooser</span>();</span><br><span class="line">            <span class="type">FileNameExtensionFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileNameExtensionFilter</span>(</span><br><span class="line">                    <span class="string">&quot;JPG &amp; GIF &amp; PNG Images&quot;</span>, <span class="string">&quot;png&quot;</span>, <span class="string">&quot;jpeg&quot;</span>, <span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;gif&quot;</span></span><br><span class="line">            );</span><br><span class="line">            chooser.setFileFilter(filter);</span><br><span class="line">            <span class="type">int</span> <span class="variable">returnValue</span> <span class="operator">=</span> chooser.showOpenDialog(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (returnValue == JFileChooser.APPROVE_OPTION) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;You chose to open this file: &quot;</span> +</span><br><span class="line">                        chooser.getSelectedFile().getName());</span><br><span class="line">                imgPix = tools.getPixel(chooser.getSelectedFile().getPath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">&quot;保存&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">JFileChooser</span> <span class="variable">chooser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFileChooser</span>();</span><br><span class="line">            <span class="type">FileNameExtensionFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileNameExtensionFilter</span>(<span class="string">&quot;JPG &amp; GIF &amp; PNG Images&quot;</span>, <span class="string">&quot;png&quot;</span>, <span class="string">&quot;jpeg&quot;</span>, <span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;gif&quot;</span>);</span><br><span class="line">            chooser.setFileFilter(filter);</span><br><span class="line">            <span class="type">int</span> returnValue=chooser.showSaveDialog(<span class="literal">null</span> );</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ImageIO.write(imgList.get(imgList.size()-<span class="number">1</span>),<span class="string">&quot;PNG&quot;</span>,chooser.getSelectedFile() );</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>都使用 JFileChooser类进行操作,读取时使用chooser.getSelectedFile() 获取文件,保存时使用 ImagetIO.write() 进行保存,</p>
<p>保存时的参数分别为(BufferedImage对象,文件类型,文件路径)</p>
<h1 id="JAVA-滑杆"><a href="#JAVA-滑杆" class="headerlink" title="JAVA 滑杆"></a>JAVA 滑杆</h1><h1 id="JAVA-选项卡"><a href="#JAVA-选项卡" class="headerlink" title="JAVA 选项卡"></a>JAVA 选项卡</h1><h2 id="选项卡的使用"><a href="#选项卡的使用" class="headerlink" title="选项卡的使用"></a>选项卡的使用</h2><ul>
<li>建立JTabbedPane对象,作为选项卡,选项卡的选项都要添加到该对象中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JTabbedPane tabbledPane=<span class="keyword">new</span> <span class="title class_">JTabbedPane</span>(JTabbedPane.TOP);</span><br><span class="line">        imgListener.setTabblePanel(tabbledPane);</span><br><span class="line">        tabbledPane.setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="built_in">this</span>.getWidth()-<span class="number">180</span>,<span class="number">30</span>));</span><br><span class="line">        tabbledPane.setLocation(<span class="number">90</span>,<span class="number">0</span>);</span><br><span class="line">        tabbledPane.addChangeListener(tabbleListener);</span><br><span class="line">        tabbleListener.setShowImgPanel(imgPanel);</span><br></pre></td></tr></table></figure>

<ul>
<li>对选项卡添加选项</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JLabel</span> <span class="variable">nameLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>();</span><br><span class="line">        nameLabel.setName(path);</span><br><span class="line">        tabblePanel.add(name,nameLabel);</span><br><span class="line">        <span class="comment">//将选项卡设置到最新添加的</span></span><br><span class="line">        tabblePanel.setSelectedIndex(tabblePanel.getComponentCount()-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>JLabel作为选项对象,<code>tabblePanel.add(name,nameLabel);</code> 参数分别为: 显示出来的选项名称,选项对象</p>
<h2 id="设置选中的选项"><a href="#设置选中的选项" class="headerlink" title="设置选中的选项"></a>设置选中的选项</h2><p><code>tabblePanel.setSelectedIndex(tabblePanel.getComponentCount()-1);</code></p>
<ul>
<li>通过index 选中选项,<code>tabblePanel.getComponentCount()-1</code> 即最后一个选项的引索</li>
</ul>
<h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>对选项卡进行监听要实现 ChangeListener 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateChanged</span><span class="params">(ChangeEvent e)</span> &#123;</span><br><span class="line">        <span class="type">JTabbedPane</span> <span class="variable">pane</span> <span class="operator">=</span> (JTabbedPane) e.getSource();</span><br><span class="line">        JLabel label= (JLabel) pane.getSelectedComponent();</span><br><span class="line"></span><br><span class="line">        String path=label.getName();</span><br><span class="line">        System.out.println(path);</span><br><span class="line">        imgList.add(openImg(path));</span><br><span class="line">        imgListener.setImgPix(path);</span><br><span class="line"></span><br><span class="line">        panel.repaint();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h1 id="JAVA-菜单"><a href="#JAVA-菜单" class="headerlink" title="JAVA 菜单"></a>JAVA 菜单</h1><h2 id="菜单条"><a href="#菜单条" class="headerlink" title="菜单条"></a>菜单条</h2><p>JMenuBar — 菜单条类</p>
<ul>
<li>JMenuBar是菜单的基础,只能添加到JFram组件的顶端中,承载菜单组件,一个JFram组件只能添加一个菜单条</li>
<li><code>this.setJMenuBar(new JMenuBar);</code></li>
</ul>
<p>JMenu — 菜单类</p>
<ul>
<li>JMenu 是菜单条中的一个个选项,添加到菜单条中 </li>
<li><code>menuBar.add(menu);</code></li>
</ul>
<p>JMenuItem — 菜单项类 </p>
<ul>
<li>JMenuItem 是菜单点开后的菜单选项,添加到菜单中</li>
<li>分割条: <code>menu.addSeparator();</code></li>
</ul>
<h1 id="JAVA-窗体操作"><a href="#JAVA-窗体操作" class="headerlink" title="JAVA 窗体操作"></a>JAVA 窗体操作</h1><ul>
<li>退出程序 <code>System.exit(0);</code></li>
<li>退出窗口<code> (JFrame)frame.dispose();</code></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/2023/02/06/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="基础算法-1"><a href="#基础算法-1" class="headerlink" title="基础算法-1"></a>基础算法-1</h1><span id="more"></span>

<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>查找 [0,n)之间的 x或<strong>x的后缀</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binSearch</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>; <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="comment">// mid=left+(right-left)/2  防止right和left相加后溢出</span></span><br><span class="line">        <span class="comment">// mid=left+(right-left)&gt;&gt;2 综合最优</span></span><br><span class="line">		<span class="keyword">if</span> (a[mid] &gt; x) right = mid;</span><br><span class="line">		<span class="comment">//if(a[mid]&gt;=x) right=mid;</span></span><br><span class="line">		<span class="comment">// eles left=mid+1;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码中 left&#x3D;mid+1 不能写作 left&#x3D;mid,默认向下取整,若left&#x3D;2,right&#x3D;3则导致 left&#x3D;mid时 陷入死循环</li>
<li>不同问题下mid的取值<ul>
<li>语言中 mid默认向下取整,称为”左中位数”,适应于求 x或x的后缀</li>
<li>向上取整时,称为”右中位数”,使用于 求x或x的前驱 此时 <code>left=mid; right=mid-1;</code></li>
</ul>
</li>
<li>应谨慎使用直接  除2(x&#x2F;2)操作,因为默认朝 0 方向取整<ul>
<li>为运算 &gt;&gt; 向下取整而 right-left 保证了不小于0</li>
</ul>
</li>
</ul>
<h3 id="STL二分"><a href="#STL二分" class="headerlink" title="STL二分"></a>STL二分</h3><ul>
<li>lower_bound()  upper_bound()</li>
</ul>
<h3 id="最大值最小化-最小值最大化"><a href="#最大值最小化-最小值最大化" class="headerlink" title="最大值最小化(最小值最大化)"></a>最大值最小化(最小值最大化)</h3><p>- </p>
<h3 id="实数二分"><a href="#实数二分" class="headerlink" title="实数二分"></a>实数二分</h3><p>实数二分不需要考虑取整问题,编码比整数二分简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-7</span>; <span class="comment">//控制精度</span></span><br><span class="line">	<span class="type">int</span> left, right,x;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (right - left &gt; eps) &#123;</span><br><span class="line">		<span class="type">double</span> mid = left + (right - left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(mid)) right = mid;</span><br><span class="line">		<span class="keyword">else</span> left=mid</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>用for循环控制精度和while控制精度都存在问题</p>
<ul>
<li>for循环次数不能太大或太小,一般100次比while要大得多,但若for中需要的时间过长会导致超时,需要根据实际调整循环次数</li>
<li>对于while循环 eps太小会超时,太大会导致精度小,也需要仔细考虑</li>
</ul>
<h3 id="P1824"><a href="#P1824" class="headerlink" title="P1824"></a>P1824</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, c,x[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">1</span>,pre=<span class="number">0</span>;	<span class="comment">//第一头牛放在第一个位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x[i] - x[pre] &gt;= mid) &#123;</span><br><span class="line">			count += <span class="number">1</span>;</span><br><span class="line">			pre = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count &gt;= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; x[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(x, x + n);</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = x[n - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">		mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">			ans = mid; <span class="comment">//记录结果</span></span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> right = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h2><p>用 mid1和mid2 进行三分,可以用于求单峰或单谷函数的极值</p>
<p>N次函数求值: <code>for(int i=0;i&lt;=n;++i) s=s*x+a[i]  </code></p>
<p>a[i]代表从高到低各项的系数</p>
<h3 id="整数三分"><a href="#整数三分" class="headerlink" title="整数三分"></a>整数三分</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(right-left&gt;<span class="number">2</span>)&#123;</span><br><span class="line">    mid1=left+(right-left)/<span class="number">3</span>;</span><br><span class="line">    mid2=right-(right-left)/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid1)&gt;<span class="built_in">check</span>(mid2)) </span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​     </p>
<h1 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h1><p>倍增法需要提前计算好跳板,这要求数据是静态不变的,若数据动态变化,跳板需要重新计算,倍增法也就失去意义了</p>
<h2 id="洛谷P4155"><a href="#洛谷P4155" class="headerlink" title="洛谷P4155"></a>洛谷P4155</h2><ul>
<li>定义go[s][i]表示从第s个区间出发,走2^i个最优区间到达的区间,s和go[s][i]之间的区间也都是最优区间</li>
<li>跳板的递推计算 : go[s][i]&#x3D;go[ go[s][i-1] ] [i-1]<ul>
<li>首先从s起跳,跳到2^i-1位置,再从 2^i-1位置跳到 2^i位置,一共跳了2^i-1 + 2^i-1 步,即2^i步</li>
</ul>
</li>
<li>初始条件 go[s][0] 是使用贪心算法计算出的第一个最优位置,之后的跳板以此为基础计算</li>
</ul>
<h2 id="ST算法"><a href="#ST算法" class="headerlink" title="ST算法"></a>ST算法</h2><p>求解区间最值查询,基于 大区间的最值 等于多个小区间的最值的最值</p>
<p>分为以下步骤:</p>
<ol>
<li>把整个区间划分为很多个小区间,提前计算各小区间的最值</li>
<li>对任意区间查最值,找到覆盖它的小区间,计算小区间最值的最值</li>
</ol>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li><p>使用倍增法分组,第一组 小区间长度为1,第二组小区间长度为2…以此类推</p>
</li>
<li><p>即长度为n的数列有公有 log2 n组 </p>
</li>
<li><p>其中,每组的最值可以由前一组的最值递推而来</p>
</li>
<li><p>定义 dp[s][k]表示左端点为s,区间长度为 2^k长度的区间最值 </p>
<ul>
<li>dp[s][k]&#x3D;min(dp[s][k-1],dp[s+(1&lt;&lt;k-1)][k-1] )</li>
</ul>
</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li>查询任意区间最值只需要找到两个覆盖该区间的小区间,求该小区间的最值的最值</li>
<li>区间[L,R] 的长度len&#x3D; L-R+1,令x为小于len的2的最大倍数,如len&#x3D;19,则x&#x3D;16,k&#x3D;4;</li>
<li>res&#x3D;min(dp[L][k],dp[R-(1&lt;&lt;k)+1][k])</li>
</ul>
<h3 id="例题-P2880"><a href="#例题-P2880" class="headerlink" title="例题 P2880"></a>例题 P2880</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> num[N],lr[<span class="number">180001</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dpMax[N][<span class="number">22</span>], dpMin[N][<span class="number">22</span>];</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//长度为1的小组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		dpMax[i][<span class="number">0</span>] = num[i];</span><br><span class="line">		dpMin[i][<span class="number">0</span>] = num[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;=<span class="built_in">log2</span>(n); ++i) &#123;	<span class="comment">//倍增</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j+( <span class="number">1</span> &lt;&lt; i) &lt;= n+<span class="number">1</span>; ++j) &#123; <span class="comment">//即j+2^i-1 &lt;=n ,从1开始长度为2的区间应是 [1,2],但1+2=3，故减一</span></span><br><span class="line">			dpMax[j][i] = <span class="built_in">max</span>(dpMax[j][i - <span class="number">1</span>], dpMax[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">			dpMin[j][i] = <span class="built_in">min</span>(dpMin[j][i - <span class="number">1</span>], dpMin[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRes</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">	k = <span class="built_in">log2</span>(len);</span><br><span class="line">	<span class="type">int</span> max_ = <span class="built_in">max</span>(dpMax[l][k], dpMax[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">	<span class="type">int</span> min_ = <span class="built_in">min</span>(dpMin[l][k], dpMin[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">	<span class="keyword">return</span> max_ - min_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; lr[i][<span class="number">0</span>] &gt;&gt; lr[i][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">getRes</span>(lr[i][<span class="number">0</span>], lr[i][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="差分法"><a href="#差分法" class="headerlink" title="差分法"></a>差分法</h1><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p>差分应用于区间修改和查询问题,把给定数据集A分成多个区间,对不同区间进行多次操作,如对区间内数据进行加减操作,求操作后的数据集</p>
<p>若使用暴力法,时间复杂度为O(mn),使用差分法可以优化至O(m+n)</p>
<ul>
<li>使用两个数组: 原数组a[],差分数组 D[]</li>
<li>差分数组D[]的定义是 D[i]&#x3D;a[i]-a[i-1],可以推出 a[i]&#x3D;D[1]+D[2]+…+D[i],即原数组是差分数组的前缀和数组 <em><strong>差分是前缀和的逆运算</strong></em></li>
<li>对数组a[] 的 [L,R]区间加上一个数x<ul>
<li>D[L] +&#x3D;	x</li>
<li>D[R+1] -&#x3D; x</li>
</ul>
</li>
<li>这样使[L,R]之间的前缀和增加了x(即 a[L,R]增加了x),其他范围不受影响</li>
<li>结果数组为 a[i]&#x3D;a[i-1]+D[i] (a[i-1]即D[1]+…+D[i-1])</li>
</ul>
<h3 id="hdu1556"><a href="#hdu1556" class="headerlink" title="hdu1556"></a>hdu1556</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>]=&#123;<span class="number">0</span>&#125;,d[<span class="number">100005</span>]=&#123;<span class="number">0</span>&#125;	;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,l,r;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		d[l] += <span class="number">1</span>;</span><br><span class="line">		d[r + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		a[i] = d[i] + a[i - <span class="number">1</span>];	<span class="comment">//可以将a[]换为d[] 来节省一半的空间</span></span><br><span class="line">		cout &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一维差分数字对区间修改很高效，但对单点查询不高效</li>
</ul>
<h2 id="二维差分-上册第70页"><a href="#二维差分-上册第70页" class="headerlink" title="二维差分  上册第70页"></a>二维差分  上册第70页</h2><p><em>例： 一块n*n的格子上有m块地毯，给出地毯的信息，求每个点被几块地毯覆盖</em>  (洛谷P3397)</p>
<p>暴力求解 时间复杂度O（m*n*n）,用二维差分,时间复杂度O(m+n*n) 为最优时间复杂度 </p>
<ul>
<li><p>二维差分中,原数组a[][]是差分数组D[][]的前缀和,坐标原点(1,1)和坐标(i,j)之间每个D[][]的和为a[i][j]</p>
</li>
<li><p>可以把每个D[][]看作一个格子,所有格子的面积之和为a[][]</p>
</li>
<li><p>计算公式: <strong>D[i][j]&#x3D;a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]</strong>  因为a[i-1][j]-a[i][j-1]减去了两次a[i-1][j-1],故加上一次</p>
</li>
<li><p>区间修改:  x1,y1,x2,y2即为地毯的两个坐标</p>
<ul>
<li><strong>D[x1][y1]+&#x3D;d;</strong>	&#x2F;&#x2F;起点</li>
<li><strong>D[x1][y2+1]-&#x3D;d;</strong></li>
<li><strong>D[x2+1][y1]-&#x3D;d;</strong></li>
<li><strong>D[x2+1][y2+1]+&#x3D;d;</strong>  &#x2F;&#x2F;终点,减了两次,故加上一次</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归公式法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m,x1,y1,x2,y2;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="comment">//二维差分数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">		D[x1][y1] += <span class="number">1</span>;</span><br><span class="line">		D[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">		D[x1][y2 + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">		D[x2 + <span class="number">1</span>][y1] -= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			D[i][j] = D[i][j] + D[i - <span class="number">1</span>][j] + D[i][j - <span class="number">1</span>] - D[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">			cout &lt;&lt; D[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接计算法 不使用递推公式</span></span><br><span class="line"><span class="comment">//先累加y方向,在累加x方向即可求出前缀和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			D[i][j + <span class="number">1</span>] += D[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			D[i+<span class="number">1</span>][j] += D[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接计算与递推公式的计算量相当</li>
<li>递归公式简洁明了</li>
<li>三维差分递推公式过于复杂,使用直接计算更加方便</li>
</ul>
<h2 id="三维差分"><a href="#三维差分" class="headerlink" title="三维差分"></a>三维差分</h2><p>三维差分与二维差分类似,二维差分是面,三维差分是体</p>
<ul>
<li>三维差分的区间修改需要修改体的8个顶点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D[x1][y1][z1]+=d;</span><br><span class="line">D[x2+<span class="number">1</span>][y1][z1]-=d;</span><br><span class="line">D[x1][y2+<span class="number">1</span>][z1]-=d;</span><br><span class="line">D[x1][y1][z2+<span class="number">1</span>]-=d;</span><br><span class="line">D[x2+<span class="number">1</span>][y2+<span class="number">1</span>][z1]+=d;</span><br><span class="line">D[x2+<span class="number">1</span>][y1][z2+<span class="number">1</span>]+=d;</span><br><span class="line">D[x1][y2+<span class="number">1</span>][z2+<span class="number">1</span>]+=d;</span><br><span class="line">D[x1][y1][z1]-=d;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用直接计算法求结果数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=B;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=C;++k)&#123;</span><br><span class="line">            D[i][j][k+<span class="number">1</span>]+=D[i][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在剩下两个方向上再重复两次</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以不适用三维数组,使用一维数组存储,再定义一个函数 <code>num(x,y,z)</code>计算坐标对应的引索<ul>
<li><code>if(x&gt;A||y&gt;B||z&gt;C) return 0;</code></li>
<li><code>return ((x-1)*B+(y-1)*c+(z-1)*A);</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>随记</title>
    <url>/2023/02/27/%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="最大公约数和最大公倍数"><a href="#最大公约数和最大公倍数" class="headerlink" title="最大公约数和最大公倍数"></a>最大公约数和最大公倍数</h1><p>a,b两个数</p>
<ul>
<li>求最大公约数:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x%y!=<span class="number">0</span>):</span><br><span class="line">    z=x%y</span><br><span class="line">    x=y</span><br><span class="line">    y=z</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure>

<ul>
<li>最小公倍数 : a * b &#x3D; a,b的最小公倍数* a,b的最大公约数</li>
<li>故 最小公倍数&#x3D; (a*b)&#x2F;z</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JAVA并发</title>
    <url>/2023/03/03/java%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="进程-x2F-线程"><a href="#进程-x2F-线程" class="headerlink" title="进程&#x2F;线程"></a>进程&#x2F;线程</h1><span id="more"></span>

<p>​	一个进程有多个线程,线程是CPU执行的基础单位(最小单位),线程不能独立运行,必须依赖进程,所有线程共享进程的资源</p>
<p>​	并发量是效率,在一段时间内完成的量,并行量是指在某一时刻可以同时进行几项任务</p>
<h2 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h2><ul>
<li><p>自定义一个线程类,继承<code>Thread</code></p>
</li>
<li><p>在类中重载run()方法</p>
<ul>
<li>run()方法在线程启动后自动执行</li>
<li>run()方法执行完毕后线程自动销毁</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BallThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Graphics graphics;</span><br><span class="line">    <span class="comment">//实现线程</span></span><br><span class="line">    <span class="comment">//重新run方法:启动线程后自动执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//绘制小球</span></span><br><span class="line">        <span class="comment">//graphics.fillOval(100,100,100,100);</span></span><br><span class="line">        <span class="comment">//让小球循环画</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">400</span>;i++) &#123;</span><br><span class="line">            graphics.fillOval(<span class="number">100</span>,<span class="number">100</span>+i,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">            <span class="comment">//延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);   <span class="comment">//添加线程延迟,单位毫秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>Thread.sleep(int millis)</code>来设置线程的延时(停顿),单位为毫秒</li>
<li>通过父类方法 <code>start()</code> 启动线程</li>
</ul>
<h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><ul>
<li><p>NEW</p>
<p>尚未启动的线程处于此状态</p>
</li>
<li><p>RUNNABLE</p>
</li>
</ul>
<p>​		在Java虚拟机中执行的线程处于此状态</p>
<ul>
<li><p>BLOCKED</p>
<p>被阻塞等待监视器锁定的线程处于此状态</p>
</li>
<li><p>WAITING</p>
<p>正在等待另一个线程执行特定动作的线程处于此状态</p>
</li>
<li><p>TIMED_WAITING</p>
<p>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态(超时等待)</p>
</li>
<li><p>TERMINATED</p>
<p>已经退出的线程处于此状态</p>
</li>
</ul>
<h2 id="等待和阻塞"><a href="#等待和阻塞" class="headerlink" title="等待和阻塞"></a>等待和阻塞</h2><ul>
<li><p>等待是线程还没有被CPU调度,没有获得处理机资源的时间片,即使CPU空闲也不会被调用;</p>
</li>
<li><p>阻塞是线程无法获取到其执行需要的资源,如CPU没有空闲资源</p>
</li>
</ul>
<h2 id="使用构造方法初始化线程"><a href="#使用构造方法初始化线程" class="headerlink" title="使用构造方法初始化线程"></a>使用构造方法初始化线程</h2><ul>
<li>构造方法只执行一次,防止出现重复线程等问题</li>
<li>在构造方法中创建线程并启动,可以防止创建多个进程</li>
</ul>
<h1 id="键盘监听器"><a href="#键盘监听器" class="headerlink" title="键盘监听器"></a>键盘监听器</h1><ul>
<li><p>窗口需要获取焦点才能使用键盘监听器</p>
</li>
<li><p>获取按下的键盘按键,(控制方向移动等)</p>
</li>
</ul>
<h1 id="线程任务"><a href="#线程任务" class="headerlink" title="线程任务"></a>线程任务</h1><ul>
<li>定时线程任务,每隔一段时间自动创建对象</li>
</ul>
<h1 id="图片移动显示"><a href="#图片移动显示" class="headerlink" title="图片移动显示"></a>图片移动显示</h1><ul>
<li><p>在正坐标画图片的同时在相应的负坐标也画图</p>
</li>
<li><p><code>drawImage(image,0,y++,900,900,null);</code></p>
<p><code>drawImage(image,0,y-900,900,900,null);</code></p>
</li>
<li><p>因为y轴最大为900,所有在相应负坐标即为正坐标y-900</p>
</li>
</ul>
<h1 id="闪烁问题"><a href="#闪烁问题" class="headerlink" title="闪烁问题"></a>闪烁问题</h1><ul>
<li>闪烁问题是由于多个对象被画笔绘制,导致绘制被覆盖,一个对象没有被画完就画另一个对象</li>
<li>使用缓冲区来解决</li>
<li>创建一个BufferedImage作为缓冲区,将窗体画笔替换为缓冲区画笔,让缓冲区被绘制完成后再显示在窗体上就可以解决闪烁问题</li>
</ul>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/2023/03/17/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2/</url>
    <content><![CDATA[<h1 id="基础算法-2"><a href="#基础算法-2" class="headerlink" title="基础算法-2"></a>基础算法-2</h1><span id="more"></span>

<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p>​	在不关注数值的绝对大小而关注数据的相对大小时,将数据离散化可以把分布广而稀疏的数据转换为密集分布,从而使算法更快速,更节省空间地处理问题.</p>
<p>​	离散化的步骤: 1.排序 2.离散化 3.归位</p>
<p>使用STL进行离散化处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">100001</span>];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span>* newArr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="comment">//通过lower_bound获取递增后arr[i]的位置,该位置即为离散化后的数值</span></span><br><span class="line">		newArr[i] = <span class="built_in">lower_bound</span>(arr + <span class="number">1</span>, arr + n + <span class="number">1</span>, arr[i]) - arr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		cout &lt;&lt; newArr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要去重,可以使用unique()函数</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>​	可以直接使用STL中的排序算法 sort(),该函数的复杂度为 nlogn</p>
<h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><ul>
<li>next_permutation()函数</li>
</ul>
<p>​	返回值为bool,若没有下一个更大的排列,就返回false,若有就在原字符串中放入新的排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123; cout &lt;&lt; s &lt;&lt; endl; &#125; </span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()));</span><br><span class="line">	<span class="comment">// 将会输出 bca,cab,cba</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	若要获取全排列,先把字符串从小到大排序,然后再使用该函数.</p>
<ul>
<li>prev_permutation()</li>
</ul>
<p>​	该函数于上面函数相似,但是求前一个排列</p>
<ul>
<li>手写排列函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isVis[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myNext_permutation</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> resNum,<span class="type">int</span> totalNum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//s记录是排列中的第几个,t记录 所求排列的数组的长度</span></span><br><span class="line">	<span class="keyword">if</span> (s == resNum) &#123;</span><br><span class="line">		<span class="comment">//输出一个排列</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">			cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalNum; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isVis[i]) &#123;</span><br><span class="line">			isVis[i] = <span class="literal">true</span>;</span><br><span class="line">			b[s] = a[i];</span><br><span class="line">			<span class="built_in">myNext_permutation</span>(s + <span class="number">1</span>, resNum,totalNum);</span><br><span class="line">			isVis[i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">	<span class="comment">//前3个数中的3个数的全排列</span></span><br><span class="line">	<span class="comment">//若要取前四个数中的3个数的全排列,应为: myNext_permutation(0,3,4);</span></span><br><span class="line">	<span class="built_in">myNext_permutation</span>(<span class="number">0</span>, n,n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h2 id="分治算法的特征"><a href="#分治算法的特征" class="headerlink" title="分治算法的特征:"></a>分治算法的特征:</h2><ul>
<li>平衡子问题:分治后的子问题规模大致相同;子问题规模相同的问题处理效率高于子问题规模不等的问题</li>
<li>独立子问题:分治后的子问题相互独立,互不相干,这是区别与DP的根本特征</li>
</ul>
<p>汉诺塔问题,快速幂的一种解决方法,归并排序,快速排序都属于分支算法的应用</p>
<h2 id="逆序数问题-归并排序"><a href="#逆序数问题-归并排序" class="headerlink" title="逆序数问题(归并排序)"></a>逆序数问题(归并排序)</h2><p> 通过归并排序的合并来统计逆序数的数量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll a[N], b[N], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ll left, ll mid, ll right)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = left, j = mid + <span class="number">1</span>, temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">			b[temp++] = a[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			b[temp++] = a[j++];</span><br><span class="line">			cnt += mid - i + <span class="number">1</span>;	<span class="comment">//记录逆序数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 处理剩下的</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) b[temp++] = a[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= left) b[temp++] = b[j++];</span><br><span class="line">	<span class="comment">// 将归并好的复制回原数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; temp; ++x) &#123;</span><br><span class="line">		a[left + x] = b[x];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(ll left, ll right)</span> </span>&#123;</span><br><span class="line">	ll mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">mergeSort</span>(left, mid);</span><br><span class="line">	<span class="built_in">mergeSort</span>(mid + <span class="number">1</span>, right);</span><br><span class="line">	<span class="built_in">merge</span>(left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每交换一次相邻的逆序对就可以消去一个逆序对,从 大,中,小;大,小,中;各种情况归纳可得</span></span><br></pre></td></tr></table></figure>

<h2 id="第K大数问题-快速排序"><a href="#第K大数问题-快速排序" class="headerlink" title="第K大数问题(快速排序)"></a>第K大数问题(快速排序)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="comment">//快速排序求第 k 大数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = arr[left + (right - left) / <span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> i = left, j = right - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (arr[i] &lt; mid) ++i;</span><br><span class="line">		<span class="keyword">while</span> (arr[j] &gt; mid) --j;</span><br><span class="line">		<span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">			++i; --j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//只递归含有第k个数的部分</span></span><br><span class="line">	<span class="keyword">if</span> (left &lt;= j &amp;&amp; k &lt;= j) <span class="keyword">return</span> <span class="built_in">quickSort</span>(left, j+<span class="number">1</span>, k);</span><br><span class="line">	<span class="keyword">if</span> (i &lt; right &amp;&amp; k &gt;= i) <span class="keyword">return</span> <span class="built_in">quickSort</span>(i, right, k);</span><br><span class="line">	<span class="keyword">return</span> arr[k]; <span class="comment">//返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心与拟阵"><a href="#贪心与拟阵" class="headerlink" title="贪心与拟阵"></a>贪心与拟阵</h1><p>​	使用贪心的问题需要满足 可以从局部最优推广到全局最优,拟阵是一种评估方法,能在某些特殊情况下证明贪心法是全局最优的</p>
<p>​	局部最优不能总能导致全局最优,即使是同一个问题,参数的改变也会导致无法使用贪心算法</p>
<p>贪心算法需要满足:</p>
<ul>
<li><strong>最优子结构性质</strong>,即一个问题的最优解包含子问题的最优解,即能从局部最优扩展到全局最优</li>
<li><strong>贪心选择性质</strong>,整体的最优解可以通过对一系列子问题的最优解的选择得到</li>
</ul>
<p>即使贪心算法得不到最优解,也往往能得到十分接近最优解的<strong>近似解</strong>,如果一个问题不一定要求最优解,可以尝试贪心</p>
<h2 id="拟阵"><a href="#拟阵" class="headerlink" title="拟阵"></a>拟阵</h2><p>​	如果一个问题满足拟阵结构,那么贪心就可以得到最优解,是一个充分不必要条件</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>搜索</title>
    <url>/2023/04/01/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>BFS,DFS,剪枝,判重,最短路径dijkstra</p>
<span id="more"></span>

<h1 id="BFS和DFS基础"><a href="#BFS和DFS基础" class="headerlink" title="BFS和DFS基础"></a>BFS和DFS基础</h1><ul>
<li>BFS&#x3D;队列</li>
<li>DFS&#x3D;递归</li>
</ul>
<p>BFS使用的空间往往比DFS要大,因为出一个节点往往要向队列中加入多个节点</p>
<p>DFS使用的空间比BFS要小,但往往会搜索大量无效的节点</p>
<ul>
<li>DFS的算法往往比BFS简单,如果一道题目BFS和DFS都可以用,那么一般选择DFS</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>​	在BFS和DFS基础上,发展出了剪枝,记忆化(DFS),双向广搜(BFS),迭代加深搜索(DFS)等算法,大大提高了搜索能力</p>
<p>​	BFS的常用技巧是去重,DFS的常用技巧是剪枝</p>
<h2 id="连通性判断"><a href="#连通性判断" class="headerlink" title="连通性判断"></a>连通性判断</h2><p>​	p106,高地问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> cmap[N][N];</span><br><span class="line"><span class="type">int</span> isVis[N][N];</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	isVis[x][y] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (cmap[x][y + <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; cmap[x][y - <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span></span><br><span class="line">		&amp;&amp; cmap[x + <span class="number">1</span>][y] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; cmap[x - <span class="number">1</span>][y] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		flag = <span class="number">1</span>;	<span class="comment">//判断是否存在高地</span></span><br><span class="line">		<span class="comment">//不能在此处返回,要把一整个岛遍历完,不然可能一个岛上有多个高地被判断为多个岛</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> newX = x + d[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> newY = y + d[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (!isVis[newX][newY]&amp;&amp;cmap[newX][newY]==<span class="string">&#x27;#&#x27;</span>) <span class="built_in">DFS</span>(newX, newY);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			cin &gt;&gt; cmap[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cmap[i][j] = <span class="string">&#x27;#&#x27;</span>&amp;&amp; !isVis[i][j]) &#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">DFS</span>(i, j);</span><br><span class="line">				<span class="keyword">if</span> (flag == <span class="number">0</span>) ++cnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><p><strong>BFS剪枝</strong></p>
<ul>
<li>BFS剪枝常使用判重,若搜索到某一层出现重复的状态就剪枝</li>
</ul>
<p><strong>DFS剪枝</strong></p>
<ul>
<li>DFS剪枝技术较多<ul>
<li>可行性剪枝: 若当前状态不符合条件就剪枝</li>
<li>搜索顺序剪枝: 不同的搜索顺序会产生不同的搜索树形态,复杂度差异也较大</li>
<li>最优性剪枝: 在最优问题中,若当前花费已超过先前搜索得到的最优解,剪枝</li>
<li>排除等效冗余: 若搜索不同分支的结果是一样的,就只搜索一个分支</li>
<li>记忆化搜索: 将已经计算的结果保存,避免重复运算</li>
</ul>
</li>
</ul>
<h2 id="BFS判重"><a href="#BFS判重" class="headerlink" title="BFS判重"></a>BFS判重</h2><h3 id="跳蚱蜢-八数码问题"><a href="#跳蚱蜢-八数码问题" class="headerlink" title="跳蚱蜢(八数码问题)"></a>跳蚱蜢(八数码问题)</h3><p>​	一个圆上有8个蚂蚱,一个空盘,蚂蚱可以跳到相邻的空盘上,或者跳过一个蚂蚱跳到距离为2的空盘上,将蚂蚱按顺时针排序,问最少调几次可以使蚂蚱的位置逆序而空盘的位置不变</p>
<ul>
<li><p>即 初始状态(化圆为线) 为 012345678,目标状态 087654321,使用广搜可以很好的解决</p>
</li>
<li><p>一个状态可以分出四个状态,要遍历所有状态以求取结果,使用树结构来实现广搜</p>
</li>
<li><p>一个裸的BFS第一步有4个状态,第二步有4*4种跳法….到第二十步时有约一万亿种跳法,因此必须剪枝,使用去重,当遇到已经遇到过的状态时就不再继续搜索</p>
</li>
<li><p>用STL 中的 map 和 set 判重,效率都很好</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string value;</span><br><span class="line">	<span class="type">int</span> depth;</span><br><span class="line">	<span class="built_in">Node</span>(string value, <span class="type">int</span> depth) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;depth = depth;</span><br><span class="line">		<span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;Node&gt; que;</span><br><span class="line">map&lt;string, <span class="type">bool</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		Node node = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//目标状态</span></span><br><span class="line">		<span class="keyword">if</span> (node.value == <span class="string">&quot;087654321&quot;</span>) &#123;</span><br><span class="line">			cout &lt;&lt; node.depth &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">			string temp;</span><br><span class="line">            <span class="comment">//找到0的位置</span></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; node.value.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (node.value[i] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//由该状态发散出的四种状态</span></span><br><span class="line">			temp = node.value;</span><br><span class="line">			<span class="built_in">swap</span>(temp[i], temp[(i + <span class="number">1</span>) % <span class="number">9</span>]);</span><br><span class="line">			<span class="keyword">if</span> (!mp[temp]) &#123;</span><br><span class="line">				que.<span class="built_in">push</span>(<span class="built_in">Node</span>(temp, node.depth + <span class="number">1</span>));</span><br><span class="line">				mp[temp] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = node.value;</span><br><span class="line">			<span class="built_in">swap</span>(temp[i], temp[(i + <span class="number">2</span>) % <span class="number">9</span>]);</span><br><span class="line">			<span class="keyword">if</span> (!mp[temp]) &#123;</span><br><span class="line">				que.<span class="built_in">push</span>(<span class="built_in">Node</span>(temp, node.depth + <span class="number">1</span>));</span><br><span class="line">				mp[temp] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = node.value;</span><br><span class="line">			<span class="built_in">swap</span>(temp[i], temp[(i - <span class="number">1</span> + <span class="number">9</span>) % <span class="number">9</span>]);</span><br><span class="line">			<span class="keyword">if</span> (!mp[temp]) &#123;</span><br><span class="line">				que.<span class="built_in">push</span>(<span class="built_in">Node</span>(temp, node.depth + <span class="number">1</span>));</span><br><span class="line">				mp[temp] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = node.value;</span><br><span class="line">			<span class="built_in">swap</span>(temp[i], temp[(i - <span class="number">2</span> + <span class="number">9</span>) % <span class="number">9</span>]);</span><br><span class="line">			<span class="keyword">if</span> (!mp[temp]) &#123;</span><br><span class="line">				que.<span class="built_in">push</span>(<span class="built_in">Node</span>(temp, node.depth + <span class="number">1</span>));</span><br><span class="line">				mp[temp] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="string">&quot;012345678&quot;</span>, <span class="number">0</span>));</span><br><span class="line">	<span class="built_in">BFS</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="综合剪枝"><a href="#综合剪枝" class="headerlink" title="综合剪枝"></a>综合剪枝</h2><pre><code> 某些题目中需要用到多种剪枝手段
</code></pre>
<ul>
<li>奇偶判断 p115页<ul>
<li>一种搜索特定步数时的剪枝手段</li>
<li>曼哈顿距离可以用于奇偶判断</li>
</ul>
</li>
</ul>
<h1 id="最短路径Dijkstra"><a href="#最短路径Dijkstra" class="headerlink" title="最短路径Dijkstra"></a>最短路径Dijkstra</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2999999</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="comment">//边类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> from, to;</span><br><span class="line">	ll value;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="type">int</span> from, <span class="type">int</span> to, ll value) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;from = from;</span><br><span class="line">		<span class="keyword">this</span>-&gt;to = to;</span><br><span class="line">		<span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	ll minDis;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> id, <span class="type">int</span> minDis) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">		<span class="keyword">this</span>-&gt;minDis = minDis;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node&amp; a) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;minDis &gt; a.minDis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存储图</span></span><br><span class="line">vector&lt;Edge&gt; edges[N];</span><br><span class="line"><span class="comment">//存储所有点到起点的距离</span></span><br><span class="line">ll allDis[N];</span><br><span class="line"><span class="comment">//标志该点已找到最短路径</span></span><br><span class="line"><span class="type">bool</span> isDone[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; smallHeap;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		allDis[i] = INF;</span><br><span class="line">		isDone[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	allDis[start] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入第一个点</span></span><br><span class="line">	smallHeap.<span class="built_in">push</span>(<span class="built_in">Node</span>(start, allDis[start]));</span><br><span class="line">	<span class="keyword">while</span> (!smallHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		Node node = smallHeap.<span class="built_in">top</span>();</span><br><span class="line">		smallHeap.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">//是否被遍历过,即是否找到最短路径</span></span><br><span class="line">		<span class="keyword">if</span> (isDone[node.id]) <span class="keyword">continue</span>;</span><br><span class="line">		isDone[node.id] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edges[node.id].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge edge = edges[node.id][i];</span><br><span class="line">			<span class="keyword">if</span> (isDone[edge.to]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//是否更新</span></span><br><span class="line">			<span class="keyword">if</span> (allDis[edge.to] &gt; node.minDis + edge.value) &#123;</span><br><span class="line">				allDis[edge.to] = node.minDis + edge.value;</span><br><span class="line">				smallHeap.<span class="built_in">push</span>(<span class="built_in">Node</span>(edge.to, allDis[edge.to]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m,u,v,w;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		edges[u].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v,w));</span><br><span class="line">		<span class="comment">//若为无方向图</span></span><br><span class="line">		<span class="comment">//edges[v].push_back(Edge(v, u, w));</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dijkstra</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (allDis[i] == INF) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; allDis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2023/04/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><span id="more"></span>

<h2 id="效用"><a href="#效用" class="headerlink" title="效用"></a>效用</h2><p>​	线程池可以提高性能,在系统启动时创建大量空闲的线程,再将任务传入线程池,线程池就会启动一个线程来执行该任务,执行结束后该线程不会被消亡,而是返回线程池,重回空闲状态,等待执行下一个任务.</p>
<ul>
<li><p>线程池可以降低资源消耗,避免了创建和销毁线程时造成的消耗</p>
</li>
<li><p>线程池可以提高响应速度,因为任务不需要等待线程被创建</p>
</li>
<li><p>线程池可以提高线程的可管理性,可以对线程进行统一的分配,调优,监控和管理</p>
</li>
</ul>
<h2 id="模拟线程池"><a href="#模拟线程池" class="headerlink" title="模拟线程池"></a>模拟线程池</h2><p>​	创建一个线程池类,作为线程池,包括构造方法和任务提交方法</p>
<ul>
<li>线程池中创建两个ArrayList,workThreadList 存储用于执行提交任务的线程,runnableList存储提交到线程池中待执行的任务,执行任务时从runnableList中取出最前端的任务并使用workThreadList中的线程执行提取出的任务的run方法.</li>
<li>线程池初始化时指定核心线程个数,创建相应数量的线程加入到workThreadList中并启动这些线程,并传入runnableList以获取任务以及作为监视器</li>
<li>提交任务方法execute方法用于将任务提交到线程池,使用同步代码块(因为需要调用runnableList的notify方法)以runnableList作为监视器,提交任务后执行runnableList的notify()方法,唤醒一个上述创建的以runnableList作为监视器的workThrad,启动任务执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">// 保存的核心线程</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;WorkThread&gt; workThreadList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WorkThread&gt;();</span><br><span class="line">    <span class="comment">// 提交到线程池的线程</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Runnable&gt; runnableList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Runnable&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> core)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程对象(执行任务的线程)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;core;i++)&#123;</span><br><span class="line">            WorkThread wt=<span class="keyword">new</span> <span class="title class_">WorkThread</span>(runnableList);</span><br><span class="line">            workThreadList.add(wt);</span><br><span class="line">            <span class="comment">// 启动线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(wt).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提交任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable runnable)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList)&#123;</span><br><span class="line">            runnableList.add(runnable);</span><br><span class="line">            <span class="comment">//提交后唤醒</span></span><br><span class="line">            runnableList.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	创建线程池中运行的线程,即核心线程,用于执行提交到线程池的任务</p>
<ul>
<li>核心线程的run方法需要设置while(true)循环,使核心线程不被销毁,能够正常处理提交的任务</li>
<li>使用同步代码块保护来对线程池的runnableList进行操作,并以runnableList作为同步代码块的监视器</li>
<li>如果任务列表为空,则通过runnableList使当前核心线程进入等待状态,直到提交任务时被唤醒</li>
<li>应该注意:线程唤醒后是从进入等待的位置继续执行代码,若使用if判断任务列表是否为空时,在从runnableList中提取任务时应再次判断任务列表中是否有任务,因为从唤醒线程到执行任务提取直接可能有其他线程已对runnableList进行操作,可能会出现执行到提取任务时任务列表为空的情况</li>
<li>使用while(runnableList&lt;&#x3D;0)来使线程进入等待,可不用再次判断任务列表中是否有任务</li>
<li><strong>同步代码块应只保护对runnableList的操作,对任务的执行不能处于同步代码块内</strong>,否则核心线程对任务的执行不是并发进行的,使线程池失去意义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Runnable&gt; runnableList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WorkThread</span><span class="params">(ArrayList&lt;Runnable&gt; runnableList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.runnableList = runnableList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不断执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">                <span class="comment">//如果没有任务就进入等待</span></span><br><span class="line">                <span class="keyword">if</span>(runnableList.size() &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        runnableList.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在线程中直接执行任务的run()方法,不需要再创建线程</span></span><br><span class="line">                <span class="keyword">if</span>(runnableList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> runnableList.remove(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	以及主函数和测试任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">DoThread</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoThread</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.idx = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;待处理任务&quot;</span>+idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>​	Java中的线程池</p>
<ul>
<li>构造方法 <code>ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize, long keepAliveTime, Runnable&gt; workQueue)</code><ul>
<li>corePoolSize 线程池大小,对于上面的核心线程数</li>
<li>maximumPoolSize 最大线程池大小,当阻塞队列已满时向线程池中创建更多的线程(大于corePoolSize),最多不超过maximumPoolSize,来执行更多的任务;新创建的线程不会在阻塞队列未满时就被消耗,而是一直被分配任务,直到阻塞队列中的任务数量不足以给每一个线程都分配任务</li>
<li>keepAliveTime 线程存活时间,当线程池为执行更多任务而创建的线程(即超出corePoolSize的线程),在持续keepAliveTime时间没有被分配任务后销毁</li>
<li>workQueue 阻塞队列,用于存储提交到线程池的任务</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全</title>
    <url>/2023/04/01/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><span id="more"></span>

<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>​	在多个线程对同一个变量进行更改时,可能会导致线程对该变量的更改和读取出现错误,出现线程不安全</p>
<p>​	通过添加监听器或加锁的方式,限定变量同一时间只能被一个线程修改</p>
<h2 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1. 同步代码块"></a>1. 同步代码块</h2><p>​	使用synchronized(){} 方法同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(监视器(对象锁))&#123;</span><br><span class="line">    需要同步代码...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任何一个对象都可以作为监视器(锁)使用,且要保证并发线程使用的监视器是同一个对象</span></span><br></pre></td></tr></table></figure>

<p><strong>任何一个对象都可以作为监视器,无论是专门创建的,还是有其他用途的对象,但必须要保证唯一性</strong></p>
<p>使用wait()和notify()时，要通过监视器调用这些方法。</p>
<h2 id="2-同步方法"><a href="#2-同步方法" class="headerlink" title="2.同步方法"></a>2.同步方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法的监视器对象是 本类对象 <strong>this</strong> ,且不可修改8</p>
<h2 id="3-lock"><a href="#3-lock" class="headerlink" title="3.lock"></a>3.lock</h2><p> 使用Lock锁来控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;++i) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;该线程开始时的票数:&quot;</span> 					+ ticket.ticket);</span><br><span class="line">                sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            ticket.ticket -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="生产消费模型"><a href="#生产消费模型" class="headerlink" title="生产消费模型"></a>生产消费模型</h1><p>​	 对于一个频繁使用的线程,在不需要使用它时不应该直接终止该线程,而应该让线程挂起,使用wait()方法,不然会大量增减消耗</p>
<p>​	调用wait()的方法,必须跟监视器监听的对象一致,否则会陷入死锁</p>
<h1 id="使用Lock对生成消费模型进行并行控制"><a href="#使用Lock对生成消费模型进行并行控制" class="headerlink" title="使用Lock对生成消费模型进行并行控制"></a>使用Lock对生成消费模型进行并行控制</h1><ul>
<li><p>获取某个监视器的lock锁作为线程的锁,监视器应该是同一个,如使用仓库对象作为消费和生成线程的监视器</p>
</li>
<li><p>获取lock()锁的condition组件,用于线程的等待和唤醒</p>
</li>
<li><p>线程运行时应设置一个间隔,使其他线程可以获取到锁,避免一个线程一直运行,其他线程无法获取到锁</p>
</li>
<li><p>使用condition.await()使当前线程进入等待队列,使用condition.signal()唤醒等待队列中首个(等待时间最长)的线程</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Warehouse wh;</span><br><span class="line">    String name=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">    <span class="keyword">public</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Warehouse wh,String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wh = wh;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line">        lock=wh.lock;</span><br><span class="line">        <span class="built_in">this</span>.condition = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">produce</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr=wh.goods;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr.size()&lt;<span class="number">30</span>)&#123;</span><br><span class="line">                System.out.println(name+<span class="string">&quot;  生产:&quot;</span>+ (++wh.lastGood));</span><br><span class="line">                arr.add(wh.lastGood);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">// 仓库满则进入休眠</span></span><br><span class="line">                <span class="keyword">if</span>(wh.goods.size()&gt;=<span class="number">30</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;  生产前的仓库存储量:&quot;</span> + wh.goods.size());</span><br><span class="line">                <span class="comment">//生产</span></span><br><span class="line">                <span class="keyword">if</span>(produce())&#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;  生产后的仓库存储量:&quot;</span> + wh.goods.size());</span><br><span class="line">                    condition.signal();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;仓库已满&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Warehouse wh=<span class="keyword">new</span> <span class="title class_">Warehouse</span>();</span><br><span class="line">    String name=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">    <span class="keyword">public</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Warehouse wh,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.wh = wh;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        lock=wh.lock;</span><br><span class="line">        <span class="built_in">this</span>.condition=lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr=wh.goods;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;  消费:&quot;</span>+arr.get(<span class="number">0</span>));</span><br><span class="line">        arr.remove(<span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">// 若仓库为空,挂起</span></span><br><span class="line">                <span class="keyword">if</span>(wh.goods.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                        System.out.println(name+<span class="string">&quot;  进入等待&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;  消费前的仓库存储量:&quot;</span> + wh.goods.size());</span><br><span class="line">                <span class="comment">//消费</span></span><br><span class="line">                consume();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;  消费后的仓库存储量:&quot;</span> + wh.goods.size());</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Warehouse wh=<span class="keyword">new</span> <span class="title class_">Warehouse</span>();</span><br><span class="line">        Lock lock=wh.lock;</span><br><span class="line">        Condition condition=lock.newCondition();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(wh,<span class="string">&quot;Producer1&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(wh,<span class="string">&quot;Consumer1&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(wh,<span class="string">&quot;Consumer2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer1.start();</span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Warehouse wh=<span class="keyword">new</span> <span class="title class_">Warehouse</span>();</span><br><span class="line">        Lock lock=wh.lock;</span><br><span class="line">        Condition condition=lock.newCondition();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(wh,<span class="string">&quot;Producer1&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(wh,<span class="string">&quot;Consumer1&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(wh,<span class="string">&quot;Consumer2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer1.start();</span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS</title>
    <url>/2023/05/14/HTTPS/</url>
    <content><![CDATA[<p>HTTPS的实现,混合加密,数字签名,数字证书,TLS握手,数字证书校验和HTTPS安全性</p>
<span id="more"></span>

<h1 id="HTTPS与HTTP"><a href="#HTTPS与HTTP" class="headerlink" title="HTTPS与HTTP"></a>HTTPS与HTTP</h1><p>HTTPS在HTTP基础上发展而来,通过在HTTP和TCP网络层之间加入<strong>SSL&#x2F;TLS</strong>安全协议,解决了HTTP的三大风险</p>
<ul>
<li>信息加密:将信息加密,解决窃听风险;</li>
<li>校验机制:验证报文是否被篡改,解决篡改风险</li>
<li>身份证书:验证通信双方身份,解决伪装风险</li>
</ul>
<h1 id="HTTPS的实现"><a href="#HTTPS的实现" class="headerlink" title="HTTPS的实现"></a>HTTPS的实现</h1><h2 id="1-混合加密"><a href="#1-混合加密" class="headerlink" title="1.混合加密"></a>1.混合加密</h2><p>通信建立前使用非对称加密,通过公钥,私钥进行加密通信交换密钥</p>
<p>通信建立后使用对称加密,通过密钥加密通信</p>
<p>非对称加密速度慢,但可以安全交换密钥,对称加密速度快但无法安全交换密钥,因此使用混合加密模式</p>
<h2 id="2-摘要算法-amp-数字签名"><a href="#2-摘要算法-amp-数字签名" class="headerlink" title="2. 摘要算法&amp;数字签名"></a>2. 摘要算法&amp;数字签名</h2><p>​	在传输信息时,通过<strong>摘要算法</strong>(哈希算法),计算出内容的哈希值,一起发送,接收后次计算哈希值并比较便可确定内容是否遭到篡改,哈希值唯一且无法推导出内容;但不能保证 <strong>哈希值和内容一同被篡改</strong></p>
<p>​	非对称加密中,公钥加密,私钥解密用于保证传输内容安全,而私钥加密,公钥解密用于验证身份;</p>
<p>​	因为可以用公钥解密就证明该信息的来源拥有私钥,数字签名算法就通过私钥加密,公钥解密来实现,但只加密哈希值而不加密内容,因为消耗较大.在建立通信后服务器会将公钥发给客户端,然后服务器用私钥加密,就可以确定信息来自服务器;</p>
<p>​	但可能会遇到伪造公钥和密钥,即消息来源身份不确定,这时需要用到数字证书</p>
<h2 id="3-数字证书"><a href="#3-数字证书" class="headerlink" title="3.数字证书"></a>3.数字证书</h2><p>​	数字证书唯一,由CA(数字证书认证机构)颁发,只要证书是可信的,公钥和私钥就是可信的,即通过数字证书验证公钥和私钥是否被伪造</p>
<p>​	本质还是数字签名算法,由CA持有私钥并颁发公钥,不同的是CA颁发的公钥已事先存储在客户端中,不会在通信过程中被篡改</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/HTTPS%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81.png"></p>
<h1 id="HTTPS连接流程"><a href="#HTTPS连接流程" class="headerlink" title="HTTPS连接流程"></a>HTTPS连接流程</h1><p>​	基于RSA算法的TLS握手流程图:</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/RSA%E6%8F%A1%E6%89%8B.jpg"></p>
<p>​	过程中一共生成三个随机数:Client Random、Server Random、pre-master key,客户端和服务端会使用这三个随机数,使用双方协商的加密算法算出会话密钥;最后服务器向客户端发送消息,表示之后的信息都使用会话密钥加密</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>​	RSA算法存在前向安全的问题,若服务器的私钥丢失,则过去被截取的所有TLS密文都会被破解,对此,出现了<code>ECDHE</code>密钥协商算法,目前大多数网站都使用该算法</p>
<h2 id="校验数字证书"><a href="#校验数字证书" class="headerlink" title="校验数字证书"></a>校验数字证书</h2><ul>
<li>证书签名</li>
</ul>
<p>​	证书分为两部分,第一部分为证书的内容,包含持有者的公钥,用途,有效时间等信息,然后通过哈希算法将这些信息计算出一个哈希值,再使用CA的密钥将哈希值加密,添加到证书中,即为证书的第二部分</p>
<ul>
<li>校验证书</li>
</ul>
<p>​	客户端收到后,使用相同的哈希算法将证书的内容计算出一个哈希值,再使用CA的公钥解密证书中的哈希值,两者相同则证书可信,反之证书不可信</p>
<ul>
<li>证书信任链</li>
</ul>
<p>​	客户端收到证书后,会找到该证书的签发者,若签发者不是根证书,就接着向上找,直到找到根证书,即自签证书,然后根证书验证下级证书,依次进行,直到验证到本次的证书,形成一个证书信任链</p>
<p>​	这么做的目的是严格隔离根证书,防止根证书被修改,一旦根证书失效,整个信任链都会出现问题</p>
<h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><p>​	TLS实现上分为TLS握手协议和TLS记录协议,后者保护数据,验证其完整性和来源</p>
<p>​	消息会被分成多个片段,对每个片段进行压缩并附上消息认证码(MAC值,哈希算法生成),目的是保证完整性和防止被修改,然后对压缩片段和MAC进行加密,头部附上信息,然后发送出去</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/HTTPS%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7.jpg"></p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p><strong>HTTPS是否完全安全可靠?</strong></p>
<p>有一个中间人服务器,它与客户端完成TLS握手,然后再与原目标服务器完成TLS握手</p>
<p>​	在这种情况下,中间人服务器可以获取到并解密客户端发送的消息,也可以获取到并解密服务器发送的消息,但发生这种情况前提是客户端接受中间人的证书,因为中间人服务器无法获取服务器的私钥,无法去CA获取签名证书,只能伪造证书,这时浏览器会提示证书不可信,只要不接受该证书,信息就不会被泄露</p>
<p>​	不信任中间人证书是一种方法,另一种是HTTPS双向验证,即服务器也验证客户端的身份</p>
<p>​	HTTPS协议到目前位为止不存在任何漏洞,被中间人攻击是利用了客户端漏洞(信任中间人证书或被恶意导入伪造的根证书)</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP基本概念</title>
    <url>/2023/05/13/HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>​	HTTP基本概念,GET与POST,HTTP缓存,HTTP特性,HTTP性能</p>
<span id="more"></span>

<h1 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h1><p>​	HTTP,即超文本传输协议,HyperText Transfer Protocol.	“文本”的含义包括文字,图片,视频,压缩包等,而”超文本”,即文字,图片,视频等的混合体,最重要的是具有超链接,可以从一个超文本跳转到另一个超文本</p>
<h3 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h3><p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.jpg"></p>
<h3 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h3><ul>
<li><code>host</code>字段,指定服务器的域名,如Host:<a href="http://www.baidu.com/">www.baidu.com</a></li>
<li><code>Content-Length</code>字段,表明服务器返回数据的长度,用于表示数据的边界,防止TCP粘包</li>
<li><code>Connection</code>字段,用于使用长连接时,为兼容老版本HTTP,首部字段值应为Keep-Alive</li>
<li><code>Content-Type</code>字段,表明返回数据的格式</li>
<li><code>Accept</code>字段,客户端请求时表明可以接收的数据格式</li>
<li><code>Content-Encoding</code>字段,表明返回数据的压缩格式,对应<code>Accept-Encoding</code></li>
</ul>
<h1 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h1><ul>
<li><code>GET</code>的语义是:从服务器获取指定的资源,GET参数一般在URL中,URL只支持ASCII且限制长度</li>
<li><code>POST</code>的语义是:根据请求的负荷(报文body)对指定的资源作出修改,如提交一个评论,将评论内容放在报文body中发送给服务器,服务器生成相应的评论</li>
</ul>
<p>上面对于GET和POST是根据RFC规范分析的,实际开发中可能不遵循RFC规范,使用GET实现POST的功能或使用POST实现GET的功能</p>
<h3 id="安全和幂等"><a href="#安全和幂等" class="headerlink" title="安全和幂等"></a>安全和幂等</h3><ul>
<li>安全:请求方法不会有破坏服务器上资源的可能</li>
<li>幂等:多次相同操作的结果相同</li>
</ul>
<p>​	对于GET,由于是只读,因此是安全且幂等的;对于POST,由于会修改服务器上的资源,因此是不安全的,由于多次提交会创建多个相同的资源,因此不是幂等的.</p>
<h1 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h1><p>HTTP缓存有两种方式,分别是<strong>强制缓存</strong>和<strong>协商缓存</strong></p>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><ul>
<li><p>强制缓存由浏览器判断缓存是否过期,由浏览器决定是否使用本地缓存</p>
</li>
<li><p>强制缓存利用HTTP相应头部<code>Cache-Control</code>字段和<code>Expires</code>字段判断是否过去,前者是相对时间,后者是绝对时间,且Cache-Control优先级高于Expires</p>
</li>
<li><p>当浏览器再次请求时,根据请求时间和Cache-Control中设置过期时间计算,若没有过期则使用本地缓存,否则重新请求服务器,并重置Cache-Control和Expires</p>
</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><blockquote>
<p>当强制缓存失效时使用协商缓存</p>
</blockquote>
<p>​	当服务器返回码为304时,代表可以使用本地缓存</p>
<p>​	协商缓存可以通过两种方式实现:<code>If-Modified-Since</code>和<code>Last-Modified</code> ; <code>If-None-Match</code>与<code>ETag</code> ;两种字段组合,前一个是请求头字段,后一个是响应头字段</p>
<ul>
<li>第一种方法实现:请求时带上<code>If-Modified-Since</code>和<code>Last-Modified</code>,服务器接受到<code>If-Modified-Since</code>时,判断<code>Last-Modified</code>,若服务器最新的修改时间大于请求的最后修改时间,返回最新资源,反之使用本地缓存</li>
<li>第二种方法实现:若本地获取到的资源有ETag字段,再次请求时把<code>If-None-Match</code>设置为ETag的值,服务器比较ETag的值是否发生改变,若改变就返回最新资源,没有改变就使用本地缓存</li>
</ul>
<p>​	第一种方法是基于时间实现,第二章方法是基于唯一表示实现,相对来说后者更加可靠,避免修改时间带来的错误.因此ETag优先级更高,当<strong>请求时</strong>同时使用了这两种方法,服务器会在先判断ETag,ETag相同才会判断Last-Modified.</p>
<p><strong>ETag可以解决Last-Modified出现的问题:</strong></p>
<ol>
<li>没有修改文件内容,但文件最后修改时间改变</li>
<li>修改文件的时间粒度可能是秒以下,但Last-Modified的粒度是秒</li>
<li>服务器可能获取不到文件的精确修改时间</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/HTTP%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B.jpg"></p>
<h1 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h1><p>​	HTTP有版本1.1,2.0,3.0,不同版本的特性不同</p>
<h2 id="HTTP-x2F-1-1特性"><a href="#HTTP-x2F-1-1特性" class="headerlink" title="HTTP&#x2F;1.1特性"></a>HTTP&#x2F;1.1特性</h2><h3 id="HTTP-x2F-1-1最突出的优点是"><a href="#HTTP-x2F-1-1最突出的优点是" class="headerlink" title="HTTP&#x2F;1.1最突出的优点是:"></a>HTTP&#x2F;1.1最突出的优点是:</h3><ol>
<li>简单:报文格式是简单的文本格式</li>
<li>灵活和易于拓展:各种请求方法,URL等每个组成的要求不固定,可根据情况改变</li>
<li>应用广泛和跨平台</li>
</ol>
<h3 id="HTTP-x2F-1-1的缺陷"><a href="#HTTP-x2F-1-1的缺陷" class="headerlink" title="HTTP&#x2F;1.1的缺陷:"></a>HTTP&#x2F;1.1的缺陷:</h3><ol>
<li><p>无状态:无状态可以节省空间和服务器的负担,但面对有关联的操作非常麻烦,无法记录用户信息等,可以用Cookie技术解决,Cookie由服务器生成,客户端保存,发送请求时附带Cookie来识别身份</p>
</li>
<li><p>明文传输:明文传输使内容可以直接被人识别,方便调试,但所有内容都无隐私可言</p>
</li>
<li><p>不安全:不安全有三个方面</p>
<ul>
<li><p>使用明文通信,信息会泄露</p>
</li>
<li><p>不验证通信双方身份,可能遭遇伪装</p>
</li>
<li><p>无法验证报文完整性,内容可能遭到篡改</p>
</li>
</ul>
</li>
</ol>
<h3 id="HTTP-x2F-1-1性能"><a href="#HTTP-x2F-1-1性能" class="headerlink" title="HTTP&#x2F;1.1性能"></a>HTTP&#x2F;1.1性能</h3><p>HTTP使用TCP&#x2F;IP,使用<strong>请求-应答</strong>的通信方式</p>
<ol>
<li>长连接:减少TCP重复建立连接的消耗,减轻服务器负担;特点是必须双方都明确提出断开连接才断开,但当长连接长时无数据交互,服务端会主动断开</li>
<li>管道网络传输:可以发送多个请求不必等待前一个请求响应,减少整体的响应时间;HTTP&#x2F;1.1解决了请求的队头阻塞但没有解决响应的队头阻塞,处理某个请求时,服务器会阻塞后续请求</li>
<li>队头阻塞:一个请求被阻塞,后续所有请求都被阻塞</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
</search>
