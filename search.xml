<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>NEXT主题使用说明</title>
    <url>/2022/10/24/NEXT%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a><center>MarkDown</center></h1><h2 id="基本信息配置"><a href="#基本信息配置" class="headerlink" title="基本信息配置"></a>基本信息配置</h2><p>Markdown最上方<code>---</code>分割区域Next预定义参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td>博客名</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
<td>更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类</td>
<td></td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章网址</td>
<td></td>
</tr>
<tr>
<td>excerpt</td>
<td></td>
<td></td>
</tr>
<tr>
<td>disableNunjucks</td>
<td></td>
<td></td>
</tr>
<tr>
<td>lang</td>
<td>语言</td>
<td></td>
</tr>
</tbody></table>
<p>tags和categories等可以设置多个值：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag2</span>	</span><br></pre></td></tr></table></figure>

<p>该方法会使tag2成为tag1的子标签，要设置同级标签，应用一下方式，其中父标签1,2,3是同级标签，categories分类标签同理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签1</span>, <span class="string">子标签1</span>]</span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签2</span>, <span class="string">子标签2</span>]</span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签3</span>]</span><br></pre></td></tr></table></figure>

<h1 id="日程表"><a href="#日程表" class="headerlink" title="日程表"></a>日程表</h1><p>由于使用type&#x3D;”schedule”	时无法正确显示Markdown，所以将type改为about</p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>使用本地插入时，绝对路径和相对路径都无法加载图片，所以采用图床的方式插入图片，<a href="https://sm.ms/">SM.MS</a>，上传图片后以网络链接的形式插入图片</p>
]]></content>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟与高精度</title>
    <url>/2022/10/26/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="A-B-Problem"><a href="#A-B-Problem" class="headerlink" title="A*B Problem"></a><center>A*B Problem</center></h1><p>题目：输入A，B，求A*B的值</p>
<p>若A的长度为n，B的长度为m，则A*B的长度&lt;&#x3D;n+m,由此确定结果数组的长度。模拟进行A*B运算，B由低到高每一位与A的每一位相乘，由于I，j从0开始，故可以用i+j确定每位相乘的结果是结果数组的第几位。</p>
<p>进行运算前先把输入的A，B逆序以便于计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* numA = <span class="keyword">new</span> <span class="type">int</span>[a.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="type">int</span>* numB = <span class="keyword">new</span> <span class="type">int</span>[b.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="type">int</span>* res = <span class="keyword">new</span> <span class="type">int</span>[a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">		res[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); ++i) &#123;	<span class="comment">//倒序把字符串转换为数字数组</span></span><br><span class="line">		numA[i] = a[a.<span class="built_in">length</span>() - i - <span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">		numB[i] = b[b.<span class="built_in">length</span>() - i - <span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; b.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">			res[i + j] += numA[i] * numB[j];</span><br><span class="line">			<span class="keyword">if</span> (res[i+j]&gt;<span class="number">9</span>) res[i + j+<span class="number">1</span>] += res[i + j]/<span class="number">10</span>;</span><br><span class="line">			res[i + j] = res[i + j] % <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">false</span>;	<span class="comment">//是否已去除前面的0</span></span><br><span class="line">	<span class="keyword">for</span> (i = a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;	<span class="comment">//输出</span></span><br><span class="line">		<span class="keyword">if</span> (res[i])	flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (flag)	cout &lt;&lt; res[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flag) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;	<span class="comment">//如果全是0，输出一个0</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] numA;</span><br><span class="line">	<span class="keyword">delete</span>[] numB;</span><br><span class="line">	<span class="keyword">delete</span>[] res;</span><br></pre></td></tr></table></figure>

<h1 id="N！之和问题"><a href="#N！之和问题" class="headerlink" title="N！之和问题"></a><center>N！之和问题</center></h1><p>求解阶乘之和</p>
<p>就是把高精乘和高精加结合起来，但在处理高精乘进位时，应该把所有的位数遍历一遍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">90</span>; ++j) &#123;</span><br><span class="line">	<span class="keyword">if</span> (now[j] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">		now[j + <span class="number">1</span>] += now[j] / <span class="number">10</span>;</span><br><span class="line">		now[j] %= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若使用判断的方法，可能会出现这一位不大于9但下面的位大于9的情况，造成出错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(now[count]&gt;<span class="number">9</span>)&#123;	<span class="comment">//进位</span></span><br><span class="line">	now[count + <span class="number">1</span>] += now[count] / <span class="number">10</span>;</span><br><span class="line">	now[count] %=  <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2022/11/06/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><center>二叉树</center></h1><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a><center>遍历</center></h2><p>前序遍历 <code>根-左-右</code>		中序遍历 <code>左-根-右</code>		后序遍历 <code>左-右-根</code></p>
<p><img src="https://s2.loli.net/2022/11/06/FrwMeBjslUpYDuH.png" alt="二叉树图.png"></p>
<p>前序遍历A-B-D-F-G-H-I-E-C</p>
<p>中序遍历F-D-H-G-I-B-E-A-C</p>
<p>后序遍历F-H-I-G-D-E-B-C-A</p>
<p>对二叉树进行遍历，前序和中序用栈而后序用两个栈实现从最后开始输出</p>
<p><em>先序遍历代码实现：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历 非递归先序遍历 头=&gt;左=&gt;右</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk;	<span class="comment">//定义一个栈</span></span><br><span class="line">		stk.<span class="built_in">push</span>(head);</span><br><span class="line">		<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			head = stk.<span class="built_in">top</span>();</span><br><span class="line">			stk.<span class="built_in">pop</span>();</span><br><span class="line">			cout &lt;&lt; head-&gt;val &lt;&lt; endl;	<span class="comment">//处理语句</span></span><br><span class="line">			<span class="keyword">if</span> (head-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>中序遍历代码实现</em></p>
<p>中序遍历时先把所有左节点入栈，遇到空指针时出一个左节点并把其右节点入栈，</p>
<p>并在此时进行操作，就可以实现左-中-右的遍历</p>
<p>​	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归中序遍历	左=&gt;头=&gt;右</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk;</span><br><span class="line">		<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()||head!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head);</span><br><span class="line">				head = head-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				head = stk.<span class="built_in">top</span>();</span><br><span class="line">				cout &lt;&lt; head-&gt;val &lt;&lt; endl;</span><br><span class="line">				stk.<span class="built_in">pop</span>();</span><br><span class="line">				head = head-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>后序遍历代码实现：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归后序遍历	左=&gt;右=&gt;头 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">posOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk1;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk2;</span><br><span class="line">		stk1.<span class="built_in">push</span>(head);</span><br><span class="line">		<span class="keyword">while</span> (!stk1.<span class="built_in">empty</span>()) &#123;	<span class="comment">//弹出时不操作而是放入另一个栈中</span></span><br><span class="line">			head = stk1.<span class="built_in">top</span>();</span><br><span class="line">			stk2.<span class="built_in">push</span>(head);</span><br><span class="line">			stk1.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk1.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk1.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!stk2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			cout &lt;&lt; stk2.<span class="built_in">top</span>()-&gt;val &lt;&lt; endl;</span><br><span class="line">			stk2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		对三种遍历结果进行观察，前序的最前边是头节点，而后序的最后一个是头节点，然后根据中序遍历的结果可以进行二叉树复原，但只有前序和后序是无法复原的。</p>
<h2 id="祖先"><a href="#祖先" class="headerlink" title="祖先"></a><center>祖先</center></h2><h4 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h4>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象</title>
    <url>/2022/12/27/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><ul>
<li><p>对象：具体的事物</p>
</li>
<li><p>类：概念，模板，抽象的描述</p>
</li>
</ul>
<h4 id="类的代码定义"><a href="#类的代码定义" class="headerlink" title="类的代码定义"></a>类的代码定义</h4><p><strong>格式：public class 类名 {}</strong></p>
<p>命名规范： 类目必须与所在的文件名一致，要求首字母大写，使用驼峰命名规范</p>
<p>内容：</p>
<p>​	成员属性：数据类型 数据名</p>
<p>​	成员方法：修饰词 返回值类型 方法名（参数类型 参数名） {}</p>
<p>​	任何方法都要放在类的结构中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    String userName;</span><br><span class="line">    String userPwd;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="type">boolean</span> isOnline;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showUserInfo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPassword</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String oldpwd, String newpwd)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="封装属性"><a href="#封装属性" class="headerlink" title="封装属性"></a>封装属性</h2><ul>
<li><p>将成员属性私有化，限制对属性的调用，针对每一个属性对设置对应的 赋值方法和获取方法</p>
</li>
<li><p>优点： </p>
<ul>
<li>set属性时 ，可以对传入参数进行验证，保证数据规范安全 </li>
<li>get属性时，可以对需要返回数据进行整合处理 返回对方需要的格式类型 </li>
<li>结构更清晰  size(w,h); 简化代码 整合数据 </li>
<li>读写分离，存在一些属性，不暴露 读&#x2F;写</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPwd;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isOnline;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserPwd</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserAge</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserScore</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserPwd</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserAge</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserScore</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getUserOnline</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showUserInfo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPassword</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String oldpwd, String newpwd)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化： 构造方法<ul>
<li>格式：类名 （参数列表）{}    没有返回值结构</li>
<li>每个类都自带一个隐式的空参数构造方法 ，一旦自己写了构造方法，不管有无参数 都会覆盖隐式的 </li>
<li>构造方法可以重组</li>
<li>构造方法在创建对象时调用，且只被调用一次</li>
</ul>
</li>
<li>私有化构造方法：<ul>
<li>私有化构造可有令该类不能在类的外部创建对象，对创建对象的权限做了限制</li>
</ul>
</li>
<li>单例：<ul>
<li>单例类只能有一个对象存在</li>
<li>将构造方法私有化后在单例类中创建一个公有 静态 的对象，该对象可以在类外部通过类名直接调用</li>
<li>在类中创建类对象若不添加static 关键字会导致不断递归创建该对象，导致死循环</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPwd;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isOnline;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String userName,String userPwd,<span class="type">int</span> age,<span class="type">int</span> score)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User king= <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;king&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="number">50</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getKing</span><span class="params">()</span>&#123;<span class="keyword">return</span> king&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserPwd</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserAge</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserScore</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserPwd</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserAge</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserScore</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getUserOnline</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showUserInfo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPassword</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String oldpwd, String newpwd)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2022/12/29/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul>
<li>继承格式 ： class 类名 extends 父类名 {}</li>
<li>访问修饰符：<ul>
<li>public 该项目所有文件</li>
<li>protrcted 子类及同包</li>
<li>private 本类及友类</li>
<li>无       同包下</li>
</ul>
</li>
<li>方法重写：<ul>
<li>在子类中重写父类中方法<ul>
<li>访问修饰词  权限不变或小权限变大权限，扩展开放原则</li>
<li>返回值类型  可以返回父类及父类的子类</li>
<li>不能修改参数表</li>
</ul>
</li>
</ul>
</li>
<li>类型转换：<ul>
<li>自动类型转换：基类指针可以指向子类，子类对象可以被自动转化为基类对象</li>
<li>强制类型转化：将基类对象转化子类对象，需要进行强制类型转换，强制向下转型需要验证是否合法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-DDL</title>
    <url>/2022/12/30/MySQL1/</url>
    <content><![CDATA[<h1 id="一、启动"><a href="#一、启动" class="headerlink" title="一、启动"></a>一、启动</h1><ul>
<li>使用MySQL终端输入密码后启动</li>
<li>使用CMD，输入 <code>mysql -u 用户名 -p</code>后启动</li>
</ul>
<h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><ul>
<li>关系型数据库：建立在关系模型的基础上，由多张相互连接的二维表组成的数据库</li>
<li>非关系型数据库：</li>
</ul>
<h1 id="三、SQL"><a href="#三、SQL" class="headerlink" title="三、SQL"></a>三、SQL</h1><h2 id="1-通用语法及分类"><a href="#1-通用语法及分类" class="headerlink" title="1.通用语法及分类"></a>1.通用语法及分类</h2><ul>
<li><p>通用语法</p>
<ol>
<li><p>可以单行或多行书写，以分号结尾</p>
</li>
<li><p>不区分大小写，关键字建议大写</p>
</li>
<li><p>单行注释： <code>--注释内容</code> or # <code>注释内容</code></p>
</li>
<li><p>多行注释：<code> /* 注释内容*/</code></p>
</li>
</ol>
</li>
<li><p>SQL分类</p>
<ol>
<li>DDL：定义语言，定义数据库对象</li>
<li>DML：操作语言，进行增删改查</li>
<li>DQL：查询语言，查询数据库中的记录</li>
<li>DCL：控制语言，创建用户，修改权限</li>
</ol>
</li>
</ul>
<h2 id="2-DDL"><a href="#2-DDL" class="headerlink" title="2.DDL"></a>2.DDL</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li>查询<ul>
<li>查询全部数据库 <code>show databases;</code></li>
<li>查询当前数据库<code>select database();</code></li>
</ul>
</li>
<li>创建<ul>
<li>创建数据库 <code>create database [if no exists] 名称 [default charset 字符集] [collate 排序规则]</code>,使用时去掉括号</li>
</ul>
</li>
<li>删除<ul>
<li><code>drop database [if exists] 名称</code></li>
</ul>
</li>
<li>使用(切换数据库)<ul>
<li><code>use 名称</code></li>
</ul>
</li>
</ul>
<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><ul>
<li><p>查询</p>
<ul>
<li>查询当前所有表	<code>show tables;</code></li>
<li>查询表结构   <code>desc 表名;</code></li>
</ul>
</li>
<li><p>创建</p>
<ul>
<li>&#96;&#96;&#96;<br>create table 表名(<br>字段1 字段1类型[comment 字段1注释]<br>…….<br>)[comment 表注释];<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```sql</span><br><span class="line">create table tb_user(</span><br><span class="line">	id int comment &#x27;编号&#x27;,</span><br><span class="line">	name varchar(50) comment &#x27;姓名&#x27;,</span><br><span class="line">	......</span><br><span class="line">	age int comment &#x27;年龄&#x27;</span><br><span class="line">) comment &#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数据类型</p>
<ul>
<li>整形	名称 整形类型 [unsigned]</li>
<li>浮点    名称 浮点类型(长度,小数位数)</li>
<li>定长字符串  char(最大长度)  长度一直是10,性能好</li>
<li>变长字符串  varchar(最大长度)  根据数据改变长度,性能较差</li>
<li>后缀为 lob 代表是二进制数据</li>
<li>date,time,year,datetime,timestamp</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">	id <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">	workno <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;工号&#x27;</span>,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">	gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">	age tinyint unsigned comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">	entrydate <span class="type">date</span> comment <span class="string">&#x27;入职时间&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;员工表&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<ul>
<li><p>添加字段 <code>alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];</code></p>
</li>
<li><p>修改字段数据类型 <code>alter table 表名 modify 字段名 新数据类型(长度);</code></p>
</li>
<li><p>修改字段名和类型 <code>alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];</code></p>
</li>
<li><p>修改表名 <code>alter table 表名 rename to 新表名;</code></p>
</li>
<li><p>删除字段<code>alter table 表名 drop 字段名;</code></p>
</li>
<li><p>删除表 <code>drop table [if exists] 表名;</code></p>
</li>
<li><p>删除表后并重新创建该表<code>truncate table 表名;</code> 即留下一个空表</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
