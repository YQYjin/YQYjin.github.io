<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>NEXT主题使用说明</title>
    <url>/2022/12/29/NEXT%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a><center>MarkDown</center></h1><span id="more"></span>

<h2 id="基本信息配置"><a href="#基本信息配置" class="headerlink" title="基本信息配置"></a>基本信息配置</h2><p>Markdown最上方<code>---</code>分割区域Next预定义参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td>博客名</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
<td>更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类</td>
<td></td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章网址</td>
<td></td>
</tr>
<tr>
<td>excerpt</td>
<td></td>
<td></td>
</tr>
<tr>
<td>disableNunjucks</td>
<td></td>
<td></td>
</tr>
<tr>
<td>lang</td>
<td>语言</td>
<td></td>
</tr>
</tbody></table>
<p>tags和categories等可以设置多个值：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag2</span>	</span><br></pre></td></tr></table></figure>

<p>该方法会使tag2成为tag1的子标签，要设置同级标签，应用一下方式，其中父标签1,2,3是同级标签，categories分类标签同理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签1</span>, <span class="string">子标签1</span>]</span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签2</span>, <span class="string">子标签2</span>]</span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签3</span>]</span><br></pre></td></tr></table></figure>

<h1 id="日程表"><a href="#日程表" class="headerlink" title="日程表"></a>日程表</h1><p>由于使用type&#x3D;”schedule”	时无法正确显示Markdown，所以将type改为about</p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>使用本地插入时，绝对路径和相对路径都无法加载图片，所以采用图床的方式插入图片，<a href="https://sm.ms/">SM.MS</a>，上传图片后以网络链接的形式插入图片</p>
]]></content>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟与高精度</title>
    <url>/2022/12/29/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="A-B-Problem"><a href="#A-B-Problem" class="headerlink" title="A*B Problem"></a><center>A*B Problem</center></h1><span id="more"></span>

<p>题目：输入A，B，求A*B的值</p>
<p>若A的长度为n，B的长度为m，则A*B的长度&lt;&#x3D;n+m,由此确定结果数组的长度。模拟进行A*B运算，B由低到高每一位与A的每一位相乘，由于I，j从0开始，故可以用i+j确定每位相乘的结果是结果数组的第几位。</p>
<p>进行运算前先把输入的A，B逆序以便于计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* numA = <span class="keyword">new</span> <span class="type">int</span>[a.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="type">int</span>* numB = <span class="keyword">new</span> <span class="type">int</span>[b.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="type">int</span>* res = <span class="keyword">new</span> <span class="type">int</span>[a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">		res[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); ++i) &#123;	<span class="comment">//倒序把字符串转换为数字数组</span></span><br><span class="line">		numA[i] = a[a.<span class="built_in">length</span>() - i - <span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">		numB[i] = b[b.<span class="built_in">length</span>() - i - <span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; b.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">			res[i + j] += numA[i] * numB[j];</span><br><span class="line">			<span class="keyword">if</span> (res[i+j]&gt;<span class="number">9</span>) res[i + j+<span class="number">1</span>] += res[i + j]/<span class="number">10</span>;</span><br><span class="line">			res[i + j] = res[i + j] % <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">false</span>;	<span class="comment">//是否已去除前面的0</span></span><br><span class="line">	<span class="keyword">for</span> (i = a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;	<span class="comment">//输出</span></span><br><span class="line">		<span class="keyword">if</span> (res[i])	flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (flag)	cout &lt;&lt; res[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flag) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;	<span class="comment">//如果全是0，输出一个0</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] numA;</span><br><span class="line">	<span class="keyword">delete</span>[] numB;</span><br><span class="line">	<span class="keyword">delete</span>[] res;</span><br></pre></td></tr></table></figure>

<h1 id="N！之和问题"><a href="#N！之和问题" class="headerlink" title="N！之和问题"></a><center>N！之和问题</center></h1><p>求解阶乘之和</p>
<p>就是把高精乘和高精加结合起来，但在处理高精乘进位时，应该把所有的位数遍历一遍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">90</span>; ++j) &#123;</span><br><span class="line">	<span class="keyword">if</span> (now[j] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">		now[j + <span class="number">1</span>] += now[j] / <span class="number">10</span>;</span><br><span class="line">		now[j] %= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若使用判断的方法，可能会出现这一位不大于9但下面的位大于9的情况，造成出错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(now[count]&gt;<span class="number">9</span>)&#123;	<span class="comment">//进位</span></span><br><span class="line">	now[count + <span class="number">1</span>] += now[count] / <span class="number">10</span>;</span><br><span class="line">	now[count] %=  <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2022/12/29/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><center>二叉树</center></h1><span id="more"></span>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a><center>遍历</center></h2><p>前序遍历 <code>根-左-右</code>		中序遍历 <code>左-根-右</code>		后序遍历 <code>左-右-根</code></p>
<p><img src="https://s2.loli.net/2022/11/06/FrwMeBjslUpYDuH.png" alt="二叉树图.png"></p>
<p>前序遍历A-B-D-F-G-H-I-E-C</p>
<p>中序遍历F-D-H-G-I-B-E-A-C</p>
<p>后序遍历F-H-I-G-D-E-B-C-A</p>
<p>对二叉树进行遍历，前序和中序用栈而后序用两个栈实现从最后开始输出</p>
<p><em>先序遍历代码实现：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历 非递归先序遍历 头=&gt;左=&gt;右</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk;	<span class="comment">//定义一个栈</span></span><br><span class="line">		stk.<span class="built_in">push</span>(head);</span><br><span class="line">		<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			head = stk.<span class="built_in">top</span>();</span><br><span class="line">			stk.<span class="built_in">pop</span>();</span><br><span class="line">			cout &lt;&lt; head-&gt;val &lt;&lt; endl;	<span class="comment">//处理语句</span></span><br><span class="line">			<span class="keyword">if</span> (head-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>中序遍历代码实现</em></p>
<p>中序遍历时先把所有左节点入栈，遇到空指针时出一个左节点并把其右节点入栈，</p>
<p>并在此时进行操作，就可以实现左-中-右的遍历</p>
<p>​	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归中序遍历	左=&gt;头=&gt;右</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk;</span><br><span class="line">		<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()||head!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head);</span><br><span class="line">				head = head-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				head = stk.<span class="built_in">top</span>();</span><br><span class="line">				cout &lt;&lt; head-&gt;val &lt;&lt; endl;</span><br><span class="line">				stk.<span class="built_in">pop</span>();</span><br><span class="line">				head = head-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>后序遍历代码实现：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归后序遍历	左=&gt;右=&gt;头 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">posOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk1;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk2;</span><br><span class="line">		stk1.<span class="built_in">push</span>(head);</span><br><span class="line">		<span class="keyword">while</span> (!stk1.<span class="built_in">empty</span>()) &#123;	<span class="comment">//弹出时不操作而是放入另一个栈中</span></span><br><span class="line">			head = stk1.<span class="built_in">top</span>();</span><br><span class="line">			stk2.<span class="built_in">push</span>(head);</span><br><span class="line">			stk1.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk1.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk1.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!stk2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			cout &lt;&lt; stk2.<span class="built_in">top</span>()-&gt;val &lt;&lt; endl;</span><br><span class="line">			stk2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		对三种遍历结果进行观察，前序的最前边是头节点，而后序的最后一个是头节点，然后根据中序遍历的结果可以进行二叉树复原，但只有前序和后序是无法复原的。</p>
<h2 id="祖先"><a href="#祖先" class="headerlink" title="祖先"></a><center>祖先</center></h2><h4 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h4>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象</title>
    <url>/2022/12/29/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><span id="more"></span>

<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><ul>
<li><p>对象：具体的事物</p>
</li>
<li><p>类：概念，模板，抽象的描述</p>
</li>
</ul>
<h4 id="类的代码定义"><a href="#类的代码定义" class="headerlink" title="类的代码定义"></a>类的代码定义</h4><p><strong>格式：public class 类名 {}</strong></p>
<p>命名规范： 类目必须与所在的文件名一致，要求首字母大写，使用驼峰命名规范</p>
<p>内容：</p>
<p>​	成员属性：数据类型 数据名</p>
<p>​	成员方法：修饰词 返回值类型 方法名（参数类型 参数名） {}</p>
<p>​	任何方法都要放在类的结构中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    String userName;</span><br><span class="line">    String userPwd;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="type">boolean</span> isOnline;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showUserInfo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPassword</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String oldpwd, String newpwd)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="封装属性"><a href="#封装属性" class="headerlink" title="封装属性"></a>封装属性</h2><ul>
<li><p>将成员属性私有化，限制对属性的调用，针对每一个属性对设置对应的 赋值方法和获取方法</p>
</li>
<li><p>优点： </p>
<ul>
<li>set属性时 ，可以对传入参数进行验证，保证数据规范安全 </li>
<li>get属性时，可以对需要返回数据进行整合处理 返回对方需要的格式类型 </li>
<li>结构更清晰  size(w,h); 简化代码 整合数据 </li>
<li>读写分离，存在一些属性，不暴露 读&#x2F;写</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPwd;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isOnline;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserPwd</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserAge</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserScore</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserPwd</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserAge</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserScore</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getUserOnline</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showUserInfo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPassword</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String oldpwd, String newpwd)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化： 构造方法<ul>
<li>格式：类名 （参数列表）{}    没有返回值结构</li>
<li>每个类都自带一个隐式的空参数构造方法 ，一旦自己写了构造方法，不管有无参数 都会覆盖隐式的 </li>
<li>构造方法可以重组</li>
<li>构造方法在创建对象时调用，且只被调用一次</li>
</ul>
</li>
<li>私有化构造方法：<ul>
<li>私有化构造可有令该类不能在类的外部创建对象，对创建对象的权限做了限制</li>
</ul>
</li>
<li>单例：<ul>
<li>单例类只能有一个对象存在</li>
<li>将构造方法私有化后在单例类中创建一个公有 静态 的对象，该对象可以在类外部通过类名直接调用</li>
<li>在类中创建类对象若不添加static 关键字会导致不断递归创建该对象，导致死循环</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPwd;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isOnline;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String userName,String userPwd,<span class="type">int</span> age,<span class="type">int</span> score)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User king= <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;king&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="number">50</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getKing</span><span class="params">()</span>&#123;<span class="keyword">return</span> king&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserPwd</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserAge</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserScore</span><span class="params">(String userName)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserPwd</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserAge</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserScore</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getUserOnline</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showUserInfo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPassword</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String pwdin)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String oldpwd, String newpwd)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2022/12/29/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><span id="more"></span>

<ul>
<li>继承格式 ： class 类名 extends 父类名 {}</li>
<li>访问修饰符：<ul>
<li>public 该项目所有文件</li>
<li>protrcted 子类及同包</li>
<li>private 本类及友类</li>
<li>无       同包下</li>
</ul>
</li>
<li>方法重写：<ul>
<li>在子类中重写父类中方法<ul>
<li>访问修饰词  权限不变或小权限变大权限，扩展开放原则</li>
<li>返回值类型  可以返回父类及父类的子类</li>
<li>不能修改参数表</li>
</ul>
</li>
</ul>
</li>
<li>类型转换：<ul>
<li>自动类型转换：基类指针可以指向子类，子类对象可以被自动转化为基类对象</li>
<li>强制类型转化：将基类对象转化子类对象，需要进行强制类型转换，强制向下转型需要验证是否合法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL简介</title>
    <url>/2022/12/30/MySQL1/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="一、启动"><a href="#一、启动" class="headerlink" title="一、启动"></a>一、启动</h1><ul>
<li>使用MySQL终端输入密码后启动</li>
<li>使用CMD，输入 <code>mysql -u 用户名 -p</code>后启动</li>
</ul>
<h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><ul>
<li>关系型数据库：建立在关系模型的基础上，由多张相互连接的二维表组成的数据库</li>
<li>非关系型数据库：</li>
</ul>
<!--more-->

<h1 id="三、SQL"><a href="#三、SQL" class="headerlink" title="三、SQL"></a>三、SQL</h1><h2 id="1-通用语法及分类"><a href="#1-通用语法及分类" class="headerlink" title="1.通用语法及分类"></a>1.通用语法及分类</h2><ul>
<li><p>通用语法</p>
<ol>
<li><p>可以单行或多行书写，以分号结尾</p>
</li>
<li><p>不区分大小写，关键字建议大写</p>
</li>
<li><p>单行注释： <code>--注释内容</code> or # <code>注释内容</code></p>
</li>
<li><p>多行注释：<code> /* 注释内容*/</code></p>
</li>
</ol>
</li>
<li><p>SQL分类</p>
<ol>
<li>DDL：定义语言，定义数据库对象</li>
<li>DML：操作语言，进行增删改查</li>
<li>DQL：查询语言，查询数据库中的记录</li>
<li>DCL：控制语言，创建用户，修改权限</li>
</ol>
</li>
</ul>
<h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li>查询<ul>
<li>查询全部数据库 <code>show databases;</code></li>
<li>查询当前数据库<code>select database();</code></li>
</ul>
</li>
<li>创建<ul>
<li>创建数据库 <code>create database [if no exists] 名称 [default charset 字符集] [collate 排序规则]</code>,使用时去掉括号</li>
</ul>
</li>
<li>删除<ul>
<li><code>drop database [if exists] 名称</code></li>
</ul>
</li>
<li>使用(切换数据库)<ul>
<li><code>use 名称</code></li>
</ul>
</li>
</ul>
<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><ul>
<li><p>查询</p>
<ul>
<li>查询当前所有表	<code>show tables;</code></li>
<li>查询表结构   <code>desc 表名;</code></li>
</ul>
</li>
<li><p>创建</p>
<ul>
<li>&#96;&#96;&#96;<br>create table 表名(<br>字段1 字段1类型[comment 字段1注释]<br>…….<br>)[comment 表注释];<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```sql</span><br><span class="line">create table tb_user(</span><br><span class="line">	id int comment &#x27;编号&#x27;,</span><br><span class="line">	name varchar(50) comment &#x27;姓名&#x27;,</span><br><span class="line">	......</span><br><span class="line">	age int comment &#x27;年龄&#x27;</span><br><span class="line">) comment &#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数据类型</p>
<ul>
<li>整形	名称 整形类型 [unsigned]</li>
<li>浮点    名称 浮点类型(长度,小数位数)</li>
<li>定长字符串  char(最大长度)  长度一直是10,性能好</li>
<li>变长字符串  varchar(最大长度)  根据数据改变长度,性能较差</li>
<li>后缀为 lob 代表是二进制数据</li>
<li>date,time,year,datetime,timestamp</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">	id <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">	workno <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;工号&#x27;</span>,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">	gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">	age tinyint unsigned comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">	entrydate <span class="type">date</span> comment <span class="string">&#x27;入职时间&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;员工表&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<ul>
<li><p>添加字段 <code>alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];</code></p>
</li>
<li><p>修改字段数据类型 <code>alter table 表名 modify 字段名 新数据类型(长度);</code></p>
</li>
<li><p>修改字段名和类型 <code>alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];</code></p>
</li>
<li><p>修改表名 <code>alter table 表名 rename to 新表名;</code></p>
</li>
<li><p>删除字段<code>alter table 表名 drop 字段名;</code></p>
</li>
<li><p>删除表 <code>drop table [if exists] 表名;</code></p>
</li>
<li><p>删除表后并重新创建该表<code>truncate table 表名;</code> 即留下一个空表</p>
</li>
</ul>
</li>
</ul>
<h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><p><strong>DML用来对表中数据记录进行增删改操作</strong></p>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><ul>
<li>给指定字段添加数据 <code>insert into 表名(字段名1,字段名2,...) values(值1,值2,...);</code></li>
<li>给全部字段添加数据 <code>insert into 表名 values(值1,值2,...);</code></li>
<li>批量添加数据<code>insert into 表名(字段名1,...) values(值1,...),(值1,...)...;</code></li>
</ul>
<p>注意:</p>
<p>​	<em>值与字段名一一对应;</em></p>
<p>​	<em>字符串和日期型数据应包含在引号中;</em></p>
<p>​	<em>插入的数据应在字段规定的范围内;</em></p>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li><p><code>update 表名 set 字段名1=值1,...... [where 条件];</code> 若无条件则修改所有字段</p>
<pre><code>   如: `update employee set name = &#39;itheima&#39; where id = 1;`
</code></pre>
</li>
<li><p>若修改后没有where字段或where字段筛选的不是键列,可能会报错,需要退出安全模式再执行</p>
</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li><p><code>dalete from 表名 [where 条件];</code>  </p>
<p>delete不能删除某个字段的值,应使用update把字段的值设为NULL</p>
</li>
</ul>
<h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><h2 id="查询语言"><a href="#查询语言" class="headerlink" title="查询语言"></a>查询语言</h2><ul>
<li><p><strong>基本查询</strong></p>
<ul>
<li>查询多个字段 <code>select 字段1,字段2... from 表名;</code> or <code>select * from 表名;</code>查询所有字段</li>
<li>设置别名 <code>select 字段1 [as 别名],...... from 表名;</code></li>
<li>去除重复记录 <code>select distinct 字段列表 from 表名;</code></li>
</ul>
</li>
<li><p><strong>条件查询</strong>(模糊查询)</p>
<ul>
<li><p><code>select 字段列表 from 表名 where 条件列表;</code>  </p>
<p>like 占位符 模糊匹配(_匹配单个字符,%匹配任意个字符)</p>
<p><code>select * from emp where name like &#39;__&#39;;</code>表示匹配两个字符的</p>
<p><code>select * from emp where idcard like &#39;%X&#39;;</code> 匹配最后一个字符是X的</p>
<p>is null  是空</p>
<p>between … and … 某个范围内,闭区间</p>
<p>in (…)	在in之后列表中的值,多选一</p>
</li>
</ul>
</li>
<li><p><strong>聚合函数</strong></p>
<p>​	将一列数据作为一个整体,进行纵向计算</p>
<p>​	常见聚合函数:  <code>cout</code> ,<code>max</code>,<code>min</code> ,<code>avg</code> ,<code>sum</code>,对有值的数据进行计算,null不参与计算</p>
<ul>
<li><code>select 聚合函数(字段列表) from 表名</code></li>
</ul>
</li>
<li><p><strong>分组查询</strong></p>
<ul>
<li><p><code>select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后的条件]</code></p>
<p>where不能对聚合函数进行判断,而having可以</p>
<p><code>select gender,count(*) from emp group by gender</code>根据性别进行分组</p>
</li>
</ul>
</li>
<li><p><strong>排序查询</strong></p>
<ul>
<li><p><code>select 字段列表 from 表名 order by 字段1 , 排序方式1,...;</code></p>
<p>asc: 升序 (默认)	desc: 降序	</p>
<p>多字段排序时,字段1的值相同后按字段2进行排序</p>
</li>
</ul>
</li>
<li><p><strong>分页查询</strong></p>
<ul>
<li><p><code>select 字段列表 from 表名 limit 起始索引,查询记录数;</code></p>
<p>起始索引从0开始,等于(查询页码-1)*每一页返回的记录数</p>
<p>若查询第一页的数据,起始引索可以省略,直接简写为</p>
<p>查询第一页 <code>select * from emp limit 10;</code></p>
<p>查询第二页 <code>select * from emp limit 10 , 10;</code></p>
</li>
</ul>
</li>
<li><p>联表查询</p>
<ul>
<li>外连接</li>
<li>内连接</li>
</ul>
</li>
</ul>
<h1 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h1><p><strong>数据控制语言,用来管理数据库用户,控制数据库访问权限</strong></p>
<ul>
<li><p>查询用户</p>
<ul>
<li><code>use mysql;</code></li>
<li>select * from user;</li>
</ul>
</li>
<li><p>创建用户</p>
<ul>
<li><p><code>create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;;</code></p>
<p>主机名为 % 表示可以被任意主机访问</p>
</li>
</ul>
</li>
<li><p>修改用户密码</p>
<ul>
<li><code>alter user &#39;用户名&#39;@&#39;主机名&#39; identified with mysql_native_password by &#39;新密码&#39;;</code></li>
</ul>
</li>
<li><p>删除用户</p>
<ul>
<li><code>drop user &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
<li><p>权限控制</p>
<ul>
<li><p><code>all</code> 所有权限 	<code>select</code>	查询数据	<code>insert</code>	插入数据	<code>update</code>	修改数据</p>
<p><code>delete</code> 删除数据	<code>alter</code> 修改表	<code>drop</code> 删除数据库&#x2F;表&#x2F;视图	<code>create</code> 创建数据库</p>
</li>
</ul>
</li>
<li><p>查询权限</p>
<ul>
<li><code>show grants for &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
<li><p>授予权限</p>
<ul>
<li><code>grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
<li><p>撤销权限</p>
<ul>
<li><code>revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>图形化编程</title>
    <url>/2022/12/31/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="图形化编程"><a href="#图形化编程" class="headerlink" title="图形化编程"></a>图形化编程</h1><span id="more"></span>

<h2 id="java图形化包"><a href="#java图形化包" class="headerlink" title="java图形化包"></a>java图形化包</h2><ul>
<li><p>java的图像包有java.awt  和javax.swing </p>
</li>
<li><p>组件: 按钮,输入框,窗体,图片,这些组件在各语言里都已经设计好了</p>
</li>
</ul>
<p>​	<strong>java窗体类 JFrame,使用import导入需要使用的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Login</span>&#123;</span><br><span class="line">	<span class="type">JFrame</span> <span class="variable">jf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line">	jf.setSize(<span class="number">450</span>,<span class="number">550</span>);	</span><br><span class="line">	jf.setTitle(<span class="string">&quot;登录界面&quot;</span>);	</span><br><span class="line">    <span class="comment">//居中</span></span><br><span class="line">	jf.setLocationRelativeTo(<span class="literal">null</span>); </span><br><span class="line">	<span class="comment">//退出进程  查看该方法原代码查看整形参数的含义</span></span><br><span class="line">    jf.setDefaultCloseOperation(<span class="number">3</span>); </span><br><span class="line">    <span class="comment">//流式布局管理器</span></span><br><span class="line">    FlowLayout flow=<span class="keyword">new</span> <span class="title class_">FlowLayout</span>();</span><br><span class="line">    <span class="comment">//设置窗体类为流式布局</span></span><br><span class="line">    jf.setLayout(flow);</span><br><span class="line">    <span class="comment">//按钮</span></span><br><span class="line">    <span class="type">JButton</span> <span class="variable">jbu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line">    jf.add(jbu);</span><br><span class="line">    <span class="comment">//设置可见</span></span><br><span class="line">    jf.setVisible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="type">ButtonListener</span> <span class="variable">listnener1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ButtonListener</span>();</span><br><span class="line">    jbu1.addActionListener(listnener1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JFrame 窗体类</li>
<li>FlowLayout 流式布局</li>
<li>ImageIcon 图片读取</li>
<li>JLabel  标签类,用于承载图片,文字等</li>
<li>Dimension 布局类,除窗体外其他组件都需要使用该对象来设定布局</li>
<li>JButton 按钮类</li>
</ul>
<h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>监听需新建一个类,继承自带的监视器类后重写其中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="comment">//事件处理方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录中...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(Account.findAccount(Login.getUser(),Login.getPwd()))&#123;</span><br><span class="line">            showSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            showFailed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是当按钮被按下时执行的程序</p>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL函数</title>
    <url>/2023/01/02/MySQL%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><span id="more"></span>

<h2 id="一-字符串函数"><a href="#一-字符串函数" class="headerlink" title="一.字符串函数"></a>一.字符串函数</h2><ul>
<li><p><code>concat(s1,s2,...) </code>拼接字符串</p>
</li>
<li><p><code>lower(str)</code> 转换小写</p>
</li>
<li><p><code>upper(str)</code> 转换小写</p>
</li>
<li><p><code>lpad(str,n,pad)</code> 左填充,用字符串pad对str左边进行填充,达到n个字符串长度(总长度)</p>
</li>
<li><p><code>rpad(str,n,pad)</code> 左填充,用字符串pad对str右边进行填充,达到n个字符串长度(总长度)</p>
</li>
<li><p><code>trim(str)</code>去除头部和尾部的空格</p>
</li>
<li><p><code>substring(str,start,len)</code>返回从start起的len个长度的字符串</p>
</li>
</ul>
<h2 id="二-数值函数"><a href="#二-数值函数" class="headerlink" title="二.数值函数"></a>二.数值函数</h2><ul>
<li><p><code>ceil(x)</code> 向上取整</p>
</li>
<li><p><code>floor(x)</code> 向下取整</p>
</li>
<li><p><code>mod(x,y)</code> 返回x&#x2F;y的模</p>
</li>
<li><p><code>rand()</code>返回[0,1]之间的随机数</p>
</li>
<li><p><code>round(x,y)</code> 返回x四舍五入的值,保留y位小数</p>
<p>生成一个六位数的随机验证码</p>
<p><code>select lpad(round( rand()*1000000 , 0),6,&#39;0&#39;);</code></p>
</li>
</ul>
<h2 id="三-日期函数"><a href="#三-日期函数" class="headerlink" title="三.日期函数"></a>三.日期函数</h2><ul>
<li><p><code>curdate()</code>返回当前日期</p>
</li>
<li><p><code>curtime()</code>返回当前时间</p>
</li>
<li><p><code>now()</code>返回当前日期和时间</p>
</li>
<li><p><code>year(data)</code>获取指定date的年份</p>
</li>
<li><p><code>month(data)</code>获取指定data的月份</p>
</li>
<li><p><code>day(data)</code>获取指定data的日期</p>
</li>
<li><p><code>date_add(data,INTERVAL expr type)</code>返回date加上一个时间间隔expr后的时间值</p>
<p><code>select date_add(now(),INTERVAL 70 DAY);</code> 现在时间加上70天</p>
</li>
<li><p><code>datediff(date1,date2)</code>返回date1和date2之间的天数</p>
</li>
</ul>
<h2 id="四-流程函数"><a href="#四-流程函数" class="headerlink" title="四.流程函数"></a>四.流程函数</h2><ul>
<li><code>if(value,t,f)</code> value为true,返回t反之返回f</li>
<li><code>ifnull(v1,v2)</code> v1不为空返回v1,为空返回v2</li>
<li><code>case when [v1] then [res1] ... else [default] end</code>若v1为true,返回res1,…否则返回default</li>
<li><code>case [expr] when [v1] then [res1] ... else [default] end</code> 若expr等于v1,返回res1,….否则返回default</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2023/01/03/%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><span id="more"></span>

<p>格式: <code>interface 接口名 &#123;&#125;</code></p>
<ul>
<li>接口中的变量默认以 statci final 修饰,必须初始化赋值</li>
<li>接口中可以定义抽象方法,静态方法和默认方法</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ol>
<li>创建一个类 实现 接口(继承接口) ,一个类可以实现多个接口但只能继承一个类</li>
<li>类中必须重写接口中的所有抽象方法</li>
<li>类中可以直接使用 接口中的变量,静态方法和默认方法</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">openDoor</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现 接口Lock</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">leyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key 正确,开门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key 正确,关门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">calss Mange&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Door door= <span class="keyword">new</span> <span class="title class_">Door</span>();</span><br><span class="line">        keyLock keylock=<span class="keyword">new</span> <span class="title class_">keyLock</span>();</span><br><span class="line">        door.lock() = keylock; <span class="comment">//传入接口</span></span><br><span class="line">        </span><br><span class="line">        door.open();</span><br><span class="line">        door.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要对锁进行升级或修改,对实现锁这个接口的类进行修改或再次创建一个类对锁进行实现,然后传入接口就可以了,避免了对门和锁的源码进行修改</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li><p>抽象类： </p>
<ul>
<li>定义抽象方法</li>
<li>定义普通方法</li>
</ul>
</li>
<li><p>接口 &gt; 抽象类 &gt; 类： </p>
</li>
<li><p>设计 &gt; 半成品 &gt; 成品 </p>
</li>
<li><p>依赖不能导致： </p>
<ul>
<li>抽象类可以继承非抽象类,但不要这么做</li>
</ul>
</li>
<li><p>只要是抽象的都不可以实例化对象</p>
</li>
</ul>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>约束</title>
    <url>/2023/01/03/MySQL%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><table>
<thead>
<tr>
<th>主键约束</th>
<th>约束数据库中每条记录唯一</th>
<th>primary key</th>
</tr>
</thead>
<tbody><tr>
<td>唯一约束</td>
<td>约束数据内容唯一</td>
<td>unique</td>
</tr>
<tr>
<td>外键约束</td>
<td>表之间引用完整</td>
<td>foreign key</td>
</tr>
<tr>
<td>非空约束</td>
<td>使该字段值不为空</td>
<td>not null</td>
</tr>
<tr>
<td>检查约束</td>
<td>限制值的范围</td>
<td>check(条件)</td>
</tr>
<tr>
<td>默认约束</td>
<td>默认值</td>
<td>default</td>
</tr>
<tr>
<td>自增约束</td>
<td>未指定值时按上一条数据的值加一</td>
<td>auto_increment</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>使两张表建立联系,保证数据的一致性和完整性</p>
<p>具有外键的表成为子表,子表关联的表称为父表(主表)</p>
<ul>
<li><p>添加外键</p>
<ul>
<li><p><code>alter table 表名 add constraint [外键名称] foreign key(外键字段名) references 主表(主表列表名)</code></p>
</li>
<li><p><code>alter table storage add constraint foreign key(ID) references oil(ID);</code></p>
</li>
<li><pre><code class="sql">create table 表名(
    字段名 数据类型,
    ...
    [constraint] [外键名称] foreign key(外键字段名) references 主表(主表列表名)
);
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="删除更新外键"><a href="#删除更新外键" class="headerlink" title="删除更新外键"></a>删除更新外键</h2><ul>
<li><code>no action</code> <code>restrict</code> 父表中删除或更新时,若子表有关联数据则不允许操作</li>
<li><code>cascade</code> 父表中进行删除更新时,若有外键则对外键同步进行删除或更新</li>
<li><code>set null</code>父表中进行删除或更新时,若有外键,则把外键设置为null</li>
<li><code>set default</code>父表中进行删除或更新时,将外键设置为一个默认值</li>
</ul>
<p>​	设置约束条件需要在创建时设置,不能在后续修改,若要修改,要先删除原有的约束再创建新的约束</p>
<p><code>alter table 表名 add constraint 外键名称 foreign key(外键字段) references 主表名(主表字段名) on update 关键字 on delete 关键字;</code></p>
<h1 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h1><ul>
<li>表外添加 <code>alter table 表名 add primary key (字段名);</code></li>
<li>撤销 <code>alter table 表名 drop primary key;</code></li>
</ul>
<h1 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h1><p>添加方式与主键约束相似</p>
<h1 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h1><p>添加方式与主键约束相送</p>
<h1 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h1><ul>
<li>表外添加 <code>alter table 表名 add 字段名 default 默认值</code></li>
<li>撤销 <code>drop defautl</code></li>
</ul>
<h1 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h1><ul>
<li>表外添加 <code>alter table 表名 add 字段名 check(条件列表)</code><ul>
<li>检查约束会约束 值必须使条件列表为真</li>
</ul>
</li>
<li>撤销 <code>drop check 字段名</code></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>五子棋</title>
    <url>/2023/01/07/%E4%BA%94%E5%AD%90%E6%A3%8B/</url>
    <content><![CDATA[<h1 id="java实现五子棋"><a href="#java实现五子棋" class="headerlink" title="java实现五子棋"></a>java实现五子棋</h1><span id="more"></span>

<h2 id="一-结构"><a href="#一-结构" class="headerlink" title="一.结构"></a>一.结构</h2><p>通过图形化编程,实现在15*15的棋盘上进行五子棋游戏,含有悔棋,录制和逐步回放功能,实现以上各功能的类和接口如下</p>
<ol>
<li>GoBangUI  </li>
<li>GoListener</li>
<li>GoData</li>
<li>StartButtonListener</li>
<li>RepetanceButtonListener</li>
<li>EndButtonListener</li>
<li>PlayBackListener</li>
<li>PlayBackUI</li>
<li>NextListener</li>
<li>LastListener</li>
</ol>
<!--more-->

<h2 id="二-功能实现"><a href="#二-功能实现" class="headerlink" title="二.功能实现"></a>二.功能实现</h2><h3 id="1-GoBangUI"><a href="#1-GoBangUI" class="headerlink" title="1.GoBangUI"></a>1.GoBangUI</h3><p> 构建游戏窗口,容纳棋盘,棋子和各按钮,继承<code>JFrame</code>类</p>
<p>在构造函数中绘制棋盘,使用空布局设定”开始游戏”按钮,”悔棋”按钮,”结束游戏”按钮和”回放”按钮的位置,并为各按钮设置监听器</p>
<p>重写<code>JFrame</code>类中的<code>paint()</code>方法,使窗口改变布局时重新显示按钮,棋盘和棋子,其中棋子的数据存放在<code>GoData</code>接口中</p>
<p>在该类中定义静态<code>GoBangUI</code> 对象 ui,以便于在悔棋和结束游戏时在监听器中调用ui对象来进行重新绘制</p>
<p>在该类中定义程序入口,执行<code>ui=new GoBangUI();</code></p>
<p>完整代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoBangUI</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> <span class="keyword">implements</span> <span class="title class_">GoData</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> GoBangUI ui;</span><br><span class="line">    <span class="type">GoListener</span> <span class="variable">gl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoListener</span>();</span><br><span class="line">    <span class="keyword">static</span> JButton start=<span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> JButton repentance=<span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> JButton end=<span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> JButton playBack=<span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> EndButtonListener endListener=<span class="keyword">new</span> <span class="title class_">EndButtonListener</span>();</span><br><span class="line">    <span class="keyword">static</span> RepetanceButtonListener repentanceListener=<span class="keyword">new</span> <span class="title class_">RepetanceButtonListener</span>();</span><br><span class="line">    <span class="keyword">static</span> StartButtonListener startListener=<span class="keyword">new</span> <span class="title class_">StartButtonListener</span>();</span><br><span class="line">    <span class="keyword">static</span> PlayBackListener playBackListener=<span class="keyword">new</span> <span class="title class_">PlayBackListener</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GoBangUI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//初始化棋盘数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ROW;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;COL;++j)&#123;</span><br><span class="line">                Data[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setTitle(<span class="string">&quot;五子棋&quot;</span>);</span><br><span class="line">        setSize(<span class="number">700</span>,<span class="number">750</span>);</span><br><span class="line">        setDefaultCloseOperation(EXIT_ON_CLOSE);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setLayout(<span class="literal">null</span>);</span><br><span class="line">        addMouseListener(gl);</span><br><span class="line">        gl.g=getGraphics(); <span class="comment">//传递了一个引用?</span></span><br><span class="line">        <span class="comment">//开始按钮</span></span><br><span class="line">        start.addActionListener(startListener);</span><br><span class="line">        start.setText(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">        <span class="comment">//Dimension startDimension=new Dimension();</span></span><br><span class="line">        <span class="comment">//startDimension.setSize(80,30);</span></span><br><span class="line">        <span class="comment">//start.setPreferredSize(startDimension);</span></span><br><span class="line">        start.setBounds(<span class="number">100</span>,<span class="number">10</span>,<span class="number">120</span>,<span class="number">30</span>);</span><br><span class="line">        add(start);</span><br><span class="line">        <span class="comment">//悔棋按钮</span></span><br><span class="line">        repentance.addActionListener(repentanceListener);</span><br><span class="line">        repentance.setText(<span class="string">&quot;悔棋&quot;</span>);</span><br><span class="line">        repentance.setBounds(<span class="number">250</span>,<span class="number">10</span>,<span class="number">120</span>,<span class="number">30</span>);</span><br><span class="line">        add(repentance);</span><br><span class="line">        <span class="comment">//结束按钮</span></span><br><span class="line">        end.addActionListener(endListener);</span><br><span class="line">        end.setText(<span class="string">&quot;结束游戏&quot;</span>);</span><br><span class="line">        end.setBounds(<span class="number">400</span>,<span class="number">10</span>,<span class="number">120</span>,<span class="number">30</span>);</span><br><span class="line">        add(end);</span><br><span class="line">        <span class="comment">//回放按钮</span></span><br><span class="line">        playBack.addActionListener(playBackListener);</span><br><span class="line">        playBack.setText(<span class="string">&quot;回放&quot;</span>);</span><br><span class="line">        playBack.setBounds(<span class="number">550</span>,<span class="number">10</span>,<span class="number">120</span>,<span class="number">30</span>);</span><br><span class="line">        add(playBack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span>&#123;</span><br><span class="line">        start.repaint();</span><br><span class="line">        repentance.repaint();</span><br><span class="line">        end.repaint();</span><br><span class="line">        playBack.repaint();</span><br><span class="line">        <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">79</span>, <span class="number">227</span>, <span class="number">165</span>);</span><br><span class="line">        g.setColor(color);</span><br><span class="line">        g.fillRect(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight());</span><br><span class="line">        g.setColor(Color.BLACK);</span><br><span class="line">        <span class="comment">//绘制棋盘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ROW;++i)&#123;</span><br><span class="line">            g.drawLine(X,Y+i*SIZE,X+(ROW-<span class="number">1</span>)*SIZE,Y+i*SIZE);</span><br><span class="line">            g.drawLine(X+i*SIZE,Y,X+i*SIZE,Y+(COL-<span class="number">1</span>)*SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复棋盘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ROW;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;COL;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Data[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    g.setColor(Color.black);</span><br><span class="line">                    g.fillOval(X+i*SIZE-SIZE/<span class="number">2</span>,Y+j*SIZE-SIZE/<span class="number">2</span>,SIZE,SIZE);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Data[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                    g.setColor(Color.white);</span><br><span class="line">                    g.fillOval(X+i*SIZE-SIZE/<span class="number">2</span>,Y+j*SIZE-SIZE/<span class="number">2</span>,SIZE,SIZE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ui = <span class="keyword">new</span> <span class="title class_">GoBangUI</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-GoListener"><a href="#2-GoListener" class="headerlink" title="2.GoListener"></a>2.GoListener</h3><p>​	该类实现MouseListener接口,对鼠标进行监听,当按下重写mousePressed方法,当按下鼠标时获取鼠标指针的位置,根据位置判断出该棋子的行数和列数,将其显示在棋盘上并存储在GoData中的Data二维数组中记录棋子信息,还存储在双向队列 Rows和Cols中,用于录制该棋局的每一步操作用于回放.</p>
<p>​	在该类中实现isEnd(int r,int c)方法,用于判断是否出现五个相同的棋子连在一起的情况,判断输赢</p>
<p>​	完整代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoListener</span> <span class="keyword">implements</span> <span class="title class_">MouseListener</span>, GoData &#123;</span><br><span class="line">    Graphics g;</span><br><span class="line">    <span class="comment">//黑子先走</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">chessFlag</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//0:不能下棋,1:黑棋,2:白棋</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEnd</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> r;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> c;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] x = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] y = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; ) &#123;</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            row = r + x[i];</span><br><span class="line">            col = c + y[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row &gt;= ROW || row &lt; <span class="number">0</span> || col &gt;= COL || col &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Data[row][col] == Data[r][c]) &#123;</span><br><span class="line">                    sum += <span class="number">1</span>;</span><br><span class="line">                    row += x[i];</span><br><span class="line">                    col += y[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            row = r + x[i + <span class="number">1</span>];</span><br><span class="line">            col = c + y[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row &gt;= ROW || row &lt; <span class="number">0</span> || col &gt;= COL || col &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Data[row][col] == Data[r][c]) &#123;</span><br><span class="line">                    sum += <span class="number">1</span>;</span><br><span class="line">                    row += x[i + <span class="number">1</span>];</span><br><span class="line">                    col += y[i + <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum &gt;= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent event)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> event.getX();</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> event.getY();</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算x,y坐标对应的行列</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= X) &#123;</span><br><span class="line">            row = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= ROW * SIZE + X) &#123;</span><br><span class="line">            row = ROW - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row = ((x - X) / SIZE) + ((x - X) % SIZE &gt; SIZE / <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= Y) &#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y &gt;= COL * SIZE + Y) &#123;</span><br><span class="line">            col = COL - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            col = ((y - Y) / SIZE) + ((y - Y) % SIZE &gt; SIZE / <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chessFlag == <span class="number">0</span>) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;请先开始游戏&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该位置没有棋子</span></span><br><span class="line">        <span class="keyword">if</span> (Data[row][col] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//录制棋局</span></span><br><span class="line">            Rows.addLast(row);</span><br><span class="line">            Cols.addLast(col);</span><br><span class="line">            <span class="keyword">if</span> (chessFlag == <span class="number">1</span>) &#123;</span><br><span class="line">                Data[row][col] = chessFlag;</span><br><span class="line">                g.setColor(Color.black);</span><br><span class="line">                g.fillOval(X + row * SIZE - SIZE / <span class="number">2</span>, Y + col * SIZE - SIZE / <span class="number">2</span>, SIZE, SIZE);</span><br><span class="line">                <span class="keyword">if</span> (isEnd(row, col)) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;黑子获胜&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                chessFlag = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chessFlag == <span class="number">2</span>) &#123;</span><br><span class="line">                Data[row][col] = chessFlag;</span><br><span class="line">                g.setColor(Color.white);</span><br><span class="line">                g.fillOval(X + row * SIZE - SIZE / <span class="number">2</span>, Y + col * SIZE - SIZE / <span class="number">2</span>, SIZE, SIZE);</span><br><span class="line">                <span class="keyword">if</span> (isEnd(row, col)) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;白子获胜&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                chessFlag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent event)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseReleased</span><span class="params">(MouseEvent event)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseEntered</span><span class="params">(MouseEvent event)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseExited</span><span class="params">(MouseEvent event)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-GoData"><a href="#3-GoData" class="headerlink" title="3.GoData"></a>3.GoData</h3><p>该接口用于设置棋盘的行列数,间距,棋盘左上角坐标以及存储当局棋子信息和回放棋子信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GoData</span> &#123;</span><br><span class="line">    <span class="type">int</span> X=<span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> Y=<span class="number">110</span>;</span><br><span class="line">    <span class="type">int</span> SIZE=<span class="number">40</span>;</span><br><span class="line">    <span class="type">int</span> ROW=<span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> COL=<span class="number">15</span>;</span><br><span class="line">    <span class="comment">//List&lt;Integer&gt; rows=new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">    <span class="comment">//List&lt;Integer&gt; cols=new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">    Deque&lt;Integer&gt; Rows=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; Cols=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">int</span>[][] Data=<span class="keyword">new</span> <span class="title class_">int</span>[ROW+<span class="number">1</span>][COL+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[][] PlayBackData=<span class="keyword">new</span> <span class="title class_">int</span>[ROW+<span class="number">1</span>][COL+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-StartButtonListener"><a href="#4-StartButtonListener" class="headerlink" title="4.StartButtonListener"></a>4.StartButtonListener</h3><p>用于监听开始按钮,按下开始按钮后设置<code>chessFlag</code>&#x3D;1,即黑子先走,并情况上一局的回放信息以记录本局的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>,GoData &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(GoListener.chessFlag!=<span class="number">0</span>)&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;游戏已经开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//黑子先走</span></span><br><span class="line">        PlayBackUI.round+=<span class="number">1</span>;</span><br><span class="line">        GoListener.chessFlag=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//清空回放记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ROW;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;COL;++j)&#123;</span><br><span class="line">                PlayBackData[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PlayBackUI.cur=<span class="number">0</span>;</span><br><span class="line">        GoData.Rows.clear();</span><br><span class="line">        GoData.Cols.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-RepetanceButtonListener"><a href="#5-RepetanceButtonListener" class="headerlink" title="5.RepetanceButtonListener"></a>5.RepetanceButtonListener</h3><p>监听悔棋按钮,当按下悔棋按钮后通过Rows和Cols获取上一步的信息,将其从棋局中和录制信息中删去,并通过GoBangUI.ui调用paint刷新棋盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepetanceButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>, GoData &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//获取最后一步</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> Rows.getLast();</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> Cols.getLast();</span><br><span class="line">        <span class="comment">//清除最后一步</span></span><br><span class="line">        Data[row][col] = <span class="number">0</span>;</span><br><span class="line">        GoListener.chessFlag=GoListener.chessFlag==<span class="number">1</span>?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">        Rows.removeLast();</span><br><span class="line">        Cols.removeLast();</span><br><span class="line">        <span class="comment">//重新绘制棋盘</span></span><br><span class="line">        GoBangUI.ui.paint(GoBangUI.ui.getGraphics());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-EndButtonListener"><a href="#6-EndButtonListener" class="headerlink" title="6.EndButtonListener"></a>6.EndButtonListener</h3><p>监听结束游戏按钮,当按下结束游戏按钮后清空棋盘,设置chessFlag&#x3D;0等待下局游戏开始,并刷新棋盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>,GoData&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//清空棋盘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ROW;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;COL;++j)&#123;</span><br><span class="line">                Data[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        GoListener.chessFlag=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//重新绘制棋盘</span></span><br><span class="line">        GoBangUI.ui.paint(GoBangUI.ui.getGraphics());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-PlayBackListener"><a href="#7-PlayBackListener" class="headerlink" title="7.PlayBackListener"></a>7.PlayBackListener</h3><p>监听回放按钮,当按下回放按钮后创建<code>PlayBackUI</code>对象并将总步数传递给<code>PlayBackUI</code>中的静态变量<code>sum</code>,用于判断回放时是否还有下一步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayBackListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        PlayBackUI.sum=GoData.Rows.size();</span><br><span class="line">        PlayBackUI.ui= <span class="keyword">new</span> <span class="title class_">PlayBackUI</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-PlayBackUI"><a href="#8-PlayBackUI" class="headerlink" title="8.PlayBackUI"></a>8.PlayBackUI</h3><p>回放棋局的窗口,含有上一步按钮和下一步按钮,通过点击按钮来操作回放,创建静态<code>PlayBackUI</code>对象<code>ui</code>用于在监听器中刷新界面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayBackUI</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> <span class="keyword">implements</span> <span class="title class_">GoData</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">round</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//总步数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Rows.size();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//当前步数</span></span><br><span class="line">    <span class="keyword">static</span> PlayBackUI ui;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">JButton</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">JButton</span> <span class="variable">last</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">NextListener</span> <span class="variable">nextListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NextListener</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">LastListener</span> <span class="variable">lastListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LastListener</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PlayBackUI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化棋盘数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">                Data[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setTitle(<span class="string">&quot;回放&quot;</span>);</span><br><span class="line">        setSize(<span class="number">700</span>, <span class="number">750</span>);</span><br><span class="line">        setDefaultCloseOperation(DISPOSE_ON_CLOSE);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setLayout(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//下一步按钮</span></span><br><span class="line">        <span class="keyword">if</span>(round==<span class="number">1</span>) &#123;</span><br><span class="line">            next.addActionListener(nextListener);</span><br><span class="line">            last.addActionListener(lastListener);</span><br><span class="line">        &#125;</span><br><span class="line">        next.setText(<span class="string">&quot;下一步&quot;</span>);</span><br><span class="line">        next.setBounds(<span class="number">400</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">        add(next);</span><br><span class="line">        <span class="comment">//上一步按钮</span></span><br><span class="line">        last.setText(<span class="string">&quot;上一步&quot;</span>);</span><br><span class="line">        last.setBounds(<span class="number">200</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">        add(last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">                PlayBackData[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">        next.repaint();</span><br><span class="line">        last.repaint();</span><br><span class="line">        <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">79</span>, <span class="number">227</span>, <span class="number">165</span>);</span><br><span class="line">        g.setColor(color);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">        g.setColor(Color.BLACK);</span><br><span class="line">        <span class="comment">//绘制棋盘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">            g.drawLine(X, Y + i * SIZE, X + (ROW - <span class="number">1</span>) * SIZE, Y + i * SIZE);</span><br><span class="line">            g.drawLine(X + i * SIZE, Y, X + i * SIZE, Y + (COL - <span class="number">1</span>) * SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复棋盘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ROW; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; COL; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (PlayBackData[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    g.setColor(Color.black);</span><br><span class="line">                    g.fillOval(X + i * SIZE - SIZE / <span class="number">2</span>, Y + j * SIZE - SIZE / <span class="number">2</span>, SIZE, SIZE);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PlayBackData[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    g.setColor(Color.white);</span><br><span class="line">                    g.fillOval(X + i * SIZE - SIZE / <span class="number">2</span>, Y + j * SIZE - SIZE / <span class="number">2</span>, SIZE, SIZE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-NextListener"><a href="#9-NextListener" class="headerlink" title="9.NextListener"></a>9.NextListener</h3><p>监听回放窗口中的下一步按钮,按下按钮后先判断是否还有下一步,然后通过<code>GoData</code>中的<code>Rows</code>和<code>Cols</code>获取下一步棋的位置信息,将其绘制在棋盘中</p>
<p>将双向队列的队头出队后从队尾入队,使在执行上一步操作时获取上一步棋的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NextListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>,GoData&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//获取下一步并录入到回放棋盘中</span></span><br><span class="line">        <span class="keyword">if</span>(PlayBackUI.cur&lt;PlayBackUI.sum)&#123;</span><br><span class="line">            <span class="type">int</span> row=Rows.getFirst();</span><br><span class="line">            <span class="type">int</span> col=Cols.getFirst();</span><br><span class="line">            Rows.addLast(row);</span><br><span class="line">            Cols.addLast(col);</span><br><span class="line">            Rows.removeFirst();</span><br><span class="line">            Cols.removeFirst();</span><br><span class="line">            PlayBackData[row][col]=(PlayBackUI.cur%<span class="number">2</span>)==<span class="number">0</span>?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">            PlayBackUI.cur+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;没有下一步了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PlayBackUI.ui.paint(PlayBackUI.ui.getGraphics());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-LastListener"><a href="#10-LastListener" class="headerlink" title="10.LastListener"></a>10.LastListener</h3><p>监听回放窗口中的上一步按钮,按下按钮后先判断是否还有上一步,然后通过<code>GoData</code>中的<code>Rows</code>和<code>Cols</code>获取上一步棋的位置信息,将其绘制在棋盘中</p>
<p>将双向队列的队尾出队后从队头入队,使在执行下一步操作时获取下一步棋的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LastListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>,GoData&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//获取下一步并录入到回放棋盘中</span></span><br><span class="line">        <span class="keyword">if</span>(PlayBackUI.cur&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> row=Rows.getLast();</span><br><span class="line">            <span class="type">int</span> col=Cols.getLast();</span><br><span class="line">            Rows.removeLast();</span><br><span class="line">            Cols.removeLast();</span><br><span class="line">            Rows.addFirst(row);</span><br><span class="line">            Cols.addFirst(col);</span><br><span class="line">            PlayBackData[row][col]=<span class="number">0</span>;</span><br><span class="line">            PlayBackUI.cur-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;没有上一步了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PlayBackUI.ui.paint(PlayBackUI.ui.getGraphics());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>hello 2023</title>
    <url>/2023/01/10/hello-2023/</url>
    <content><![CDATA[<h1 id="C-Least-Prefix-Sum"><a href="#C-Least-Prefix-Sum" class="headerlink" title="C     Least Prefix Sum"></a>C     Least Prefix Sum</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题:"></a>原题:</h2><p><a href="https://codeforces.com/contest/1779/problem/C"><strong>Least Prefix Sum</strong></a></p>
<span id="more"></span>

<blockquote>
<p>Baltic, a famous chess player who is also a mathematician, has an array a1,a2,…,ana1,a2,…,an, and he can perform the following operation several (possibly 00) times:</p>
<ul>
<li>Choose some index ii (1≤i≤n1≤i≤n);</li>
<li>multiply aiai with −1−1, that is, set ai:&#x3D;−aiai:&#x3D;−ai.</li>
</ul>
<p>Baltic’s favorite number is mm, and he wants a1+a2+⋯+ama1+a2+⋯+am to be the smallest of all non-empty prefix sums. More formally, for each k&#x3D;1,2,…,nk&#x3D;1,2,…,n it should hold that</p>
<p>a1+a2+⋯+ak≥a1+a2+⋯+am.a1+a2+⋯+ak≥a1+a2+⋯+am.</p>
<p>Please note that multiple smallest prefix sums may exist and that it is only required that a1+a2+⋯+ama1+a2+⋯+am is one of them.</p>
<p>Help Baltic find the minimum number of operations required to make a1+a2+⋯+ama1+a2+⋯+am the least of all prefix sums. It can be shown that a valid sequence of operations always exists.</p>
<p>Input</p>
<p>Each test contains multiple test cases. The first line contains the number of test cases tt (1≤t≤100001≤t≤10000). The description of the test cases follows.</p>
<p>The first line of each test case contains two integers nn and mm (1≤m≤n≤2⋅1051≤m≤n≤2⋅105) — the size of Baltic’s array and his favorite number.</p>
<p>The second line contains nn integers a1,a2,…,ana1,a2,…,an (−109≤ai≤109−109≤ai≤109) — the array.</p>
<p>It is guaranteed that the sum of nn over all test cases does not exceed 2⋅1052⋅105.</p>
<p>Output</p>
<p>For each test case, print a single integer — the minimum number of required operations.</p>
</blockquote>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>进行res次操作 ai&#x3D;-ai,使得给出的数列和一个下标m</p>
<p>得到使数列和Sm的值小于或等于其他所有数列和Si(1&lt;&#x3D;i&lt;&#x3D;长度),求最小操作次数</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要使Sm的值小于等于其它数列和</p>
<p>当下标大于m时,am+1…ai(m+1&lt;&#x3D;i&lt;&#x3D;n)的值全部都要小于等于零,使得Sm加上后面的数之后的值都小于等于Sm以满足限制</p>
<p>当下标小于等于m时,am,am-1…a1(1&lt;i**&lt;&#x3D;<strong>m)的值全部都要大于等于零,使得Sm减去以am起始的下标递减的数列和时得到的Si(1&lt;&#x3D;i</strong>&lt;**m)全部小于等于Sm,以满足限制.</p>
<p>向前判断时不能把a1加入判断,因为判断完Sm-a1的值大于等于0后,S1&#x3D;a1&#x3D;Sm-(Sm-a1)已满足限制,若再次判断a1,会使限制增加导致结果错误</p>
<p>使用大根堆来选取向前时的最大值和向后时的最大值,时操作次数最小</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t, n, m,res,min;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">200001</span>];</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">		priority_queue&lt;<span class="type">int</span>&gt; pre, pos;</span><br><span class="line">		cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line">		m = m - <span class="number">1</span>;</span><br><span class="line">		sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			cin &gt;&gt; arr[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;<span class="number">0</span> ; --j) &#123;<span class="comment">//为什么大于0而不是大于等于0</span></span><br><span class="line">			<span class="comment">//因为往前时要保证大于零使Sm小于Sa,即m向前m-a个数的和大于0,不包括a,即结束时不应包括第1个,否则增多了限制使结果出错</span></span><br><span class="line">			sum += arr[j];</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; <span class="number">0</span>) pre.<span class="built_in">push</span>(<span class="number">2</span> * arr[j]);</span><br><span class="line">			<span class="keyword">while</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				sum -= pre.<span class="built_in">top</span>();</span><br><span class="line">				pre.<span class="built_in">pop</span>();</span><br><span class="line">				res++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			sum += arr[j];</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; <span class="number">0</span>) pos.<span class="built_in">push</span>(<span class="number">-2</span> * arr[j]);</span><br><span class="line">			<span class="keyword">while</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				sum += pos.<span class="built_in">top</span>();</span><br><span class="line">				pos.<span class="built_in">pop</span>();</span><br><span class="line">				res += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Boris-and-His-Amazing-Haircut"><a href="#D-Boris-and-His-Amazing-Haircut" class="headerlink" title="D Boris and His Amazing Haircut"></a>D Boris and His Amazing Haircut</h1><p><strong><a href="https://codeforces.com/contest/1779/problem/D">Boris and His Amazing Haircut</a></strong></p>
<h2 id="原题-1"><a href="#原题-1" class="headerlink" title="原题"></a>原题</h2><blockquote>
<p>Boris thinks that chess is a tedious game. So he left his tournament early and went to a barber shop as his hair was a <em>bit</em> messy.</p>
<p>His current hair can be described by an array a1,a2,…,ana1,a2,…,an, where aiai is the height of the hair standing at position ii. His desired haircut can be described by an array b1,b2,…,bnb1,b2,…,bn in a similar fashion.</p>
<p>The barber has mm razors. Each has its own size and can be used <strong>at most</strong> once. In one operation, he chooses a razor and cuts a segment of Boris’s hair. More formally, an operation is:</p>
<ul>
<li>Choose any razor which hasn’t been used before, let its size be xx;</li>
<li>Choose a segment [l,r][l,r] (1≤l≤r≤n1≤l≤r≤n);</li>
<li>Set ai:&#x3D;min(ai,x)ai:&#x3D;min(ai,x) for each l≤i≤rl≤i≤r;</li>
</ul>
<p>Notice that some razors might have equal sizes — the barber can choose some size xx only as many times as the number of razors with size xx.</p>
<p>He may perform as many operations as he wants, as long as any razor is used at most once and ai&#x3D;biai&#x3D;bi for each 1≤i≤n1≤i≤n at the end. He <strong>does not</strong> have to use all razors.</p>
<p>Can you determine whether the barber can give Boris his desired haircut?</p>
<p>Input</p>
<p>Each test contains multiple test cases. The first line contains the number of test cases tt (1≤t≤200001≤t≤20000). The description of the test cases follows.</p>
<p>The first line of each test case contains a positive integer nn (3≤n≤2⋅1053≤n≤2⋅105) — the length of arrays aa and bb.</p>
<p>The second line of each test case contains nn positive integers a1,a2,…,ana1,a2,…,an (1≤ai≤1091≤ai≤109)  — Boris’s current hair.</p>
<p>The third line of each test case contains nn positive integers b1,b2,…,bnb1,b2,…,bn (1≤bi≤1091≤bi≤109)  — Boris’s desired hair.</p>
<p>The fourth line of each test case contains a positive integer mm (1≤m≤2⋅1051≤m≤2⋅105)  — the number of razors.</p>
<p>The fifth line of each test case contains mm positive integers x1,x2,…,xmx1,x2,…,xm (1≤xi≤1091≤xi≤109)  — the sizes of the razors.</p>
<p>It is guaranteed that the sum of nn and the sum of mm over all test cases do not exceed 2⋅1052⋅105.</p>
<p>Output</p>
<p>For each test case, print “YES” if the barber can cut Boris’s hair as desired. Otherwise, print “NO”.</p>
<p>You can output the answer in any case (upper or lower). For example, the strings “yEs”, “yes”, “Yes”, and “YES” will be recognized as positive responses.</p>
</blockquote>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>如果头发比要求的还要短,直接输出”NO”</p>
<p>使用单调栈遍历目标数组,使用哈希表存储各推子的数数量,当栈不为空且栈的头元素小于遍历到的目标元素时不断出栈,当栈为空或栈顶元素不等于遍历到的元素且相应元素需要改变时,将该元素入栈,如果没有正确的推子剩余则输出”NO”,若有剩余则推子数减一</p>
<p>通过遍历所有元素,即可判断是否可以满足条件</p>
<p>因为如果头发的长度比上一个头发小,那么该头发必须消耗相应的推子,遇到长度大于上一个头发的时候,不断出栈直到栈顶不小于该头发,若该两头发值相等,则不需要再消耗推子,若不一样,则需要消耗相应推子,需要使用推子时推子数量需要大于0</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t, n, m,i,j,in,res;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">200001</span>], b[<span class="number">200001</span>];</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mapp;</span><br><span class="line">		stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			cin &gt;&gt; a[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			cin &gt;&gt; b[j];</span><br><span class="line">		&#125;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">			cin &gt;&gt; in;</span><br><span class="line">			mapp[in] += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		res = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; b[j]) &#123;</span><br><span class="line">				res = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() &lt; b[j]) &#123; stk.<span class="built_in">pop</span>(); &#125;</span><br><span class="line">			<span class="keyword">if</span> ((stk.<span class="built_in">empty</span>() || (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() != b[j])) &amp;&amp; a[j] &gt; b[j]) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(b[j]);</span><br><span class="line">				<span class="keyword">if</span> (mapp[b[j]] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					res = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				mapp[b[j]] -= <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (res) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Anya’s-Simultaneous-Exhibition"><a href="#E-Anya’s-Simultaneous-Exhibition" class="headerlink" title="E Anya’s Simultaneous Exhibition"></a>E Anya’s Simultaneous Exhibition</h1>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D脚本应用</title>
    <url>/2023/01/13/Unity3D%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<ol>
<li>场景</li>
<li>异步加载场景</li>
<li>Transform</li>
<li>键鼠监听</li>
<li>虚拟轴</li>
<li>触摸监听</li>
<li>灯光</li>
<li>摄像机</li>
<li>声音</li>
<li>视频</li>
</ol>
<span id="more"></span>

<h1 id="1-场景"><a href="#1-场景" class="headerlink" title="1.场景"></a>1.场景</h1><p>不同场景含有不同物体 </p>
<h3 id="场景类-Scene"><a href="#场景类-Scene" class="headerlink" title="场景类: Scene"></a>场景类: Scene</h3><ul>
<li><p>场景跳转</p>
<ul>
<li>导入UnityEngine.SceneManagement </li>
<li>SceneManager.LoadScene()通过索引或名称加载目标场景</li>
</ul>
</li>
<li><p>获取当前场景 Scene s&#x3D;SceneManager.GetActiveScene()</p>
</li>
<li><p>场景是否已被加载 scene.isLoaded</p>
</li>
</ul>
<h3 id="场景管理类-SceneManager"><a href="#场景管理类-SceneManager" class="headerlink" title="场景管理类 SceneManager"></a>场景管理类 SceneManager</h3><ul>
<li>创建场景 CreateScene(场景名)</li>
<li>卸载场景 UnloadScene()</li>
<li>加载场景 LoadScene()</li>
<li>异步加载场景 LoadSceneAsync()</li>
</ul>
<h1 id="2-异步加载场景"><a href="#2-异步加载场景" class="headerlink" title="2.异步加载场景"></a>2.异步加载场景</h1><p>创建一个协程方法,用来异步加载场景,返回值必须是IEnumerator</p>
<ul>
<li>StartCoroutine(loadScene()); 用来调用自己写的协程方法 loadScene</li>
<li>获取加载进度</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/13/JanedLxI2mXCu4c.png" alt="BY__32S6_F_GYDTN_EAJH_S.png"></p>
<h1 id="3-Transform"><a href="#3-Transform" class="headerlink" title="3.Transform"></a>3.Transform</h1><ul>
<li><p>通过Transform控制物体姿态</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TransFormTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取位置</span></span><br><span class="line">        Debug.Log(transform.position); <span class="comment">//绝对位置</span></span><br><span class="line">        Debug.Log(transform.localPosition); <span class="comment">//相对于父物体的位置</span></span><br><span class="line">        <span class="comment">//获取旋转</span></span><br><span class="line">        Debug.Log(transform.rotation);  <span class="comment">//四元数</span></span><br><span class="line">        Debug.Log(transform.localRotation);</span><br><span class="line">        Debug.Log(transform.eulerAngles);   <span class="comment">//欧拉角</span></span><br><span class="line">        Debug.Log(transform.localEulerAngles);</span><br><span class="line">        <span class="comment">//获取缩放</span></span><br><span class="line">        Debug.Log(transform.localScale);</span><br><span class="line">        <span class="comment">//向量</span></span><br><span class="line">        Debug.Log(transform.forward);</span><br><span class="line">        Debug.Log(transform.right); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一直朝向原点</span></span><br><span class="line">        transform.LookAt(Vector3.zero);</span><br><span class="line">        <span class="comment">//旋转</span></span><br><span class="line">        transform.Rotate(Vector3.up,<span class="number">1</span>); <span class="comment">//沿up方向,每一帧旋转1度</span></span><br><span class="line">        <span class="comment">//绕某个物体旋转</span></span><br><span class="line">        transform.RotateAround(Vector3.zero, Vector3.up, <span class="number">1</span>); <span class="comment">//沿原点up方向每一帧旋转1度</span></span><br><span class="line">        <span class="comment">//移动</span></span><br><span class="line">        transform.Translate(Vector3.forward*<span class="number">0.1f</span>); <span class="comment">//朝前方每一帧移动0.1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Transform控制父子关系</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父子关系</span></span><br><span class="line">        <span class="comment">//获取父物体</span></span><br><span class="line">        Debug.Log(transform.parent.gameObject);</span><br><span class="line">        <span class="comment">//子物体个数</span></span><br><span class="line">        Debug.Log(transform.childCount);</span><br><span class="line">        <span class="comment">//解除所有子物体</span></span><br><span class="line">        transform.DetachChildren();</span><br><span class="line">        <span class="comment">//获取子物体</span></span><br><span class="line">        Transform tanns = transform.Find(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">        Transform tans = transform.GetChild(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//判断是否是某一个物体的子物体</span></span><br><span class="line">        <span class="built_in">bool</span> res = transform.IsChildOf(transform);</span><br><span class="line">		<span class="comment">//设置父物体</span></span><br><span class="line">        tans.SetParent(transform);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-键鼠监听"><a href="#4-键鼠监听" class="headerlink" title="4.键鼠监听"></a>4.键鼠监听</h1><p>对键鼠的监听应在每一帧进行,因此应放在Update中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按下鼠标 0左键,1右键,2滚轮</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;按下鼠标左键&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//持续按下鼠标</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;持续按下鼠标左键&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//抬起鼠标</span></span><br><span class="line">        Input.GetMouseButtonUp(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//键盘按键</span></span><br><span class="line">        <span class="comment">//按下</span></span><br><span class="line">        Input.GetKeyDown(KeyCode.A); <span class="comment">//按下A</span></span><br><span class="line">        Input.GetKey(KeyCode.A); <span class="comment">//持续按下A</span></span><br><span class="line">        Input.GetKeyUp(KeyCode.A); <span class="comment">//松开A</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-虚拟轴"><a href="#5-虚拟轴" class="headerlink" title="5.虚拟轴"></a>5.虚拟轴</h1><p>用虚拟轴可以使用不同的方式来控制,令键盘和手柄都操作虚拟轴,使得游戏可以适配所有设备</p>
<p>虚拟轴的变换为 -1 — 0 — 1 浮点数渐变而不是直接从-1 到 0 或 从0 到 1</p>
<p>虚拟轴设置在设置-输入管理器中</p>
<p>若虚拟轴只有一个按钮(肯定或否定),则构不成虚拟轴,作为虚拟按键</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取水平轴</span></span><br><span class="line">        <span class="built_in">float</span> horizontal = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="comment">//获取虚拟按键</span></span><br><span class="line">        Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>); <span class="comment">//参数为虚拟按键名</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-触摸监听"><a href="#6-触摸监听" class="headerlink" title="6.触摸监听"></a>6.触摸监听</h1><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//开启多点触摸</span></span><br><span class="line">        Input.multiTouchEnabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断单点触摸 判断多点触摸时返回多个Touch对象,一个对象一个触摸点</span></span><br><span class="line">        <span class="keyword">if</span> (Input.touchCount == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Touch touch = Input.touches[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//触摸位置</span></span><br><span class="line">            Debug.Log(touch.position);</span><br><span class="line">            <span class="comment">//触摸阶段</span></span><br><span class="line">            <span class="keyword">switch</span> (touch.phase)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> TouchPhase.Began:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TouchPhase.Moved:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TouchPhase.Stationary:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TouchPhase.Ended:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TouchPhase.Canceled:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-灯光"><a href="#7-灯光" class="headerlink" title="7.灯光"></a>7.灯光</h1><ul>
<li>定向灯光,从无穷远的方向照射过来,平行光,只有灯光的角度会影响灯光效果,位置不会影响</li>
<li>聚光,手电筒式的灯光</li>
<li>点光源</li>
<li>区域灯光 ,从一个平面发射出的平行光,仅支持烘焙灯光</li>
<li>遮罩可以删除或添加某一图层的光照效果</li>
<li>实时灯光 ,消耗性能大</li>
<li>烘焙 ,提前设定好灯光效果,灯光照射信息不再改变,不消耗性能,删除灯光后渲染效果依旧存在<ul>
<li>在物体名称后的三角下选择Contribute GI来设置被烘焙</li>
<li>然后在   窗口—渲染 右下角生成照明</li>
</ul>
</li>
</ul>
<h1 id="8-摄像机"><a href="#8-摄像机" class="headerlink" title="8.摄像机"></a>8.摄像机</h1><ul>
<li>透视摄像机</li>
<li>正交摄像机 没有近大远小的透视效果</li>
<li>相机的深度来设定相机的优先度,深度越大越优先显示</li>
<li>改为仅深度后,深度较高的相机拍摄到的内容就会叠加到深度较低的相机上</li>
<li>视野 即相机显示的范围大小</li>
<li>近平面和远平面限定了摄像机能拍摄到的物体范围,两平面之间的立方体内的物体才能显示</li>
<li>Viewport矩阵 限定了摄像机在游戏屏幕中的显示位置和大小,使屏幕中可以出现多个摄像机的画面</li>
<li>目标显示 类似于信号源,可以设置摄像机显示在哪个窗口中</li>
<li>目标纹理 会覆盖目标显示,将摄像机拍摄到的画面实时加载到一个纹理上,可以将<strong>摄像机画面在游戏物体上显示</strong></li>
<li><em>Ctrl&#x2F;Cmd + Shift + F</em> 将选中的<em>摄像机</em>与Scene视图对齐</li>
</ul>
<h1 id="9-音频"><a href="#9-音频" class="headerlink" title="9.音频"></a>9.音频</h1><ul>
<li>音乐</li>
<li>音效</li>
<li>摄像机使用 Audio Listener 组件 用于播放声音</li>
<li>游戏物体使用 Audio Source 承载声音<ul>
<li>加载组件后会有两个球体,球体的范围即为发出声音的最小距离和最大声音</li>
</ul>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//AudioClip</span></span><br><span class="line">    <span class="keyword">public</span> AudioClip music;</span><br><span class="line">    <span class="keyword">public</span> AudioClip se;</span><br><span class="line">    <span class="comment">//播放器组件</span></span><br><span class="line">    <span class="keyword">private</span> AudioSource player;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        player=GetComponent&lt;AudioSource&gt;();</span><br><span class="line">        <span class="comment">//设定播放的音频</span></span><br><span class="line">        player.clip = music;</span><br><span class="line">        <span class="comment">//循环播放</span></span><br><span class="line">        player.loop = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//音量</span></span><br><span class="line">        player.volume = <span class="number">0.5f</span>;</span><br><span class="line">        <span class="comment">//播放</span></span><br><span class="line">        player.Play(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按下空格切换播放</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (player.isPlaying)</span><br><span class="line">            &#123;</span><br><span class="line">                player.Pause();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                player.UnPause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按鼠标左键播声音(音效)</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            player.PlayOneShot(se);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-视频"><a href="#10-视频" class="headerlink" title="10.视频"></a>10.视频</h1><p>类似于音频播放</p>
<ul>
<li>创建一个渲染器纹理</li>
<li>创建一个游戏物体作为载体</li>
<li>在平面上添加 Video Player组件 ,导入的视频对象类型为 VideoClip</li>
<li>渲染模式选择渲染器纹理</li>
<li>应用纹理就可以显示视频了</li>
</ul>
<h3 id="要使用VideoPlayer需要引入UnityEngine-Video"><a href="#要使用VideoPlayer需要引入UnityEngine-Video" class="headerlink" title="要使用VideoPlayer需要引入UnityEngine.Video"></a>要使用VideoPlayer需要引入UnityEngine.Video</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.Video;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VideoTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> VideoPlayer player;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//和音频一致</span></span><br><span class="line">            player.Play();</span><br><span class="line">            player.Stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D基础</title>
    <url>/2023/01/12/Unity3D%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ol>
<li>脚本生命周期方法				</li>
<li>多脚本执行顺序                   </li>
<li>标识                                       </li>
<li>预设体                                  </li>
<li>vector3</li>
<li>旋转</li>
<li>Debug</li>
<li>物体类</li>
<li>游戏时间</li>
<li>Application</li>
</ol>
<span id="more"></span>

<h1 id="1-脚本生命周期方法"><a href="#1-脚本生命周期方法" class="headerlink" title="1.脚本生命周期方法"></a>1.脚本生命周期方法</h1><p>按调用顺序排序</p>
<ol>
<li>Awake()  最早调用,一般在此实现单例模式</li>
<li>OnEnable()  组件激活后调用,在Awake后会调用一次</li>
<li>Start() 可以在此设置一些初始值</li>
<li>FixedUpdate() 固定频率调用方法,按规定时间间隔重复调用</li>
<li>Update() 帧调用方法,每一帧调用一次</li>
<li>LateUpdate() 在Update后紧接着调用</li>
<li>OnDisabel() 组件取消激活时调用</li>
<li>OnDestroy() 析构函数(移除组件时就会被调用)</li>
</ol>
<h1 id="2-多脚本执行顺序"><a href="#2-多脚本执行顺序" class="headerlink" title="2.多脚本执行顺序"></a>2.多脚本执行顺序</h1><ul>
<li><p>对于使用了相同生命周期方法,后添加的脚本先执行</p>
</li>
<li><p>对于不同生命周期方法,按上述优先级执行</p>
</li>
<li><p>在设置里选择脚本执行顺序,改变执行顺序</p>
</li>
</ul>
<h1 id="3-标识"><a href="#3-标识" class="headerlink" title="3.标识"></a>3.标识</h1><ul>
<li><p>图层,图层最多32层,图层的概念比标签大,通过图层控制相机,碰撞等</p>
</li>
<li><p>标签用来区分游戏物体类别,标签可以重复</p>
</li>
<li><p>名称是唯一的,通过名称来选取某一特定游戏物体</p>
</li>
</ul>
<h1 id="4-预设体"><a href="#4-预设体" class="headerlink" title="4.预设体"></a>4.预设体</h1><p>通过预设体创建变体,变体也受预设体影响,但对变体操作不影响预设体</p>
<h1 id="5-Vector3"><a href="#5-Vector3" class="headerlink" title="5.Vector3"></a>5.Vector3</h1><ul>
<li><p>vector: 结构体,后缀多少就意味着内部有几个变量,即是一个向量</p>
</li>
<li><p>vector3即三维向量,内含x,y,z三个变量,可以代表坐标或旋转量或缩放等</p>
<ul>
<li>vector3.zero即生成一个0,0,0的向量,用作右值,用于初始化</li>
<li>vector3.normalized 规范化为单位向量</li>
</ul>
</li>
</ul>
<h1 id="6-旋转"><a href="#6-旋转" class="headerlink" title="6.旋转"></a>6.旋转</h1><ul>
<li>欧拉角 用三个0-360的值代表旋转量</li>
<li>四元数 quaternion<ul>
<li>Quaternion.identity 创建一个没有旋转角度的四元数</li>
<li>Quaternion.LookRotation() 创建一个朝向目标的四元数</li>
</ul>
</li>
</ul>
<h1 id="7-Debug"><a href="#7-Debug" class="headerlink" title="7.Debug"></a>7.Debug</h1><ul>
<li>debug.log() 	输出信息</li>
<li>debug.logworning() 输出警告信息</li>
<li>debug.logerror() 输出错误信息</li>
<li>debug还可以绘制线段,射线等</li>
</ul>
<p>debug输出的信息或绘制的内容只能在开发者视角看到,游戏中不会显示</p>
<h1 id="8-物体类"><a href="#8-物体类" class="headerlink" title="8.物体类"></a>8.物体类</h1><p>每一个游戏物体都对应一个C#物体类 <a href="https://www.bilibili.com/video/BV1gQ4y1e7SS?p=24">详细视频</a> </p>
<ul>
<li><p>GameObject go&#x3D;this.gameObject 获取当前脚本挂载的游戏物体,也可以直接gameObject.方法来对游戏物体进行操作</p>
</li>
<li><p>可以在一个脚本里创建一个物体,然后通过该物体使得在本物体中改变其他物体 <em>5min</em></p>
</li>
<li><p>获取transfrom组件 this.transform</p>
</li>
<li><p>获取其他组件 GetComponent&lt;类型名称&gt;();</p>
</li>
<li><p>添加组件 AddComponent&lt;组件类型名&gt;();</p>
</li>
<li><p>通过物体名称获取物体 GameObject.find(string name);</p>
</li>
<li><p>通过物体标签获取物体 GameObject.FindWithTag(string tag);</p>
</li>
<li><p>获取预设体 ,可以通过预设体实例化一个游戏物体 <em>20min</em></p>
</li>
<li><p>销毁 Destory(对象);</p>
</li>
</ul>
<h1 id="9-游戏时间"><a href="#9-游戏时间" class="headerlink" title="9.游戏时间"></a>9.游戏时间</h1><ul>
<li>Time.time 从游戏开始到现在的时间</li>
<li>Time.timeScale 时间缩放值,改变游戏速度</li>
<li>Time.fixedDeltaTime 固定时间间隔</li>
<li>Time.deltaTime 上一帧到这一帧的时间间隔<ul>
<li>可以累加来计算以帧为单位的游戏时间</li>
</ul>
</li>
</ul>
<h1 id="10-Application"><a href="#10-Application" class="headerlink" title="10.Application"></a>10.Application</h1><p>Application类,不同平台的路径不一样,使用该类来获取路径</p>
<ul>
<li><p>游戏数据文件夹路径 Application.dataPath 返回一个字符串,后面加上文件名就可以读取相应文件了(只读)</p>
</li>
<li><p>持久化文件路径 Application.persistentDataPath 根据平台不同改变,写数据应写在该路径下(写)</p>
</li>
<li><p>StreamingAssets 文件夹路径  Application.StreamingAssetsPath 指向第一个路径下的StreamingAssets文件夹(配置文件,只读,不需要加密)</p>
</li>
<li><p>临时文件夹 Application.temporaryCachePath</p>
</li>
<li><p>控制是否在后台运行 Application.runlnBackground</p>
</li>
<li><p>打开url Application.OpenURL(“”) 打开一个链接</p>
</li>
<li><p>退出游戏 Application.Quit()</p>
</li>
</ul>
<p>在脚本中使用Transform</p>
<p>游戏物体的父子关系由transform控制</p>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Uinty3DUI</title>
    <url>/2023/01/16/Uinty3DUI/</url>
    <content><![CDATA[<ol>
<li>画布</li>
<li>锚点和轴心点</li>
<li>文字</li>
<li>按钮</li>
<li>文本框</li>
<li>选项</li>
<li>滚动</li>
<li>面板</li>
<li>UI组件</li>
</ol>
<span id="more"></span>

<h1 id="一-画布"><a href="#一-画布" class="headerlink" title="一.画布"></a>一.画布</h1><ul>
<li><p>右键新建 UI-画布,创建画布会自动创建一个事件系统</p>
</li>
<li><p>画布使用2D模式进行边界,画布比例和显示窗口的比例一致</p>
</li>
<li><p>UI中的内容必须以画布为父物体才能显示</p>
</li>
<li><p>渲染模式</p>
<ul>
<li>设置为覆盖模式,则UI画布一定会显示在游戏最上层</li>
<li>设置为摄像机,则会按实际位置显示</li>
<li>设置为世界空间后,UI画布就可以旋转缩放等操作</li>
</ul>
</li>
<li><p>缩放</p>
<ul>
<li>恒定大小缩放和屏幕比例缩放</li>
<li>按照参考分辨率的比例进行缩放</li>
</ul>
</li>
</ul>
<h1 id="二-锚点和轴心点"><a href="#二-锚点和轴心点" class="headerlink" title="二.锚点和轴心点"></a>二.锚点和轴心点</h1><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><ul>
<li>每个图像都有一个在父物体身上的锚点,即有四个箭头指向的点,图像的坐标是相对于锚点</li>
<li>根据分辨率适配图像大小<ul>
<li>将锚点拉分开,即锚点变成一个矩形,由左下坐标和右上坐标定位</li>
<li>此时图片的大小,坐标就相对于锚框进行变换,当分辨率改变,锚框改变,图像也随之改变</li>
<li>若锚框变成锚线,则锚线垂直方向不会进行适配,平行方向会进行适配</li>
</ul>
</li>
<li>图像的位置由轴心确定,即小圆环,旋转和坐标都以该点确定</li>
</ul>
<h1 id="三-文本"><a href="#三-文本" class="headerlink" title="三.文本"></a>三.文本</h1><h2 id="旧版文本"><a href="#旧版文本" class="headerlink" title="旧版文本"></a>旧版文本</h2><ul>
<li>在UI-旧版-文本 创建的即为旧文本,按钮,文本框等组件都基础文本实现</li>
<li>勾选富文本后,可以使用html对一段文本中的片段改变样式</li>
</ul>
<h2 id="新版字体"><a href="#新版字体" class="headerlink" title="新版字体"></a>新版字体</h2><ul>
<li>依赖TestMeshPro组件实现</li>
<li>在UI-文本 创建</li>
</ul>
<h1 id="四-按钮"><a href="#四-按钮" class="headerlink" title="四.按钮"></a>四.按钮</h1><ul>
<li><p>把按钮的文本子物体删除就不显示文字</p>
</li>
<li><p>在Image组件中更改按钮图像</p>
</li>
<li><p>Button组件</p>
<ul>
<li>Interactable 是否开启按钮</li>
<li>导入的按钮图片需要设置为 Sprite(2D和UI) 才能作为按钮过度图片</li>
</ul>
</li>
<li><p>导航 即将按钮连接起来,使用上下左右键可以切换选中的按钮</p>
</li>
<li><p>鼠标单击</p>
<ul>
<li>创建脚本,可以挂载到任意物体上</li>
<li><code>public void ButtonClick()&#123;&#125;</code> 点击方法</li>
<li>将脚本传入目标按钮,在鼠标单击中选中脚本和点击方法</li>
</ul>
</li>
</ul>
<h1 id="五-文本框"><a href="#五-文本框" class="headerlink" title="五.文本框"></a>五.文本框</h1><ul>
<li>文本框中的文本是占位文本,输入文本后占位文本消失</li>
<li>改变内容类型设定输入</li>
<li>事件<ul>
<li>值改变时,提交时,结束编辑时三个事件,使用方法和按钮一致</li>
<li>引入 UnityEngine.UI,创建 InputField 对象,将脚本挂载到UI上并将输入框添加到脚本的InputFiled上,InputFiled对象就会实时获取输入框内容</li>
</ul>
</li>
</ul>
<h1 id="六-选项"><a href="#六-选项" class="headerlink" title="六.选项"></a>六.选项</h1><ul>
<li>UI-切换 创建选项</li>
<li>添加组件 Toggle Group 组件,将该组件关联到多个选项的Group中,就可以实现多选一等功能</li>
<li>UI-下拉列表框 创建 下拉框<ul>
<li>可以在组件中手动添加选项</li>
<li>可以使用  <a href="https://www.bilibili.com/video/BV1gQ4y1e7SS?p=64&vd_source=5a3868fe69388cd372b51d75baaaca98">脚本添加</a></li>
<li>可以为选项单独添加图像,分为标题图像和项图像</li>
</ul>
</li>
</ul>
<h1 id="七-滚动条"><a href="#七-滚动条" class="headerlink" title="七.滚动条"></a>七.滚动条</h1><ul>
<li>UI-滑动条 <ul>
<li>事件使用和按钮一致</li>
</ul>
</li>
<li>UI-滚动条<ul>
<li>滚动条一般和滑动视图联合使用</li>
</ul>
</li>
<li>UI-滑动视图<ul>
<li>用滑动视图显示较多的内容</li>
<li>Content为要显示的全部内容 Viewport显示Content的部分内容</li>
</ul>
</li>
</ul>
<h1 id="八-面板"><a href="#八-面板" class="headerlink" title="八.面板"></a>八.面板</h1><ul>
<li>UI-面板<ul>
<li>把面板放在需要的位置</li>
<li>将需要的组件放在面板中,此时仅改变面板的锚点就可以应用到面板中的所有组件</li>
</ul>
</li>
</ul>
<h1 id="九-UI组件"><a href="#九-UI组件" class="headerlink" title="九.UI组件"></a>九.UI组件</h1><ul>
<li><p>遮罩</p>
<ul>
<li>添加Content Size Fitter 使文本框等组件随着游戏状态的变换来适配</li>
</ul>
</li>
<li><p>控制间隔一致</p>
<ul>
<li>选中要间隔一致的物体的父物体</li>
<li>添加Vertical Layout Group垂直布局,也可以添加水平布局,网格布局等</li>
<li>网格布局的大小由单元格大小确定</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D动画</title>
    <url>/2023/01/15/Unity3D%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<ol>
<li>角色动画</li>
<li>按键控制</li>
<li>剪辑</li>
<li>曲线和帧事件</li>
<li>混合动画</li>
<li>动画分层</li>
<li>反向动力</li>
<li>导航网格</li>
<li>网格连接和动态障碍物</li>
<li>导航区域</li>
</ol>
<span id="more"></span>

<h1 id="一-角色动画"><a href="#一-角色动画" class="headerlink" title="一.角色动画"></a>一.角色动画</h1><ul>
<li><p><a href="https://www.bilibili.com/video/BV1gQ4y1e7SS?p=48&vd_source=5a3868fe69388cd372b51d75baaaca98">组件控制</a></p>
</li>
<li><p>脚本控制</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.F))</span><br><span class="line">        &#123;</span><br><span class="line">            GetComponent&lt;Animator&gt;().SetTrigger(<span class="string">&quot;条件名&quot;</span>);<span class="comment">//设置一次触发</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在过度中选择退出时间,就会等待上个动画播放完才执行下一个动画</p>
</li>
</ul>
<h1 id="二-按键控制"><a href="#二-按键控制" class="headerlink" title="二.按键控制"></a>二.按键控制</h1><ul>
<li><p>把过度持续时间设置为0或取消固定持续时间,就可以减少动画延时</p>
</li>
<li><p>脚本控制</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Animator animator;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> horizontal = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="built_in">float</span> vertiacl = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        Vector3 dir = <span class="keyword">new</span> Vector3(horizontal, <span class="number">0</span>, vertiacl);</span><br><span class="line">        <span class="comment">//看向向量</span></span><br><span class="line">        transform.rotation = Quaternion.LookRotation(dir);</span><br><span class="line">        <span class="comment">//动作切换 当用户按下方向键,按下键后方向就不好为0来判断</span></span><br><span class="line">        <span class="keyword">if</span> (dir != Vector3.zero)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//移动</span></span><br><span class="line">            transform.rotation=Quaternion.LookRotation(dir);</span><br><span class="line">            transform.Translate(Vector3.forward * <span class="number">2</span> * Time.deltaTime);</span><br><span class="line">            animator.SetBool(<span class="string">&quot;run&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;run&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三-剪辑"><a href="#三-剪辑" class="headerlink" title="三.剪辑"></a>三.剪辑</h1><h2 id="Rig选项"><a href="#Rig选项" class="headerlink" title="Rig选项"></a>Rig选项</h2><ul>
<li>泛型支持所有动画类型</li>
<li>人形特指人物模型的动画</li>
<li>旧版指 可以用Animation组件播放</li>
</ul>
<h2 id="检查器"><a href="#检查器" class="headerlink" title="检查器"></a>检查器</h2><ul>
<li>在检查器中更改的设置必须点击最下方的应用</li>
<li>在检查器中可以对动画进行一个剪辑,播放指定长度的动画</li>
</ul>
<h1 id="四-曲线和帧事件"><a href="#四-曲线和帧事件" class="headerlink" title="四.曲线和帧事件"></a>四.曲线和帧事件</h1><h2 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h2><ul>
<li>曲线默认在整个动画期间全返回为0,更改曲线可以改变返回的值</li>
<li>通过返回值可以判断动作执行的进度,根据进度可以做一些其他操作</li>
<li>在动画器中添加 float 条件 ,以获取数值</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Debug.Log(animator.GetFloat(<span class="string">&quot;条件名&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="帧事件"><a href="#帧事件" class="headerlink" title="帧事件"></a>帧事件</h2><ul>
<li>可以设定在动画播放的某一个时刻,触发一个事件</li>
<li>在检查器中选定某个帧,添加一个函数,如添加一个名为leftFoot的函数</li>
<li>将脚本挂载到动画播放的游戏物体上,设定leftFoot,动画每到该帧执行一次</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftFoot</span>()</span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五-混合动画"><a href="#五-混合动画" class="headerlink" title="五.混合动画"></a>五.混合动画</h1><ul>
<li>在动画控制器中 创建状态-从新混合树 就可以创建混合动画</li>
<li>双击打开混合树,一般用1D通过一个参数来控制混合</li>
<li>通过Parameter选择混合参数,参数需要在动画器中被创建Float类型</li>
<li>在内部加号添加动画或再加一级混合树</li>
<li>动画Threshold 数值代表动画混合阈值,与值相同时不混合,在两值之间进行不同程度的混合</li>
<li>取消Automate Thresholds就可以更改 Thresholds数值</li>
</ul>
<h1 id="六-动画分层"><a href="#六-动画分层" class="headerlink" title="六.动画分层"></a>六.动画分层</h1><ul>
<li>动画有三个状态 入口状态Entry 出口状态Exit 任何状态AnyState<ul>
<li>任何状态创建一个过度,即所有状态下都可以过度到下一个状态</li>
</ul>
</li>
<li>子状态机包含一系列动画,可以把多个动画组合起来形成一个大动画,使用和一般状态一样</li>
<li>可以添加多个图层<ul>
<li>在左侧齿轮改变权重,就可以形成类似融合动画的效果</li>
<li>两图层权重相同,新创建的图层覆盖旧图层</li>
<li>遮罩<ul>
<li>在项目中创建遮罩,修改遮罩来更改权重应用的部分</li>
<li>在遮罩中加载到图层中,可以单独使人体某一部分覆盖上级动画,使身体动画和手部动画不冲突</li>
</ul>
</li>
</ul>
</li>
<li>图层可以替代子状态机</li>
</ul>
<h1 id="七-反向动力学"><a href="#七-反向动力学" class="headerlink" title="七.反向动力学"></a>七.反向动力学</h1><ul>
<li><p>可以使移动中令人物一直朝向某物体或身体某一部分指向某物体</p>
</li>
<li><p>在动画控制器中选中IK</p>
</li>
<li><p>脚本控制</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorIK</span>(<span class="params"><span class="built_in">int</span> layerIndex</span>)</span>&#123; <span class="comment">//传入参数为图层引索</span></span><br><span class="line">    <span class="comment">//设置头部IK  先获取两个物体 animator 和 target </span></span><br><span class="line">    animator.SetLookAtWeight(<span class="number">1</span>);<span class="comment">//设置权重</span></span><br><span class="line">    animator.SetLookAtPosition(target.position); </span><br><span class="line">    <span class="comment">//设置右手IK权重 令身体部分也指向某个物体</span></span><br><span class="line">    animator.SetIkPositionWight(AvatarIKGoal.RightHand,<span class="number">1</span>); <span class="comment">//位置</span></span><br><span class="line">    animator.SetIKRoationWight(AvatarIKGoal.RightHand,<span class="number">1</span>);<span class="comment">//旋转</span></span><br><span class="line">    animator.SetIKPosition(AvatarIKGoal.RightHand,target.position);<span class="comment">//应用IK</span></span><br><span class="line">    animator.SetIKRotation(AvatarIKGoal.RIghtHand,target.rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>商城中有其他IK插件,可能比官方提供的更好用</p>
</li>
</ul>
<h1 id="八-导航网格"><a href="#八-导航网格" class="headerlink" title="八.导航网格"></a>八.导航网格</h1><h2 id="烘焙导航"><a href="#烘焙导航" class="headerlink" title="烘焙导航"></a>烘焙导航</h2><ul>
<li>先选中所有导航涉及的游戏物体,在检查器中将其在id最右侧更改为 Navigation Static</li>
<li>在窗体中打开 AI-导航</li>
<li>烘焙最为重要,通过半径,高度,坡度和步高判断路径是否可以通过来生成导航网格</li>
<li>点击烘焙后生成导航网格,人物可以在蓝色区域中移动</li>
</ul>
<h2 id="导航应用"><a href="#导航应用" class="headerlink" title="导航应用"></a>导航应用</h2><ul>
<li><p>为需要导航的游戏物体添加 Nav Mesh Agent组件</p>
</li>
<li><p>导航代理,即使用不同参数生成的导航网格</p>
</li>
<li><p>在组件中设置导航选项</p>
</li>
<li><p>若多个物体通过一个狭窄的路口,优先级高的先通过</p>
</li>
<li><p>脚本控制移动</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.AI;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerControlTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> NavMeshAgent agent;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取代理组件</span></span><br><span class="line">        agent = GetComponent&lt;NavMeshAgent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//移动到点击位置</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))&#123;</span><br><span class="line">            Ray ray= Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">            RaycastHit hit;</span><br><span class="line">            <span class="keyword">if</span>(Physics.Raycast(ray,<span class="keyword">out</span> hit))</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3 point = hit.point;</span><br><span class="line">                <span class="comment">//设置目标点</span></span><br><span class="line">                agent.SetDestination(point);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="九-网格连接和动态障碍物"><a href="#九-网格连接和动态障碍物" class="headerlink" title="九.网格连接和动态障碍物"></a>九.网格连接和动态障碍物</h1><h2 id="网格连接"><a href="#网格连接" class="headerlink" title="网格连接"></a>网格连接</h2><ul>
<li>导航烘焙选项中 生成分离网格链接</li>
<li>选中要生成网格链接的对象,在对象选项中勾选Generate OffMeshLinks</li>
<li>设置掉率高度和跳跃距离后重新烘焙就可以链接网格(跳跃距离是横向跳跃,步高是纵向跳跃)</li>
<li>设置两个特殊点使两点间可以跳跃<ul>
<li>使用两个立方体(或其他物体)放在两个特殊点</li>
<li>添加组件 Off Mesh Link </li>
<li>添加起始物体和结束物体</li>
<li>自动更新位置,使网格链接随这两点位置变换</li>
</ul>
</li>
</ul>
<h2 id="动态障碍物"><a href="#动态障碍物" class="headerlink" title="动态障碍物"></a>动态障碍物</h2><ul>
<li>选中要设置为动态障碍物的物体,取消Navigation Static,重新烘焙</li>
<li>给动态障碍物添加 Nav Mesh Obstacle组件 <ul>
<li>给动画障碍物添加切割,就会根据障碍物状态动态烘焙网格</li>
<li>添加切割会增加性能消耗,非必要不使用</li>
</ul>
</li>
</ul>
<h1 id="十-导航区域"><a href="#十-导航区域" class="headerlink" title="十.导航区域"></a>十.导航区域</h1><ul>
<li><p>不同区域有不同颜色,名称,权重</p>
</li>
<li><p>导航会优先选取总权重小的路线</p>
</li>
<li><p>创建一个物体来承载不同区域,选中对象,在导航中的对象下选择导航区域</p>
</li>
<li><p>在导航物体中的导航组件中改变区域遮罩,来改变那些区域可以走</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D进阶</title>
    <url>/2023/01/15/Unity3D%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<ol>
<li>角色控制器</li>
<li>重力</li>
<li>碰撞监听</li>
<li>触发</li>
<li>物理关节</li>
<li>物理材质</li>
<li>射线检测</li>
<li>粒子系统</li>
<li>绘制</li>
<li>游戏物体动画</li>
</ol>
<span id="more"></span>

<h1 id="一-角色控制器"><a href="#一-角色控制器" class="headerlink" title="一.角色控制器"></a>一.角色控制器</h1><h2 id="控制器方案"><a href="#控制器方案" class="headerlink" title="控制器方案"></a>控制器方案</h2><ul>
<li>可以在商店中下载角色控制器</li>
<li>可以使用Unity3D提供的角色控制器</li>
<li>可以自己编写角色控制器</li>
</ul>
<h2 id="控制器的使用"><a href="#控制器的使用" class="headerlink" title="控制器的使用"></a>控制器的使用</h2><ul>
<li>给游戏物体添加 <code>Character Controller</code> 组件</li>
<li>WASD会获取一个水平轴和一个垂直轴数值 </li>
<li>使用向量的方向来控制移动方法,向量的大小控制移动速度</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerControlTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CharacterController player;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        player=GetComponent&lt;CharacterController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取虚拟轴数据</span></span><br><span class="line">        <span class="built_in">float</span> horizontal = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="built_in">float</span> vertical = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        <span class="comment">//创建称一个方向向量</span></span><br><span class="line">        Vector3 dir = <span class="keyword">new</span> Vector3(horizontal, <span class="number">0</span>, vertical);</span><br><span class="line">        player.SimpleMove(dir * <span class="number">2</span>);<span class="comment">//该移动方法受重力影响  且移动速度为2倍,用于控制移动速度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-重力"><a href="#二-重力" class="headerlink" title="二.重力"></a>二.重力</h1><ul>
<li><p>添加 <code>Rigidbody</code> 组件,就会使物体受到重力影响</p>
</li>
<li><p><code>Is Kinematic</code> 打开后,该物体就不受物理系统影响了,无法被撞开或下落等</p>
</li>
<li><p>若要判断高速物体的碰撞判断,应该选用连续的碰撞检测,而不是离散的,离散会每隔一段时间检测一次可能会检测不到</p>
</li>
</ul>
<h1 id="三-碰撞监听"><a href="#三-碰撞监听" class="headerlink" title="三.碰撞监听"></a>三.碰撞监听</h1><h2 id="产生碰撞"><a href="#产生碰撞" class="headerlink" title="产生碰撞"></a>产生碰撞</h2><ul>
<li>每个游戏物体上的Collider组件就是碰撞检测器组件</li>
<li>有碰撞器和刚体组件才能产生碰撞</li>
<li>可以改变碰撞判定范围</li>
</ul>
<h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><ul>
<li>将脚本挂载到碰撞两物体的任意一个物体上就可以检测碰撞</li>
<li>传入的参数是碰撞到的物体的信息</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CollisionTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//监听发生碰撞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//持续发生碰撞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionStay</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听结束碰撞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionExit</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四-触发"><a href="#四-触发" class="headerlink" title="四.触发"></a>四.触发</h1><ul>
<li>碰撞和触发的产生条件一致,但一方的碰撞器必须设置为是触发器</li>
<li>当设置为触发器后,就不会发生碰撞,会穿过触发器</li>
<li>把触发器的Mesh Renderer 取消,使其不显示</li>
<li>通过触发器就可以判断游戏物体是否处于或经过某一区域,然后进行一系列操作</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider other</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五-物理关节"><a href="#五-物理关节" class="headerlink" title="五.物理关节"></a>五.物理关节</h1><p>在Physics中的Hinge Joint组件,即铰链关节</p>
<ul>
<li>铰链关键使物体沿铰链轴固定,可以用于门的物理效果等</li>
<li>通过Anchor调整关节中心点,通过轴调整朝向</li>
<li>也可以给关节一个目标速度和力,打开Use Motor就可以使门自动旋转</li>
</ul>
<p>Spring Joint 弹簧关节</p>
<ul>
<li>可以给两个物体间添加一个弹簧</li>
</ul>
<p>Fixed Joint 固定关节</p>
<ul>
<li>相等于给两个物体之间添加一个固定的杆</li>
<li>可以设置一个阈值,当力大于阈值时关节断开</li>
</ul>
<h1 id="六-物理材质"><a href="#六-物理材质" class="headerlink" title="六.物理材质"></a>六.物理材质</h1><p>改变物体表面的物理性质,如摩擦因数等参数</p>
<ul>
<li><p>在文件目录中创建 物理材质(注意不是材质)</p>
</li>
<li><p>在Mesh Collider组件中 添加 材质</p>
</li>
<li><p>在物理材质中调整材质参数</p>
</li>
</ul>
<h1 id="七-射线检测"><a href="#七-射线检测" class="headerlink" title="七. 射线检测"></a>七. 射线检测</h1><p>点击平面上一点后令物体移动到该点,即从摄像机向点击方向射出一条射线,判断射线碰触到的第一个物体的点</p>
<ul>
<li>一般将射线检测脚本挂载到 要进行动作的游戏物体上</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建射线的两种方法</span></span><br><span class="line">        Ray ray = <span class="keyword">new</span> Ray(Vector3.zero, Vector3.up);</span><br><span class="line">        </span><br><span class="line">        Ray cameraRay = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按下鼠标发射射线</span></span><br><span class="line">        Ray cameraRay = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">        <span class="comment">//声明一个碰撞信息类</span></span><br><span class="line">        RaycastHit hit;</span><br><span class="line">        <span class="comment">//碰撞检测</span></span><br><span class="line">        <span class="built_in">bool</span> res = Physics.Raycast(cameraRay, <span class="keyword">out</span> hit);</span><br><span class="line">        <span class="comment">//out是c#的一个输出方法,若产生碰撞,则hit就会有碰撞信息</span></span><br><span class="line">        <span class="keyword">if</span> (res == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(hit.point);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//多物体检测</span></span><br><span class="line">        RaycastHit[] hits = Physics.RaycastAll(cameraRay);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="八-粒子系统"><a href="#八-粒子系统" class="headerlink" title="八. 粒子系统"></a>八. <a href="https://www.bilibili.com/video/BV1gQ4y1e7SS?p=44&spm_id_from=pageDriver&vd_source=5a3868fe69388cd372b51d75baaaca98">粒子系统</a></h1><p>粒子系统组件 <code>Particle System</code></p>
<p>在粒子系统组件中更改粒子设置</p>
<h1 id="九-绘制"><a href="#九-绘制" class="headerlink" title="九. 绘制"></a>九. 绘制</h1><h2 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h2><ul>
<li><p>创建一个空白的物体,添加Line Renderer 组件 用于绘制线段</p>
</li>
<li><p>绘制后线的方向不受物体方向影响,受组件里的位置影响</p>
</li>
<li><p>Materials 中选择材质</p>
</li>
<li><p>在组件中添加点来绘制</p>
</li>
<li><p>点循环可以使头尾相连</p>
</li>
<li><p>用场景工具直接使用鼠标绘制</p>
</li>
<li><p>通过脚本设置线段位置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       LineRenderer lineRenderer = GetComponent&lt;LineRenderer&gt;();</span><br><span class="line">       lineRenderer.positionCount = <span class="number">3</span>; <span class="comment">//设置有几个点</span></span><br><span class="line">       <span class="comment">//设置三个位置</span></span><br><span class="line">       lineRenderer.SetPosition(<span class="number">0</span>,Vector3.zero);</span><br><span class="line">       lineRenderer.SetPosition(<span class="number">0</span>, Vector3.one);</span><br><span class="line">       lineRenderer.SetPosition(<span class="number">0</span>, Vector3.down);</span><br><span class="line">       <span class="comment">//开始颜色 等等</span></span><br><span class="line">       lineRenderer.startColor = Color.white;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="拖尾"><a href="#拖尾" class="headerlink" title="拖尾"></a>拖尾</h2><ul>
<li>Trail Renderer 组件</li>
<li>时间 设定 拖尾的持续时间 </li>
<li>最小顶点距离 即 移动多少距离后生成拖尾</li>
</ul>
<h1 id="十-游戏物体动画"><a href="#十-游戏物体动画" class="headerlink" title="十.游戏物体动画"></a>十.游戏物体动画</h1><h2 id="旧版动画组件-Animation"><a href="#旧版动画组件-Animation" class="headerlink" title="旧版动画组件 Animation"></a>旧版动画组件 Animation</h2><ul>
<li><p>动画内容Clip,也可以添加多个动画</p>
</li>
<li><p>Culling Tpye 选择 Based On Renderers 后看到才做动画,看不到就停止</p>
</li>
<li><p>窗口-动画-动画 打开动画制作面板,然后选中要制作动画的物体 <a href="https://www.bilibili.com/video/BV1gQ4y1e7SS?p=46&vd_source=5a3868fe69388cd372b51d75baaaca98">详细教程</a></p>
</li>
<li><p>脚本控制</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Input.GetMouseButtonDown(<span class="number">0</span>))&#123;</span><br><span class="line">    GetComponent&lt;Animation&gt;().Play(<span class="string">&quot;要播放的动画名&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="新版动画组件-Animator"><a href="#新版动画组件-Animator" class="headerlink" title="新版动画组件 Animator"></a>新版动画组件 Animator</h2><ul>
<li><p>挂载Animator 组件 在项目中创建动画器控制器加载到Animator上</p>
</li>
<li><p>所有动画挂载到控制器中执行</p>
</li>
<li><p>在控制器中对动画进行进一步控制</p>
</li>
<li><p>脚本控制</p>
<p>  if(Input.GetMouseButtonDown(0)){<br>  GetComponent<Animator>().Play(“要播放的动画名”);<br>  }</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛-1</title>
    <url>/2023/01/17/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h1><span id="more"></span>

<ul>
<li>单调队列&#x2F;栈<ul>
<li>即普通的队列或栈,但在进行 <code>入</code> 操作时通过弹出尾部元素来使队列或栈保持单调性</li>
<li>用于滑动窗口,DP优化等</li>
</ul>
</li>
<li>哈夫曼树<ul>
<li>一种二叉树,进行对具有权重的两两对象操作时求权重和最小或最优前缀码等</li>
</ul>
</li>
<li>优先队列<ul>
<li><code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;</code> 小根堆  <code>less&lt;int&gt;</code>  大根堆</li>
<li>可以用于构造哈夫曼树</li>
</ul>
</li>
</ul>
<h1 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h1><h2 id="问题规模"><a href="#问题规模" class="headerlink" title="问题规模"></a>问题规模</h2><p>在1秒时间内可用的算法时间时间复杂度</p>
<table>
<thead>
<tr>
<th>问题规模n</th>
<th>logn</th>
<th>n</th>
<th>nlogn</th>
<th>n^2</th>
<th>2^n</th>
<th>n!</th>
</tr>
</thead>
<tbody><tr>
<td>n&lt;&#x3D;11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>n&lt;&#x3D;25</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>n&lt;&#x3D;5000</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>n&lt;&#x3D;1e6</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>n&lt;&#x3D;1e7</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>n&lt;&#x3D;1e8</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h2 id="尺取法-双指针-快慢指针"><a href="#尺取法-双指针-快慢指针" class="headerlink" title="尺取法(双指针,快慢指针)"></a>尺取法(双指针,快慢指针)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>尺取法可以优化二重循环,将O(n^2)优化为O(n)</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">        <span class="comment">//dosometing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化为----------&gt;</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">    i++;</span><br><span class="line">    j--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>java图片增强</title>
    <url>/2023/02/22/java%E5%9B%BE%E7%89%87%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h1 id="JAVA-IO"><a href="#JAVA-IO" class="headerlink" title="JAVA IO"></a>JAVA IO</h1><span id="more"></span>

<h2 id="图像的读取和保存-GUI"><a href="#图像的读取和保存-GUI" class="headerlink" title="图像的读取和保存(GUI)"></a>图像的读取和保存(GUI)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">&quot;打开&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">JFileChooser</span> <span class="variable">chooser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFileChooser</span>();</span><br><span class="line">            <span class="type">FileNameExtensionFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileNameExtensionFilter</span>(</span><br><span class="line">                    <span class="string">&quot;JPG &amp; GIF &amp; PNG Images&quot;</span>, <span class="string">&quot;png&quot;</span>, <span class="string">&quot;jpeg&quot;</span>, <span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;gif&quot;</span></span><br><span class="line">            );</span><br><span class="line">            chooser.setFileFilter(filter);</span><br><span class="line">            <span class="type">int</span> <span class="variable">returnValue</span> <span class="operator">=</span> chooser.showOpenDialog(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (returnValue == JFileChooser.APPROVE_OPTION) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;You chose to open this file: &quot;</span> +</span><br><span class="line">                        chooser.getSelectedFile().getName());</span><br><span class="line">                imgPix = tools.getPixel(chooser.getSelectedFile().getPath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">&quot;保存&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">JFileChooser</span> <span class="variable">chooser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFileChooser</span>();</span><br><span class="line">            <span class="type">FileNameExtensionFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileNameExtensionFilter</span>(<span class="string">&quot;JPG &amp; GIF &amp; PNG Images&quot;</span>, <span class="string">&quot;png&quot;</span>, <span class="string">&quot;jpeg&quot;</span>, <span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;gif&quot;</span>);</span><br><span class="line">            chooser.setFileFilter(filter);</span><br><span class="line">            <span class="type">int</span> returnValue=chooser.showSaveDialog(<span class="literal">null</span> );</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ImageIO.write(imgList.get(imgList.size()-<span class="number">1</span>),<span class="string">&quot;PNG&quot;</span>,chooser.getSelectedFile() );</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>都使用 JFileChooser类进行操作,读取时使用chooser.getSelectedFile() 获取文件,保存时使用 ImagetIO.write() 进行保存,</p>
<p>保存时的参数分别为(BufferedImage对象,文件类型,文件路径)</p>
<h1 id="JAVA-滑杆"><a href="#JAVA-滑杆" class="headerlink" title="JAVA 滑杆"></a>JAVA 滑杆</h1><h1 id="JAVA-选项卡"><a href="#JAVA-选项卡" class="headerlink" title="JAVA 选项卡"></a>JAVA 选项卡</h1><h2 id="选项卡的使用"><a href="#选项卡的使用" class="headerlink" title="选项卡的使用"></a>选项卡的使用</h2><ul>
<li>建立JTabbedPane对象,作为选项卡,选项卡的选项都要添加到该对象中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JTabbedPane tabbledPane=<span class="keyword">new</span> <span class="title class_">JTabbedPane</span>(JTabbedPane.TOP);</span><br><span class="line">        imgListener.setTabblePanel(tabbledPane);</span><br><span class="line">        tabbledPane.setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="built_in">this</span>.getWidth()-<span class="number">180</span>,<span class="number">30</span>));</span><br><span class="line">        tabbledPane.setLocation(<span class="number">90</span>,<span class="number">0</span>);</span><br><span class="line">        tabbledPane.addChangeListener(tabbleListener);</span><br><span class="line">        tabbleListener.setShowImgPanel(imgPanel);</span><br></pre></td></tr></table></figure>

<ul>
<li>对选项卡添加选项</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JLabel</span> <span class="variable">nameLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>();</span><br><span class="line">        nameLabel.setName(path);</span><br><span class="line">        tabblePanel.add(name,nameLabel);</span><br><span class="line">        <span class="comment">//将选项卡设置到最新添加的</span></span><br><span class="line">        tabblePanel.setSelectedIndex(tabblePanel.getComponentCount()-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>JLabel作为选项对象,<code>tabblePanel.add(name,nameLabel);</code> 参数分别为: 显示出来的选项名称,选项对象</p>
<h2 id="设置选中的选项"><a href="#设置选中的选项" class="headerlink" title="设置选中的选项"></a>设置选中的选项</h2><p><code>tabblePanel.setSelectedIndex(tabblePanel.getComponentCount()-1);</code></p>
<ul>
<li>通过index 选中选项,<code>tabblePanel.getComponentCount()-1</code> 即最后一个选项的引索</li>
</ul>
<h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>对选项卡进行监听要实现 ChangeListener 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateChanged</span><span class="params">(ChangeEvent e)</span> &#123;</span><br><span class="line">        <span class="type">JTabbedPane</span> <span class="variable">pane</span> <span class="operator">=</span> (JTabbedPane) e.getSource();</span><br><span class="line">        JLabel label= (JLabel) pane.getSelectedComponent();</span><br><span class="line"></span><br><span class="line">        String path=label.getName();</span><br><span class="line">        System.out.println(path);</span><br><span class="line">        imgList.add(openImg(path));</span><br><span class="line">        imgListener.setImgPix(path);</span><br><span class="line"></span><br><span class="line">        panel.repaint();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h1 id="JAVA-菜单"><a href="#JAVA-菜单" class="headerlink" title="JAVA 菜单"></a>JAVA 菜单</h1><h2 id="菜单条"><a href="#菜单条" class="headerlink" title="菜单条"></a>菜单条</h2><p>JMenuBar — 菜单条类</p>
<ul>
<li>JMenuBar是菜单的基础,只能添加到JFram组件的顶端中,承载菜单组件,一个JFram组件只能添加一个菜单条</li>
<li><code>this.setJMenuBar(new JMenuBar);</code></li>
</ul>
<p>JMenu — 菜单类</p>
<ul>
<li>JMenu 是菜单条中的一个个选项,添加到菜单条中 </li>
<li><code>menuBar.add(menu);</code></li>
</ul>
<p>JMenuItem — 菜单项类 </p>
<ul>
<li>JMenuItem 是菜单点开后的菜单选项,添加到菜单中</li>
<li>分割条: <code>menu.addSeparator();</code></li>
</ul>
<h1 id="JAVA-窗体操作"><a href="#JAVA-窗体操作" class="headerlink" title="JAVA 窗体操作"></a>JAVA 窗体操作</h1><ul>
<li>退出程序 <code>System.exit(0);</code></li>
<li>退出窗口<code> (JFrame)frame.dispose();</code></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/2023/02/06/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="基础算法-1"><a href="#基础算法-1" class="headerlink" title="基础算法-1"></a>基础算法-1</h1><span id="more"></span>

<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>查找 [0,n)之间的 x或<strong>x的后缀</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binSearch</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>; <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="comment">// mid=left+(right-left)/2  防止right和left相加后溢出</span></span><br><span class="line">        <span class="comment">// mid=left+(right-left)&gt;&gt;2 综合最优</span></span><br><span class="line">		<span class="keyword">if</span> (a[mid] &gt; x) right = mid;</span><br><span class="line">		<span class="comment">//if(a[mid]&gt;=x) right=mid;</span></span><br><span class="line">		<span class="comment">// eles left=mid+1;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码中 left&#x3D;mid+1 不能写作 left&#x3D;mid,默认向下取整,若left&#x3D;2,right&#x3D;3则导致 left&#x3D;mid时 陷入死循环</li>
<li>不同问题下mid的取值<ul>
<li>语言中 mid默认向下取整,称为”左中位数”,适应于求 x或x的后缀</li>
<li>向上取整时,称为”右中位数”,使用于 求x或x的前驱 此时 <code>left=mid; right=mid-1;</code></li>
</ul>
</li>
<li>应谨慎使用直接  除2(x&#x2F;2)操作,因为默认朝 0 方向取整<ul>
<li>为运算 &gt;&gt; 向下取整而 right-left 保证了不小于0</li>
</ul>
</li>
</ul>
<h3 id="STL二分"><a href="#STL二分" class="headerlink" title="STL二分"></a>STL二分</h3><ul>
<li>lower_bound()  upper_bound()</li>
</ul>
<h3 id="最大值最小化-最小值最大化"><a href="#最大值最小化-最小值最大化" class="headerlink" title="最大值最小化(最小值最大化)"></a>最大值最小化(最小值最大化)</h3><p>- </p>
<h3 id="实数二分"><a href="#实数二分" class="headerlink" title="实数二分"></a>实数二分</h3><p>实数二分不需要考虑取整问题,编码比整数二分简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-7</span>; <span class="comment">//控制精度</span></span><br><span class="line">	<span class="type">int</span> left, right,x;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (right - left &gt; eps) &#123;</span><br><span class="line">		<span class="type">double</span> mid = left + (right - left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(mid)) right = mid;</span><br><span class="line">		<span class="keyword">else</span> left=mid</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>用for循环控制精度和while控制精度都存在问题</p>
<ul>
<li>for循环次数不能太大或太小,一般100次比while要大得多,但若for中需要的时间过长会导致超时,需要根据实际调整循环次数</li>
<li>对于while循环 eps太小会超时,太大会导致精度小,也需要仔细考虑</li>
</ul>
<h3 id="P1824"><a href="#P1824" class="headerlink" title="P1824"></a>P1824</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, c,x[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">1</span>,pre=<span class="number">0</span>;	<span class="comment">//第一头牛放在第一个位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x[i] - x[pre] &gt;= mid) &#123;</span><br><span class="line">			count += <span class="number">1</span>;</span><br><span class="line">			pre = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count &gt;= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; x[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(x, x + n);</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = x[n - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">		mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">			ans = mid; <span class="comment">//记录结果</span></span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> right = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h2><p>用 mid1和mid2 进行三分,可以用于求单峰或单谷函数的极值</p>
<p>N次函数求值: <code>for(int i=0;i&lt;=n;++i) s=s*x+a[i]  </code></p>
<p>a[i]代表从高到低各项的系数</p>
<h3 id="整数三分"><a href="#整数三分" class="headerlink" title="整数三分"></a>整数三分</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(right-left&gt;<span class="number">2</span>)&#123;</span><br><span class="line">    mid1=left+(right-left)/<span class="number">3</span>;</span><br><span class="line">    mid2=right-(right-left)/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid1)&gt;<span class="built_in">check</span>(mid2)) </span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​     </p>
<h1 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h1><p>倍增法需要提前计算好跳板,这要求数据是静态不变的,若数据动态变化,跳板需要重新计算,倍增法也就失去意义了</p>
<h2 id="洛谷P4155"><a href="#洛谷P4155" class="headerlink" title="洛谷P4155"></a>洛谷P4155</h2><ul>
<li>定义go[s][i]表示从第s个区间出发,走2^i个最优区间到达的区间,s和go[s][i]之间的区间也都是最优区间</li>
<li>跳板的递推计算 : go[s][i]&#x3D;go[ go[s][i-1] ] [i-1]<ul>
<li>首先从s起跳,跳到2^i-1位置,再从 2^i-1位置跳到 2^i位置,一共跳了2^i-1 + 2^i-1 步,即2^i步</li>
</ul>
</li>
<li>初始条件 go[s][0] 是使用贪心算法计算出的第一个最优位置,之后的跳板以此为基础计算</li>
</ul>
<h2 id="ST算法"><a href="#ST算法" class="headerlink" title="ST算法"></a>ST算法</h2><p>求解区间最值查询,基于 大区间的最值 等于多个小区间的最值的最值</p>
<p>分为以下步骤:</p>
<ol>
<li>把整个区间划分为很多个小区间,提前计算各小区间的最值</li>
<li>对任意区间查最值,找到覆盖它的小区间,计算小区间最值的最值</li>
</ol>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li><p>使用倍增法分组,第一组 小区间长度为1,第二组小区间长度为2…以此类推</p>
</li>
<li><p>即长度为n的数列有公有 log2 n组 </p>
</li>
<li><p>其中,每组的最值可以由前一组的最值递推而来</p>
</li>
<li><p>定义 dp[s][k]表示左端点为s,区间长度为 2^k长度的区间最值 </p>
<ul>
<li>dp[s][k]&#x3D;min(dp[s][k-1],dp[s+(1&lt;&lt;k-1)][k-1] )</li>
</ul>
</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li>查询任意区间最值只需要找到两个覆盖该区间的小区间,求该小区间的最值的最值</li>
<li>区间[L,R] 的长度len&#x3D; L-R+1,令x为小于len的2的最大倍数,如len&#x3D;19,则x&#x3D;16,k&#x3D;4;</li>
<li>res&#x3D;min(dp[L][k],dp[R-(1&lt;&lt;k)+1][k])</li>
</ul>
<h3 id="例题-P2880"><a href="#例题-P2880" class="headerlink" title="例题 P2880"></a>例题 P2880</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> num[N],lr[<span class="number">180001</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dpMax[N][<span class="number">22</span>], dpMin[N][<span class="number">22</span>];</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//长度为1的小组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		dpMax[i][<span class="number">0</span>] = num[i];</span><br><span class="line">		dpMin[i][<span class="number">0</span>] = num[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;=<span class="built_in">log2</span>(n); ++i) &#123;	<span class="comment">//倍增</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j+( <span class="number">1</span> &lt;&lt; i) &lt;= n+<span class="number">1</span>; ++j) &#123; <span class="comment">//即j+2^i-1 &lt;=n ,从1开始长度为2的区间应是 [1,2],但1+2=3，故减一</span></span><br><span class="line">			dpMax[j][i] = <span class="built_in">max</span>(dpMax[j][i - <span class="number">1</span>], dpMax[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">			dpMin[j][i] = <span class="built_in">min</span>(dpMin[j][i - <span class="number">1</span>], dpMin[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRes</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">	k = <span class="built_in">log2</span>(len);</span><br><span class="line">	<span class="type">int</span> max_ = <span class="built_in">max</span>(dpMax[l][k], dpMax[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">	<span class="type">int</span> min_ = <span class="built_in">min</span>(dpMin[l][k], dpMin[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">	<span class="keyword">return</span> max_ - min_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; lr[i][<span class="number">0</span>] &gt;&gt; lr[i][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">getRes</span>(lr[i][<span class="number">0</span>], lr[i][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="差分法"><a href="#差分法" class="headerlink" title="差分法"></a>差分法</h1><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p>差分应用于区间修改和查询问题,把给定数据集A分成多个区间,对不同区间进行多次操作,如对区间内数据进行加减操作,求操作后的数据集</p>
<p>若使用暴力法,时间复杂度为O(mn),使用差分法可以优化至O(m+n)</p>
<ul>
<li>使用两个数组: 原数组a[],差分数组 D[]</li>
<li>差分数组D[]的定义是 D[i]&#x3D;a[i]-a[i-1],可以推出 a[i]&#x3D;D[1]+D[2]+…+D[i],即原数组是差分数组的前缀和数组 <em><strong>差分是前缀和的逆运算</strong></em></li>
<li>对数组a[] 的 [L,R]区间加上一个数x<ul>
<li>D[L] +&#x3D;	x</li>
<li>D[R+1] -&#x3D; x</li>
</ul>
</li>
<li>这样使[L,R]之间的前缀和增加了x(即 a[L,R]增加了x),其他范围不受影响</li>
<li>结果数组为 a[i]&#x3D;a[i-1]+D[i] (a[i-1]即D[1]+…+D[i-1])</li>
</ul>
<h3 id="hdu1556"><a href="#hdu1556" class="headerlink" title="hdu1556"></a>hdu1556</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>]=&#123;<span class="number">0</span>&#125;,d[<span class="number">100005</span>]=&#123;<span class="number">0</span>&#125;	;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,l,r;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		d[l] += <span class="number">1</span>;</span><br><span class="line">		d[r + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		a[i] = d[i] + a[i - <span class="number">1</span>];	<span class="comment">//可以将a[]换为d[] 来节省一半的空间</span></span><br><span class="line">		cout &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一维差分数字对区间修改很高效，但对单点查询不高效</li>
</ul>
<h2 id="二维差分-上册第70页"><a href="#二维差分-上册第70页" class="headerlink" title="二维差分  上册第70页"></a>二维差分  上册第70页</h2><p><em>例： 一块n*n的格子上有m块地毯，给出地毯的信息，求每个点被几块地毯覆盖</em>  (洛谷P3397)</p>
<p>暴力求解 时间复杂度O（m*n*n）,用二维差分,时间复杂度O(m+n*n) 为最优时间复杂度 </p>
<ul>
<li><p>二维差分中,原数组a[][]是差分数组D[][]的前缀和,坐标原点(1,1)和坐标(i,j)之间每个D[][]的和为a[i][j]</p>
</li>
<li><p>可以把每个D[][]看作一个格子,所有格子的面积之和为a[][]</p>
</li>
<li><p>计算公式: <strong>D[i][j]&#x3D;a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]</strong>  因为a[i-1][j]-a[i][j-1]减去了两次a[i-1][j-1],故加上一次</p>
</li>
<li><p>区间修改:  x1,y1,x2,y2即为地毯的两个坐标</p>
<ul>
<li><strong>D[x1][y1]+&#x3D;d;</strong>	&#x2F;&#x2F;起点</li>
<li><strong>D[x1][y2+1]-&#x3D;d;</strong></li>
<li><strong>D[x2+1][y1]-&#x3D;d;</strong></li>
<li><strong>D[x2+1][y2+1]+&#x3D;d;</strong>  &#x2F;&#x2F;终点,减了两次,故加上一次</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归公式法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m,x1,y1,x2,y2;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="comment">//二维差分数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">		D[x1][y1] += <span class="number">1</span>;</span><br><span class="line">		D[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">		D[x1][y2 + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">		D[x2 + <span class="number">1</span>][y1] -= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			D[i][j] = D[i][j] + D[i - <span class="number">1</span>][j] + D[i][j - <span class="number">1</span>] - D[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">			cout &lt;&lt; D[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接计算法 不使用递推公式</span></span><br><span class="line"><span class="comment">//先累加y方向,在累加x方向即可求出前缀和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			D[i][j + <span class="number">1</span>] += D[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			D[i+<span class="number">1</span>][j] += D[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接计算与递推公式的计算量相当</li>
<li>递归公式简洁明了</li>
<li>三维差分递推公式过于复杂,使用直接计算更加方便</li>
</ul>
<h2 id="三维差分"><a href="#三维差分" class="headerlink" title="三维差分"></a>三维差分</h2><p>三维差分与二维差分类似,二维差分是面,三维差分是体</p>
<ul>
<li>三维差分的区间修改需要修改体的8个顶点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D[x1][y1][z1]+=d;</span><br><span class="line">D[x2+<span class="number">1</span>][y1][z1]-=d;</span><br><span class="line">D[x1][y2+<span class="number">1</span>][z1]-=d;</span><br><span class="line">D[x1][y1][z2+<span class="number">1</span>]-=d;</span><br><span class="line">D[x2+<span class="number">1</span>][y2+<span class="number">1</span>][z1]+=d;</span><br><span class="line">D[x2+<span class="number">1</span>][y1][z2+<span class="number">1</span>]+=d;</span><br><span class="line">D[x1][y2+<span class="number">1</span>][z2+<span class="number">1</span>]+=d;</span><br><span class="line">D[x1][y1][z1]-=d;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用直接计算法求结果数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=B;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=C;++k)&#123;</span><br><span class="line">            D[i][j][k+<span class="number">1</span>]+=D[i][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在剩下两个方向上再重复两次</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以不适用三维数组,使用一维数组存储,再定义一个函数 <code>num(x,y,z)</code>计算坐标对应的引索<ul>
<li><code>if(x&gt;A||y&gt;B||z&gt;C) return 0;</code></li>
<li><code>return ((x-1)*B+(y-1)*c+(z-1)*A);</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>随记</title>
    <url>/2023/02/27/%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="最大公约数和最大公倍数"><a href="#最大公约数和最大公倍数" class="headerlink" title="最大公约数和最大公倍数"></a>最大公约数和最大公倍数</h1><p>a,b两个数</p>
<ul>
<li>求最大公约数:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x%y!=<span class="number">0</span>):</span><br><span class="line">    z=x%y</span><br><span class="line">    x=y</span><br><span class="line">    y=z</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure>

<ul>
<li>最小公倍数 : a * b &#x3D; a,b的最小公倍数* a,b的最大公约数</li>
<li>故 最小公倍数&#x3D; (a*b)&#x2F;z</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JAVA并发</title>
    <url>/2023/03/03/java%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="进程-x2F-线程"><a href="#进程-x2F-线程" class="headerlink" title="进程&#x2F;线程"></a>进程&#x2F;线程</h1><span id="more"></span>

<p>​	一个进程有多个线程,线程是CPU执行的基础单位(最小单位),线程不能独立运行,必须依赖进程,所有线程共享进程的资源</p>
<p>​	并发量是效率,在一段时间内完成的量,并行量是指在某一时刻可以同时进行几项任务</p>
<h2 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h2><ul>
<li><p>自定义一个线程类,继承<code>Thread</code></p>
</li>
<li><p>在类中重载run()方法</p>
<ul>
<li>run()方法在线程启动后自动执行</li>
<li>run()方法执行完毕后线程自动销毁</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BallThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Graphics graphics;</span><br><span class="line">    <span class="comment">//实现线程</span></span><br><span class="line">    <span class="comment">//重新run方法:启动线程后自动执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//绘制小球</span></span><br><span class="line">        <span class="comment">//graphics.fillOval(100,100,100,100);</span></span><br><span class="line">        <span class="comment">//让小球循环画</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">400</span>;i++) &#123;</span><br><span class="line">            graphics.fillOval(<span class="number">100</span>,<span class="number">100</span>+i,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">            <span class="comment">//延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);   <span class="comment">//添加线程延迟,单位毫秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>Thread.sleep(int millis)</code>来设置线程的延时(停顿),单位为毫秒</li>
<li>通过父类方法 <code>start()</code> 启动线程</li>
</ul>
<h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><ul>
<li><p>NEW</p>
<p>尚未启动的线程处于此状态</p>
</li>
<li><p>RUNNABLE</p>
</li>
</ul>
<p>​		在Java虚拟机中执行的线程处于此状态</p>
<ul>
<li><p>BLOCKED</p>
<p>被阻塞等待监视器锁定的线程处于此状态</p>
</li>
<li><p>WAITING</p>
<p>正在等待另一个线程执行特定动作的线程处于此状态</p>
</li>
<li><p>TIMED_WAITING</p>
<p>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态(超时等待)</p>
</li>
<li><p>TERMINATED</p>
<p>已经退出的线程处于此状态</p>
</li>
</ul>
<h2 id="等待和阻塞"><a href="#等待和阻塞" class="headerlink" title="等待和阻塞"></a>等待和阻塞</h2><ul>
<li><p>等待是线程还没有被CPU调度,没有获得处理机资源的时间片,即使CPU空闲也不会被调用;</p>
</li>
<li><p>阻塞是线程无法获取到其执行需要的资源,如CPU没有空闲资源</p>
</li>
</ul>
<h2 id="使用构造方法初始化线程"><a href="#使用构造方法初始化线程" class="headerlink" title="使用构造方法初始化线程"></a>使用构造方法初始化线程</h2><ul>
<li>构造方法只执行一次,防止出现重复线程等问题</li>
<li>在构造方法中创建线程并启动,可以防止创建多个进程</li>
</ul>
<h1 id="键盘监听器"><a href="#键盘监听器" class="headerlink" title="键盘监听器"></a>键盘监听器</h1><ul>
<li><p>窗口需要获取焦点才能使用键盘监听器</p>
</li>
<li><p>获取按下的键盘按键,(控制方向移动等)</p>
</li>
</ul>
<h1 id="线程任务"><a href="#线程任务" class="headerlink" title="线程任务"></a>线程任务</h1><ul>
<li>定时线程任务,每隔一段时间自动创建对象</li>
</ul>
<h1 id="图片移动显示"><a href="#图片移动显示" class="headerlink" title="图片移动显示"></a>图片移动显示</h1><ul>
<li><p>在正坐标画图片的同时在相应的负坐标也画图</p>
</li>
<li><p><code>drawImage(image,0,y++,900,900,null);</code></p>
<p><code>drawImage(image,0,y-900,900,900,null);</code></p>
</li>
<li><p>因为y轴最大为900,所有在相应负坐标即为正坐标y-900</p>
</li>
</ul>
<h1 id="闪烁问题"><a href="#闪烁问题" class="headerlink" title="闪烁问题"></a>闪烁问题</h1><ul>
<li>闪烁问题是由于多个对象被画笔绘制,导致绘制被覆盖,一个对象没有被画完就画另一个对象</li>
<li>使用缓冲区来解决</li>
<li>创建一个BufferedImage作为缓冲区,将窗体画笔替换为缓冲区画笔,让缓冲区被绘制完成后再显示在窗体上就可以解决闪烁问题</li>
</ul>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/2023/03/17/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2/</url>
    <content><![CDATA[<h1 id="基础算法-2"><a href="#基础算法-2" class="headerlink" title="基础算法-2"></a>基础算法-2</h1><span id="more"></span>

<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p>​	在不关注数值的绝对大小而关注数据的相对大小时,将数据离散化可以把分布广而稀疏的数据转换为密集分布,从而使算法更快速,更节省空间地处理问题.</p>
<p>​	离散化的步骤: 1.排序 2.离散化 3.归位</p>
<p>使用STL进行离散化处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">100001</span>];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span>* newArr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="comment">//通过lower_bound获取递增后arr[i]的位置,该位置即为离散化后的数值</span></span><br><span class="line">		newArr[i] = <span class="built_in">lower_bound</span>(arr + <span class="number">1</span>, arr + n + <span class="number">1</span>, arr[i]) - arr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		cout &lt;&lt; newArr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要去重,可以使用unique()函数</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>​	可以直接使用STL中的排序算法 sort(),该函数的复杂度为 nlogn</p>
<h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><ul>
<li>next_permutation()函数</li>
</ul>
<p>​	返回值为bool,若没有下一个更大的排列,就返回false,若有就在原字符串中放入新的排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123; cout &lt;&lt; s &lt;&lt; endl; &#125; </span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()));</span><br><span class="line">	<span class="comment">// 将会输出 bca,cab,cba</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	若要获取全排列,先把字符串从小到大排序,然后再使用该函数.</p>
<ul>
<li>prev_permutation()</li>
</ul>
<p>​	该函数于上面函数相似,但是求前一个排列</p>
<ul>
<li>手写排列函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isVis[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myNext_permutation</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> resNum,<span class="type">int</span> totalNum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//s记录是排列中的第几个,t记录 所求排列的数组的长度</span></span><br><span class="line">	<span class="keyword">if</span> (s == resNum) &#123;</span><br><span class="line">		<span class="comment">//输出一个排列</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">			cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalNum; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isVis[i]) &#123;</span><br><span class="line">			isVis[i] = <span class="literal">true</span>;</span><br><span class="line">			b[s] = a[i];</span><br><span class="line">			<span class="built_in">myNext_permutation</span>(s + <span class="number">1</span>, resNum,totalNum);</span><br><span class="line">			isVis[i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">	<span class="comment">//前3个数中的3个数的全排列</span></span><br><span class="line">	<span class="comment">//若要取前四个数中的3个数的全排列,应为: myNext_permutation(0,3,4);</span></span><br><span class="line">	<span class="built_in">myNext_permutation</span>(<span class="number">0</span>, n,n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h2 id="分治算法的特征"><a href="#分治算法的特征" class="headerlink" title="分治算法的特征:"></a>分治算法的特征:</h2><ul>
<li>平衡子问题:分治后的子问题规模大致相同;子问题规模相同的问题处理效率高于子问题规模不等的问题</li>
<li>独立子问题:分治后的子问题相互独立,互不相干,这是区别与DP的根本特征</li>
</ul>
<p>汉诺塔问题,快速幂的一种解决方法,归并排序,快速排序都属于分支算法的应用</p>
<h2 id="逆序数问题-归并排序"><a href="#逆序数问题-归并排序" class="headerlink" title="逆序数问题(归并排序)"></a>逆序数问题(归并排序)</h2><p> 通过归并排序的合并来统计逆序数的数量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll a[N], b[N], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ll left, ll mid, ll right)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = left, j = mid + <span class="number">1</span>, temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">			b[temp++] = a[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			b[temp++] = a[j++];</span><br><span class="line">			cnt += mid - i + <span class="number">1</span>;	<span class="comment">//记录逆序数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 处理剩下的</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) b[temp++] = a[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= left) b[temp++] = b[j++];</span><br><span class="line">	<span class="comment">// 将归并好的复制回原数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; temp; ++x) &#123;</span><br><span class="line">		a[left + x] = b[x];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(ll left, ll right)</span> </span>&#123;</span><br><span class="line">	ll mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">mergeSort</span>(left, mid);</span><br><span class="line">	<span class="built_in">mergeSort</span>(mid + <span class="number">1</span>, right);</span><br><span class="line">	<span class="built_in">merge</span>(left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每交换一次相邻的逆序对就可以消去一个逆序对,从 大,中,小;大,小,中;各种情况归纳可得</span></span><br></pre></td></tr></table></figure>

<h2 id="第K大数问题-快速排序"><a href="#第K大数问题-快速排序" class="headerlink" title="第K大数问题(快速排序)"></a>第K大数问题(快速排序)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="comment">//快速排序求第 k 大数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = arr[left + (right - left) / <span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> i = left, j = right - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (arr[i] &lt; mid) ++i;</span><br><span class="line">		<span class="keyword">while</span> (arr[j] &gt; mid) --j;</span><br><span class="line">		<span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">			++i; --j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//只递归含有第k个数的部分</span></span><br><span class="line">	<span class="keyword">if</span> (left &lt;= j &amp;&amp; k &lt;= j) <span class="keyword">return</span> <span class="built_in">quickSort</span>(left, j+<span class="number">1</span>, k);</span><br><span class="line">	<span class="keyword">if</span> (i &lt; right &amp;&amp; k &gt;= i) <span class="keyword">return</span> <span class="built_in">quickSort</span>(i, right, k);</span><br><span class="line">	<span class="keyword">return</span> arr[k]; <span class="comment">//返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心与拟阵"><a href="#贪心与拟阵" class="headerlink" title="贪心与拟阵"></a>贪心与拟阵</h1><p>​	使用贪心的问题需要满足 可以从局部最优推广到全局最优,拟阵是一种评估方法,能在某些特殊情况下证明贪心法是全局最优的</p>
<p>​	局部最优不能总能导致全局最优,即使是同一个问题,参数的改变也会导致无法使用贪心算法</p>
<p>贪心算法需要满足:</p>
<ul>
<li><strong>最优子结构性质</strong>,即一个问题的最优解包含子问题的最优解,即能从局部最优扩展到全局最优</li>
<li><strong>贪心选择性质</strong>,整体的最优解可以通过对一系列子问题的最优解的选择得到</li>
</ul>
<p>即使贪心算法得不到最优解,也往往能得到十分接近最优解的<strong>近似解</strong>,如果一个问题不一定要求最优解,可以尝试贪心</p>
<h2 id="拟阵"><a href="#拟阵" class="headerlink" title="拟阵"></a>拟阵</h2><p>​	如果一个问题满足拟阵结构,那么贪心就可以得到最优解,是一个充分不必要条件</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>搜索</title>
    <url>/2023/04/01/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>BFS,DFS,剪枝,判重,最短路径dijkstra</p>
<span id="more"></span>

<h1 id="BFS和DFS基础"><a href="#BFS和DFS基础" class="headerlink" title="BFS和DFS基础"></a>BFS和DFS基础</h1><ul>
<li>BFS&#x3D;队列</li>
<li>DFS&#x3D;递归</li>
</ul>
<p>BFS使用的空间往往比DFS要大,因为出一个节点往往要向队列中加入多个节点</p>
<p>DFS使用的空间比BFS要小,但往往会搜索大量无效的节点</p>
<ul>
<li>DFS的算法往往比BFS简单,如果一道题目BFS和DFS都可以用,那么一般选择DFS</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>​	在BFS和DFS基础上,发展出了剪枝,记忆化(DFS),双向广搜(BFS),迭代加深搜索(DFS)等算法,大大提高了搜索能力</p>
<p>​	BFS的常用技巧是去重,DFS的常用技巧是剪枝</p>
<h2 id="连通性判断"><a href="#连通性判断" class="headerlink" title="连通性判断"></a>连通性判断</h2><p>​	p106,高地问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> cmap[N][N];</span><br><span class="line"><span class="type">int</span> isVis[N][N];</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	isVis[x][y] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (cmap[x][y + <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; cmap[x][y - <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span></span><br><span class="line">		&amp;&amp; cmap[x + <span class="number">1</span>][y] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; cmap[x - <span class="number">1</span>][y] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">		flag = <span class="number">1</span>;	<span class="comment">//判断是否存在高地</span></span><br><span class="line">		<span class="comment">//不能在此处返回,要把一整个岛遍历完,不然可能一个岛上有多个高地被判断为多个岛</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> newX = x + d[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> newY = y + d[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (!isVis[newX][newY]&amp;&amp;cmap[newX][newY]==<span class="string">&#x27;#&#x27;</span>) <span class="built_in">DFS</span>(newX, newY);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			cin &gt;&gt; cmap[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cmap[i][j] = <span class="string">&#x27;#&#x27;</span>&amp;&amp; !isVis[i][j]) &#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">DFS</span>(i, j);</span><br><span class="line">				<span class="keyword">if</span> (flag == <span class="number">0</span>) ++cnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><p><strong>BFS剪枝</strong></p>
<ul>
<li>BFS剪枝常使用判重,若搜索到某一层出现重复的状态就剪枝</li>
</ul>
<p><strong>DFS剪枝</strong></p>
<ul>
<li>DFS剪枝技术较多<ul>
<li>可行性剪枝: 若当前状态不符合条件就剪枝</li>
<li>搜索顺序剪枝: 不同的搜索顺序会产生不同的搜索树形态,复杂度差异也较大</li>
<li>最优性剪枝: 在最优问题中,若当前花费已超过先前搜索得到的最优解,剪枝</li>
<li>排除等效冗余: 若搜索不同分支的结果是一样的,就只搜索一个分支</li>
<li>记忆化搜索: 将已经计算的结果保存,避免重复运算</li>
</ul>
</li>
</ul>
<h2 id="BFS判重"><a href="#BFS判重" class="headerlink" title="BFS判重"></a>BFS判重</h2><h3 id="跳蚱蜢-八数码问题"><a href="#跳蚱蜢-八数码问题" class="headerlink" title="跳蚱蜢(八数码问题)"></a>跳蚱蜢(八数码问题)</h3><p>​	一个圆上有8个蚂蚱,一个空盘,蚂蚱可以跳到相邻的空盘上,或者跳过一个蚂蚱跳到距离为2的空盘上,将蚂蚱按顺时针排序,问最少调几次可以使蚂蚱的位置逆序而空盘的位置不变</p>
<ul>
<li><p>即 初始状态(化圆为线) 为 012345678,目标状态 087654321,使用广搜可以很好的解决</p>
</li>
<li><p>一个状态可以分出四个状态,要遍历所有状态以求取结果,使用树结构来实现广搜</p>
</li>
<li><p>一个裸的BFS第一步有4个状态,第二步有4*4种跳法….到第二十步时有约一万亿种跳法,因此必须剪枝,使用去重,当遇到已经遇到过的状态时就不再继续搜索</p>
</li>
<li><p>用STL 中的 map 和 set 判重,效率都很好</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string value;</span><br><span class="line">	<span class="type">int</span> depth;</span><br><span class="line">	<span class="built_in">Node</span>(string value, <span class="type">int</span> depth) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;depth = depth;</span><br><span class="line">		<span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;Node&gt; que;</span><br><span class="line">map&lt;string, <span class="type">bool</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		Node node = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//目标状态</span></span><br><span class="line">		<span class="keyword">if</span> (node.value == <span class="string">&quot;087654321&quot;</span>) &#123;</span><br><span class="line">			cout &lt;&lt; node.depth &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">			string temp;</span><br><span class="line">            <span class="comment">//找到0的位置</span></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; node.value.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (node.value[i] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//由该状态发散出的四种状态</span></span><br><span class="line">			temp = node.value;</span><br><span class="line">			<span class="built_in">swap</span>(temp[i], temp[(i + <span class="number">1</span>) % <span class="number">9</span>]);</span><br><span class="line">			<span class="keyword">if</span> (!mp[temp]) &#123;</span><br><span class="line">				que.<span class="built_in">push</span>(<span class="built_in">Node</span>(temp, node.depth + <span class="number">1</span>));</span><br><span class="line">				mp[temp] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = node.value;</span><br><span class="line">			<span class="built_in">swap</span>(temp[i], temp[(i + <span class="number">2</span>) % <span class="number">9</span>]);</span><br><span class="line">			<span class="keyword">if</span> (!mp[temp]) &#123;</span><br><span class="line">				que.<span class="built_in">push</span>(<span class="built_in">Node</span>(temp, node.depth + <span class="number">1</span>));</span><br><span class="line">				mp[temp] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = node.value;</span><br><span class="line">			<span class="built_in">swap</span>(temp[i], temp[(i - <span class="number">1</span> + <span class="number">9</span>) % <span class="number">9</span>]);</span><br><span class="line">			<span class="keyword">if</span> (!mp[temp]) &#123;</span><br><span class="line">				que.<span class="built_in">push</span>(<span class="built_in">Node</span>(temp, node.depth + <span class="number">1</span>));</span><br><span class="line">				mp[temp] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = node.value;</span><br><span class="line">			<span class="built_in">swap</span>(temp[i], temp[(i - <span class="number">2</span> + <span class="number">9</span>) % <span class="number">9</span>]);</span><br><span class="line">			<span class="keyword">if</span> (!mp[temp]) &#123;</span><br><span class="line">				que.<span class="built_in">push</span>(<span class="built_in">Node</span>(temp, node.depth + <span class="number">1</span>));</span><br><span class="line">				mp[temp] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="string">&quot;012345678&quot;</span>, <span class="number">0</span>));</span><br><span class="line">	<span class="built_in">BFS</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="综合剪枝"><a href="#综合剪枝" class="headerlink" title="综合剪枝"></a>综合剪枝</h2><pre><code> 某些题目中需要用到多种剪枝手段
</code></pre>
<ul>
<li>奇偶判断 p115页<ul>
<li>一种搜索特定步数时的剪枝手段</li>
<li>曼哈顿距离可以用于奇偶判断</li>
</ul>
</li>
</ul>
<h1 id="最短路径Dijkstra"><a href="#最短路径Dijkstra" class="headerlink" title="最短路径Dijkstra"></a>最短路径Dijkstra</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2999999</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="comment">//边类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> from, to;</span><br><span class="line">	ll value;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="type">int</span> from, <span class="type">int</span> to, ll value) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;from = from;</span><br><span class="line">		<span class="keyword">this</span>-&gt;to = to;</span><br><span class="line">		<span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	ll minDis;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> id, <span class="type">int</span> minDis) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">		<span class="keyword">this</span>-&gt;minDis = minDis;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node&amp; a) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;minDis &gt; a.minDis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存储图</span></span><br><span class="line">vector&lt;Edge&gt; edges[N];</span><br><span class="line"><span class="comment">//存储所有点到起点的距离</span></span><br><span class="line">ll allDis[N];</span><br><span class="line"><span class="comment">//标志该点已找到最短路径</span></span><br><span class="line"><span class="type">bool</span> isDone[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; smallHeap;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		allDis[i] = INF;</span><br><span class="line">		isDone[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	allDis[start] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入第一个点</span></span><br><span class="line">	smallHeap.<span class="built_in">push</span>(<span class="built_in">Node</span>(start, allDis[start]));</span><br><span class="line">	<span class="keyword">while</span> (!smallHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		Node node = smallHeap.<span class="built_in">top</span>();</span><br><span class="line">		smallHeap.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">//是否被遍历过,即是否找到最短路径</span></span><br><span class="line">		<span class="keyword">if</span> (isDone[node.id]) <span class="keyword">continue</span>;</span><br><span class="line">		isDone[node.id] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edges[node.id].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge edge = edges[node.id][i];</span><br><span class="line">			<span class="keyword">if</span> (isDone[edge.to]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//是否更新</span></span><br><span class="line">			<span class="keyword">if</span> (allDis[edge.to] &gt; node.minDis + edge.value) &#123;</span><br><span class="line">				allDis[edge.to] = node.minDis + edge.value;</span><br><span class="line">				smallHeap.<span class="built_in">push</span>(<span class="built_in">Node</span>(edge.to, allDis[edge.to]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m,u,v,w;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		edges[u].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v,w));</span><br><span class="line">		<span class="comment">//若为无方向图</span></span><br><span class="line">		<span class="comment">//edges[v].push_back(Edge(v, u, w));</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dijkstra</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (allDis[i] == INF) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; allDis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2023/04/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><span id="more"></span>

<h2 id="效用"><a href="#效用" class="headerlink" title="效用"></a>效用</h2><p>​	线程池可以提高性能,在系统启动时创建大量空闲的线程,再将任务传入线程池,线程池就会启动一个线程来执行该任务,执行结束后该线程不会被消亡,而是返回线程池,重回空闲状态,等待执行下一个任务.</p>
<ul>
<li><p>线程池可以降低资源消耗,避免了创建和销毁线程时造成的消耗</p>
</li>
<li><p>线程池可以提高响应速度,因为任务不需要等待线程被创建</p>
</li>
<li><p>线程池可以提高线程的可管理性,可以对线程进行统一的分配,调优,监控和管理</p>
</li>
</ul>
<h2 id="模拟线程池"><a href="#模拟线程池" class="headerlink" title="模拟线程池"></a>模拟线程池</h2><p>​	创建一个线程池类,作为线程池,包括构造方法和任务提交方法</p>
<ul>
<li>线程池中创建两个ArrayList,workThreadList 存储用于执行提交任务的线程,runnableList存储提交到线程池中待执行的任务,执行任务时从runnableList中取出最前端的任务并使用workThreadList中的线程执行提取出的任务的run方法.</li>
<li>线程池初始化时指定核心线程个数,创建相应数量的线程加入到workThreadList中并启动这些线程,并传入runnableList以获取任务以及作为监视器</li>
<li>提交任务方法execute方法用于将任务提交到线程池,使用同步代码块(因为需要调用runnableList的notify方法)以runnableList作为监视器,提交任务后执行runnableList的notify()方法,唤醒一个上述创建的以runnableList作为监视器的workThrad,启动任务执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">// 保存的核心线程</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;WorkThread&gt; workThreadList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WorkThread&gt;();</span><br><span class="line">    <span class="comment">// 提交到线程池的线程</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Runnable&gt; runnableList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Runnable&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> core)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程对象(执行任务的线程)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;core;i++)&#123;</span><br><span class="line">            WorkThread wt=<span class="keyword">new</span> <span class="title class_">WorkThread</span>(runnableList);</span><br><span class="line">            workThreadList.add(wt);</span><br><span class="line">            <span class="comment">// 启动线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(wt).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提交任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable runnable)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList)&#123;</span><br><span class="line">            runnableList.add(runnable);</span><br><span class="line">            <span class="comment">//提交后唤醒</span></span><br><span class="line">            runnableList.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	创建线程池中运行的线程,即核心线程,用于执行提交到线程池的任务</p>
<ul>
<li>核心线程的run方法需要设置while(true)循环,使核心线程不被销毁,能够正常处理提交的任务</li>
<li>使用同步代码块保护来对线程池的runnableList进行操作,并以runnableList作为同步代码块的监视器</li>
<li>如果任务列表为空,则通过runnableList使当前核心线程进入等待状态,直到提交任务时被唤醒</li>
<li>应该注意:线程唤醒后是从进入等待的位置继续执行代码,若使用if判断任务列表是否为空时,在从runnableList中提取任务时应再次判断任务列表中是否有任务,因为从唤醒线程到执行任务提取直接可能有其他线程已对runnableList进行操作,可能会出现执行到提取任务时任务列表为空的情况</li>
<li>使用while(runnableList&lt;&#x3D;0)来使线程进入等待,可不用再次判断任务列表中是否有任务</li>
<li><strong>同步代码块应只保护对runnableList的操作,对任务的执行不能处于同步代码块内</strong>,否则核心线程对任务的执行不是并发进行的,使线程池失去意义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Runnable&gt; runnableList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WorkThread</span><span class="params">(ArrayList&lt;Runnable&gt; runnableList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.runnableList = runnableList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不断执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">                <span class="comment">//如果没有任务就进入等待</span></span><br><span class="line">                <span class="keyword">if</span>(runnableList.size() &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        runnableList.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在线程中直接执行任务的run()方法,不需要再创建线程</span></span><br><span class="line">                <span class="keyword">if</span>(runnableList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> runnableList.remove(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	以及主函数和测试任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">DoThread</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoThread</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.idx = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;待处理任务&quot;</span>+idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>​	Java中的线程池</p>
<ul>
<li>构造方法 <code>ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize, long keepAliveTime, Runnable&gt; workQueue)</code><ul>
<li>corePoolSize 线程池大小,对于上面的核心线程数</li>
<li>maximumPoolSize 最大线程池大小,当阻塞队列已满时向线程池中创建更多的线程(大于corePoolSize),最多不超过maximumPoolSize,来执行更多的任务;新创建的线程不会在阻塞队列未满时就被消耗,而是一直被分配任务,直到阻塞队列中的任务数量不足以给每一个线程都分配任务</li>
<li>keepAliveTime 线程存活时间,当线程池为执行更多任务而创建的线程(即超出corePoolSize的线程),在持续keepAliveTime时间没有被分配任务后销毁</li>
<li>workQueue 阻塞队列,用于存储提交到线程池的任务</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全</title>
    <url>/2023/04/01/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><span id="more"></span>

<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>​	在多个线程对同一个变量进行更改时,可能会导致线程对该变量的更改和读取出现错误,出现线程不安全</p>
<p>​	通过添加监听器或加锁的方式,限定变量同一时间只能被一个线程修改</p>
<h2 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1. 同步代码块"></a>1. 同步代码块</h2><p>​	使用synchronized(){} 方法同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(监视器(对象锁))&#123;</span><br><span class="line">    需要同步代码...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任何一个对象都可以作为监视器(锁)使用,且要保证并发线程使用的监视器是同一个对象</span></span><br></pre></td></tr></table></figure>

<p><strong>任何一个对象都可以作为监视器,无论是专门创建的,还是有其他用途的对象,但必须要保证唯一性</strong></p>
<p>使用wait()和notify()时，要通过监视器调用这些方法。</p>
<h2 id="2-同步方法"><a href="#2-同步方法" class="headerlink" title="2.同步方法"></a>2.同步方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法的监视器对象是 本类对象 <strong>this</strong> ,且不可修改8</p>
<h2 id="3-lock"><a href="#3-lock" class="headerlink" title="3.lock"></a>3.lock</h2><p> 使用Lock锁来控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;++i) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;该线程开始时的票数:&quot;</span> 					+ ticket.ticket);</span><br><span class="line">                sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            ticket.ticket -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="生产消费模型"><a href="#生产消费模型" class="headerlink" title="生产消费模型"></a>生产消费模型</h1><p>​	 对于一个频繁使用的线程,在不需要使用它时不应该直接终止该线程,而应该让线程挂起,使用wait()方法,不然会大量增减消耗</p>
<p>​	调用wait()的方法,必须跟监视器监听的对象一致,否则会陷入死锁</p>
<h1 id="使用Lock对生成消费模型进行并行控制"><a href="#使用Lock对生成消费模型进行并行控制" class="headerlink" title="使用Lock对生成消费模型进行并行控制"></a>使用Lock对生成消费模型进行并行控制</h1><ul>
<li><p>获取某个监视器的lock锁作为线程的锁,监视器应该是同一个,如使用仓库对象作为消费和生成线程的监视器</p>
</li>
<li><p>获取lock()锁的condition组件,用于线程的等待和唤醒</p>
</li>
<li><p>线程运行时应设置一个间隔,使其他线程可以获取到锁,避免一个线程一直运行,其他线程无法获取到锁</p>
</li>
<li><p>使用condition.await()使当前线程进入等待队列,使用condition.signal()唤醒等待队列中首个(等待时间最长)的线程</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Warehouse wh;</span><br><span class="line">    String name=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">    <span class="keyword">public</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Warehouse wh,String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wh = wh;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line">        lock=wh.lock;</span><br><span class="line">        <span class="built_in">this</span>.condition = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">produce</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr=wh.goods;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr.size()&lt;<span class="number">30</span>)&#123;</span><br><span class="line">                System.out.println(name+<span class="string">&quot;  生产:&quot;</span>+ (++wh.lastGood));</span><br><span class="line">                arr.add(wh.lastGood);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">// 仓库满则进入休眠</span></span><br><span class="line">                <span class="keyword">if</span>(wh.goods.size()&gt;=<span class="number">30</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;  生产前的仓库存储量:&quot;</span> + wh.goods.size());</span><br><span class="line">                <span class="comment">//生产</span></span><br><span class="line">                <span class="keyword">if</span>(produce())&#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;  生产后的仓库存储量:&quot;</span> + wh.goods.size());</span><br><span class="line">                    condition.signal();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;仓库已满&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Warehouse wh=<span class="keyword">new</span> <span class="title class_">Warehouse</span>();</span><br><span class="line">    String name=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">    <span class="keyword">public</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Warehouse wh,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.wh = wh;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        lock=wh.lock;</span><br><span class="line">        <span class="built_in">this</span>.condition=lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr=wh.goods;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;  消费:&quot;</span>+arr.get(<span class="number">0</span>));</span><br><span class="line">        arr.remove(<span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">// 若仓库为空,挂起</span></span><br><span class="line">                <span class="keyword">if</span>(wh.goods.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                        System.out.println(name+<span class="string">&quot;  进入等待&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;  消费前的仓库存储量:&quot;</span> + wh.goods.size());</span><br><span class="line">                <span class="comment">//消费</span></span><br><span class="line">                consume();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;  消费后的仓库存储量:&quot;</span> + wh.goods.size());</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Warehouse wh=<span class="keyword">new</span> <span class="title class_">Warehouse</span>();</span><br><span class="line">        Lock lock=wh.lock;</span><br><span class="line">        Condition condition=lock.newCondition();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(wh,<span class="string">&quot;Producer1&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(wh,<span class="string">&quot;Consumer1&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(wh,<span class="string">&quot;Consumer2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer1.start();</span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Warehouse wh=<span class="keyword">new</span> <span class="title class_">Warehouse</span>();</span><br><span class="line">        Lock lock=wh.lock;</span><br><span class="line">        Condition condition=lock.newCondition();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(wh,<span class="string">&quot;Producer1&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(wh,<span class="string">&quot;Consumer1&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(wh,<span class="string">&quot;Consumer2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer1.start();</span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS</title>
    <url>/2023/05/14/HTTPS/</url>
    <content><![CDATA[<p>HTTPS的实现,混合加密,数字签名,数字证书,TLS握手,数字证书校验和HTTPS安全性</p>
<span id="more"></span>

<h1 id="HTTPS与HTTP"><a href="#HTTPS与HTTP" class="headerlink" title="HTTPS与HTTP"></a>HTTPS与HTTP</h1><p>HTTPS在HTTP基础上发展而来,通过在HTTP和TCP网络层之间加入<strong>SSL&#x2F;TLS</strong>安全协议,解决了HTTP的三大风险</p>
<ul>
<li>信息加密:将信息加密,解决窃听风险;</li>
<li>校验机制:验证报文是否被篡改,解决篡改风险</li>
<li>身份证书:验证通信双方身份,解决伪装风险</li>
</ul>
<h1 id="HTTPS的实现"><a href="#HTTPS的实现" class="headerlink" title="HTTPS的实现"></a>HTTPS的实现</h1><h2 id="1-混合加密"><a href="#1-混合加密" class="headerlink" title="1.混合加密"></a>1.混合加密</h2><p>通信建立前使用非对称加密,通过公钥,私钥进行加密通信交换密钥</p>
<p>通信建立后使用对称加密,通过密钥加密通信</p>
<p>非对称加密速度慢,但可以安全交换密钥,对称加密速度快但无法安全交换密钥,因此使用混合加密模式</p>
<h2 id="2-摘要算法-amp-数字签名"><a href="#2-摘要算法-amp-数字签名" class="headerlink" title="2. 摘要算法&amp;数字签名"></a>2. 摘要算法&amp;数字签名</h2><p>​	在传输信息时,通过<strong>摘要算法</strong>(哈希算法),计算出内容的哈希值,一起发送,接收后次计算哈希值并比较便可确定内容是否遭到篡改,哈希值唯一且无法推导出内容;但不能保证 <strong>哈希值和内容一同被篡改</strong></p>
<p>​	非对称加密中,公钥加密,私钥解密用于保证传输内容安全,而私钥加密,公钥解密用于验证身份;</p>
<p>​	因为可以用公钥解密就证明该信息的来源拥有私钥,数字签名算法就通过私钥加密,公钥解密来实现,但只加密哈希值而不加密内容,因为消耗较大.在建立通信后服务器会将公钥发给客户端,然后服务器用私钥加密,就可以确定信息来自服务器;</p>
<p>​	但可能会遇到伪造公钥和密钥,即消息来源身份不确定,这时需要用到数字证书</p>
<h2 id="3-数字证书"><a href="#3-数字证书" class="headerlink" title="3.数字证书"></a>3.数字证书</h2><p>​	数字证书唯一,由CA(数字证书认证机构)颁发,只要证书是可信的,公钥和私钥就是可信的,即通过数字证书验证公钥和私钥是否被伪造</p>
<p>​	本质还是数字签名算法,由CA持有私钥并颁发公钥,不同的是CA颁发的公钥已事先存储在客户端中,不会在通信过程中被篡改</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/HTTPS%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81.png"></p>
<h1 id="HTTPS连接流程"><a href="#HTTPS连接流程" class="headerlink" title="HTTPS连接流程"></a>HTTPS连接流程</h1><p>​	基于RSA算法的TLS握手流程图:</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/RSA%E6%8F%A1%E6%89%8B.jpg"></p>
<p>​	过程中一共生成三个随机数:Client Random、Server Random、pre-master key,客户端和服务端会使用这三个随机数,使用双方协商的加密算法算出会话密钥;最后服务器向客户端发送消息,表示之后的信息都使用会话密钥加密</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>​	RSA算法存在前向安全的问题,若服务器的私钥丢失,则过去被截取的所有TLS密文都会被破解,对此,出现了<code>ECDHE</code>密钥协商算法,目前大多数网站都使用该算法</p>
<h2 id="校验数字证书"><a href="#校验数字证书" class="headerlink" title="校验数字证书"></a>校验数字证书</h2><ul>
<li>证书签名</li>
</ul>
<p>​	证书分为两部分,第一部分为证书的内容,包含持有者的公钥,用途,有效时间等信息,然后通过哈希算法将这些信息计算出一个哈希值,再使用CA的密钥将哈希值加密,添加到证书中,即为证书的第二部分</p>
<ul>
<li>校验证书</li>
</ul>
<p>​	客户端收到后,使用相同的哈希算法将证书的内容计算出一个哈希值,再使用CA的公钥解密证书中的哈希值,两者相同则证书可信,反之证书不可信</p>
<ul>
<li>证书信任链</li>
</ul>
<p>​	客户端收到证书后,会找到该证书的签发者,若签发者不是根证书,就接着向上找,直到找到根证书,即自签证书,然后根证书验证下级证书,依次进行,直到验证到本次的证书,形成一个证书信任链</p>
<p>​	这么做的目的是严格隔离根证书,防止根证书被修改,一旦根证书失效,整个信任链都会出现问题</p>
<h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><p>​	TLS实现上分为TLS握手协议和TLS记录协议,后者保护数据,验证其完整性和来源</p>
<p>​	消息会被分成多个片段,对每个片段进行压缩并附上消息认证码(MAC值,哈希算法生成),目的是保证完整性和防止被修改,然后对压缩片段和MAC进行加密,头部附上信息,然后发送出去</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/HTTPS%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7.jpg"></p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p><strong>HTTPS是否完全安全可靠?</strong></p>
<p>有一个中间人服务器,它与客户端完成TLS握手,然后再与原目标服务器完成TLS握手</p>
<p>​	在这种情况下,中间人服务器可以获取到并解密客户端发送的消息,也可以获取到并解密服务器发送的消息,但发生这种情况前提是客户端接受中间人的证书,因为中间人服务器无法获取服务器的私钥,无法去CA获取签名证书,只能伪造证书,这时浏览器会提示证书不可信,只要不接受该证书,信息就不会被泄露</p>
<p>​	不信任中间人证书是一种方法,另一种是HTTPS双向验证,即服务器也验证客户端的身份</p>
<p>​	HTTPS协议到目前位为止不存在任何漏洞,被中间人攻击是利用了客户端漏洞(信任中间人证书或被恶意导入伪造的根证书)</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP基本概念</title>
    <url>/2023/05/13/HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>​	HTTP基本概念,GET与POST,HTTP缓存,HTTP特性,HTTP性能</p>
<span id="more"></span>

<h1 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h1><p>​	HTTP,即超文本传输协议,HyperText Transfer Protocol.	“文本”的含义包括文字,图片,视频,压缩包等,而”超文本”,即文字,图片,视频等的混合体,最重要的是具有超链接,可以从一个超文本跳转到另一个超文本</p>
<h3 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h3><p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.jpg"></p>
<h3 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h3><ul>
<li><code>host</code>字段,指定服务器的域名,如Host:<a href="http://www.baidu.com/">www.baidu.com</a></li>
<li><code>Content-Length</code>字段,表明服务器返回数据的长度,用于表示数据的边界,防止TCP粘包</li>
<li><code>Connection</code>字段,用于使用长连接时,为兼容老版本HTTP,首部字段值应为Keep-Alive</li>
<li><code>Content-Type</code>字段,表明返回数据的格式</li>
<li><code>Accept</code>字段,客户端请求时表明可以接收的数据格式</li>
<li><code>Content-Encoding</code>字段,表明返回数据的压缩格式,对应<code>Accept-Encoding</code></li>
</ul>
<h1 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h1><ul>
<li><code>GET</code>的语义是:从服务器获取指定的资源,GET参数一般在URL中,URL只支持ASCII且限制长度</li>
<li><code>POST</code>的语义是:根据请求的负荷(报文body)对指定的资源作出修改,如提交一个评论,将评论内容放在报文body中发送给服务器,服务器生成相应的评论</li>
</ul>
<p>上面对于GET和POST是根据RFC规范分析的,实际开发中可能不遵循RFC规范,使用GET实现POST的功能或使用POST实现GET的功能</p>
<h3 id="安全和幂等"><a href="#安全和幂等" class="headerlink" title="安全和幂等"></a>安全和幂等</h3><ul>
<li>安全:请求方法不会有破坏服务器上资源的可能</li>
<li>幂等:多次相同操作的结果相同</li>
</ul>
<p>​	对于GET,由于是只读,因此是安全且幂等的;对于POST,由于会修改服务器上的资源,因此是不安全的,由于多次提交会创建多个相同的资源,因此不是幂等的.</p>
<h1 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h1><p>HTTP缓存有两种方式,分别是<strong>强制缓存</strong>和<strong>协商缓存</strong></p>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><ul>
<li><p>强制缓存由浏览器判断缓存是否过期,由浏览器决定是否使用本地缓存</p>
</li>
<li><p>强制缓存利用HTTP相应头部<code>Cache-Control</code>字段和<code>Expires</code>字段判断是否过去,前者是相对时间,后者是绝对时间,且Cache-Control优先级高于Expires</p>
</li>
<li><p>当浏览器再次请求时,根据请求时间和Cache-Control中设置过期时间计算,若没有过期则使用本地缓存,否则重新请求服务器,并重置Cache-Control和Expires</p>
</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><blockquote>
<p>当强制缓存失效时使用协商缓存</p>
</blockquote>
<p>​	当服务器返回码为304时,代表可以使用本地缓存</p>
<p>​	协商缓存可以通过两种方式实现:<code>If-Modified-Since</code>和<code>Last-Modified</code> ; <code>If-None-Match</code>与<code>ETag</code> ;两种字段组合,前一个是请求头字段,后一个是响应头字段</p>
<ul>
<li>第一种方法实现:请求时带上<code>If-Modified-Since</code>和<code>Last-Modified</code>,服务器接受到<code>If-Modified-Since</code>时,判断<code>Last-Modified</code>,若服务器最新的修改时间大于请求的最后修改时间,返回最新资源,反之使用本地缓存</li>
<li>第二种方法实现:若本地获取到的资源有ETag字段,再次请求时把<code>If-None-Match</code>设置为ETag的值,服务器比较ETag的值是否发生改变,若改变就返回最新资源,没有改变就使用本地缓存</li>
</ul>
<p>​	第一种方法是基于时间实现,第二章方法是基于唯一表示实现,相对来说后者更加可靠,避免修改时间带来的错误.因此ETag优先级更高,当<strong>请求时</strong>同时使用了这两种方法,服务器会在先判断ETag,ETag相同才会判断Last-Modified.</p>
<p><strong>ETag可以解决Last-Modified出现的问题:</strong></p>
<ol>
<li>没有修改文件内容,但文件最后修改时间改变</li>
<li>修改文件的时间粒度可能是秒以下,但Last-Modified的粒度是秒</li>
<li>服务器可能获取不到文件的精确修改时间</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/HTTP%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B.jpg"></p>
<h1 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h1><p>​	HTTP有版本1.1,2.0,3.0,不同版本的特性不同</p>
<h2 id="HTTP-x2F-1-1特性"><a href="#HTTP-x2F-1-1特性" class="headerlink" title="HTTP&#x2F;1.1特性"></a>HTTP&#x2F;1.1特性</h2><h3 id="HTTP-x2F-1-1最突出的优点是"><a href="#HTTP-x2F-1-1最突出的优点是" class="headerlink" title="HTTP&#x2F;1.1最突出的优点是:"></a>HTTP&#x2F;1.1最突出的优点是:</h3><ol>
<li>简单:报文格式是简单的文本格式</li>
<li>灵活和易于拓展:各种请求方法,URL等每个组成的要求不固定,可根据情况改变</li>
<li>应用广泛和跨平台</li>
</ol>
<h3 id="HTTP-x2F-1-1的缺陷"><a href="#HTTP-x2F-1-1的缺陷" class="headerlink" title="HTTP&#x2F;1.1的缺陷:"></a>HTTP&#x2F;1.1的缺陷:</h3><ol>
<li><p>无状态:无状态可以节省空间和服务器的负担,但面对有关联的操作非常麻烦,无法记录用户信息等,可以用Cookie技术解决,Cookie由服务器生成,客户端保存,发送请求时附带Cookie来识别身份</p>
</li>
<li><p>明文传输:明文传输使内容可以直接被人识别,方便调试,但所有内容都无隐私可言</p>
</li>
<li><p>不安全:不安全有三个方面</p>
<ul>
<li><p>使用明文通信,信息会泄露</p>
</li>
<li><p>不验证通信双方身份,可能遭遇伪装</p>
</li>
<li><p>无法验证报文完整性,内容可能遭到篡改</p>
</li>
</ul>
</li>
</ol>
<h3 id="HTTP-x2F-1-1性能"><a href="#HTTP-x2F-1-1性能" class="headerlink" title="HTTP&#x2F;1.1性能"></a>HTTP&#x2F;1.1性能</h3><p>HTTP使用TCP&#x2F;IP,使用<strong>请求-应答</strong>的通信方式</p>
<ol>
<li>长连接:减少TCP重复建立连接的消耗,减轻服务器负担;特点是必须双方都明确提出断开连接才断开,但当长连接长时无数据交互,服务端会主动断开</li>
<li>管道网络传输:可以发送多个请求不必等待前一个请求响应,减少整体的响应时间;HTTP&#x2F;1.1解决了请求的队头阻塞但没有解决响应的队头阻塞,处理某个请求时,服务器会阻塞后续请求</li>
<li>队头阻塞:一个请求被阻塞,后续所有请求都被阻塞</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>RSA,ECDHE</title>
    <url>/2023/05/21/RSA,ECDHE/</url>
    <content><![CDATA[<p>​	RSA是HTTPS下层TLS&#x2F;SSL握手过程中的一种密钥交换算法,用于交换会话用于对称加密的密钥</p>
<p>​	ECDHE支持前向保密,目前被广泛使用</p>
<span id="more"></span>

<h1 id="RSA四次握手"><a href="#RSA四次握手" class="headerlink" title="RSA四次握手"></a>RSA四次握手</h1><h2 id="1-第一次握手"><a href="#1-第一次握手" class="headerlink" title="1.第一次握手"></a>1.第一次握手</h2><p>​	客户端首先发送一个”Client Hello” 消息,包括客户端使用的TLS版本号,支持的密码套件和生成的随机数(Client Random),该随机数会被服务器保存用于生成密钥</p>
<h2 id="2-第二次握手"><a href="#2-第二次握手" class="headerlink" title="2.第二次握手"></a>2.第二次握手</h2><ul>
<li><p>服务器受到消息后确认TLS版本是否支持,从客户端密码套件中选取一个,以及生成随机数(Server Random)</p>
</li>
<li><p>服务器返回”Server Hello”消息,包括服务器确认的TLS版本号,服务器生成的随机数,和选取的密码套件</p>
</li>
<li><p>为了证明身份,服务器会发送”Server Certificate”给客户端,包含服务器的<strong>数字证书</strong></p>
</li>
<li><p>最后发送”Server Hello Done”消息,告知消息发送完毕</p>
</li>
</ul>
<p>当课后端收到响应后,会首先验证数字证书(这个过程在前文有详细解释),<strong>证书通过后才进行第三次握手</strong></p>
<h2 id="3-第三次握手"><a href="#3-第三次握手" class="headerlink" title="3.第三次握手"></a>3.第三次握手</h2><p>​	客户端生成一个新的随机数(pre-master),使用服务器的RSA公钥加密该随机数,通过”Client Key Exchange”消息传给服务器,服务器使用RSA私钥解密</p>
<p>​	此时服务器和客户端都共享了三个随机数,Client Random,Server Random和pre-master,根据这三个随机数,生成会话密钥,用于对称加密</p>
<p>​	生成密钥后,客户端发送”Change Cipher Spec”,通知服务器开始使用密钥加密</p>
<p>​	客户端再发送一个”Encrypted Handshake Message(Finished)”,将之前发送的数据做个摘要,再使用会话密钥加密,让服务器验证之前的握手信息是否被篡改以及加密会话是否可用</p>
<h2 id="4-第四次握手"><a href="#4-第四次握手" class="headerlink" title="4.第四次握手"></a>4.第四次握手</h2><p>​	服务器同样发送,”Change Cipher Spec”和”Encrypted Handshake Message(Finished)”,若没有双方都验证加密和解密没有问题,握手完成</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>​	RSA密钥协商算法不支持<strong>前向保密</strong></p>
<p>​	客户端传递的随机数使用服务器公钥加密,若服务器私钥泄露,被第三方截取的TLS密文都会被破解</p>
<h1 id="ECDHE协商算法"><a href="#ECDHE协商算法" class="headerlink" title="ECDHE协商算法"></a>ECDHE协商算法</h1><p>​	ECDHE算法由DH算法演化而来,为非对称加密算法,核心数学思想是离散对数</p>
<h2 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h2><p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.jpg"></p>
<p>​	直到底数a,模数p和对数i,可以很容易计算出真数b,反过来真数很难推导出对数,特别是当P是一个很大的质数,即使知道a,b,以目前计算机的能力,几乎无法计算出离散对数,这就是DH算法的数学基础</p>
<h2 id="DH算法交换密钥"><a href="#DH算法交换密钥" class="headerlink" title="DH算法交换密钥"></a>DH算法交换密钥</h2><ul>
<li><p>双方生成各自的随机数(私钥)a,b,公开参数P,G分别是模数和底数,然后生成公钥</p>
</li>
<li><p>A的公钥为G^a(mod P),B的公钥是G^b(mod P),A,B也是公开的</p>
</li>
<li><p>此时A执行 B^a(mod P) 得到k等于B执行 A^b(mod P),这个k便可以作为会话密钥</p>
</li>
</ul>
<p>双方公开了A,B,P,G,但a,b不参与交换,无法被第三方获取,而通过A,B,P,G几乎不可能计算出私钥(a,b),因此DH密钥交换是安全的</p>
<h2 id="DHE"><a href="#DHE" class="headerlink" title="DHE"></a>DHE</h2><p>​	DH算法根据私钥的生成方式,分为static DH和DHE算法,前者的服务器公钥是不变的,第三方可以根据海量密钥协商过程暴力破解服务器的私钥,造成信息泄露,不具备前向安全性</p>
<p>​	目前常用为DHE算法,使双方在每次会话时生成的私钥都是随机的临时的,即使一次会话密钥被破解,也不影响其他会话,保证了前向安全性</p>
<h1 id="ECDHE"><a href="#ECDHE" class="headerlink" title="ECDHE"></a>ECDHE</h1><p>​	由于DHE算法效率不高,需要大量乘法,ECDHE利用ECC椭圆曲线的特定,用更少的计算量计算出公钥和会话密钥</p>
<p>ECDHE协商算法的TLS同样是四次握手</p>
<p>​	但是使用ECDHE,在TLS四次握手结束之前,客户端就已经发送了加密HTTP数据,而对于RSA必须完成四次TLS握手才能发送加密应用数据</p>
<p>​	ECDHE相比RSA省去了一个消息往返的时间,称为”TLS False Start”,提高了传输效率</p>
<h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p>​	发送”Client Hello”,包括客户端的TLS版本号,支持的密码套件,随机数Client Random</p>
<h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p>​	服务器返回”Server Hello”,包括服务器确认的TLS版本号,随机数Server Hello,和从客户端密码套件中选取的密码套件;发送”Certificate”,表明自己的身份,发送证书,因为使用ECDHE,所以发送完证书后发送”Server Key Exchange”消息:</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/ECDHE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p>
<p>​	最后是”Server Hello Done”,表明结束本次握手</p>
<p>​	至此,服务器和客户端通过明文共享了<strong>Client Random,Server Random,使用的椭圆曲线,椭圆曲线基点G,服务器椭圆曲线的公钥</strong>,这些信息将用于生成会话密钥</p>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p>​		客户端验证服务器身份是否可信,接着生成客户端的椭圆曲线公钥,用”Client Key Exchange”发送给服务器,此时双方共享:各自的椭圆曲线公钥私钥,椭圆曲线基点G,于是双方可以计算出点(x,y),最终会话密钥为:客户端随机数+服务器随机数+x;</p>
<p>​	算好密钥后,客户端发送”Change Cipher Spec”消息,告诉服务器后续使用密钥加密</p>
<p>​	再发送”Encrypted Handshake Message”,将之前的信息做个摘要,在使用对称加密让服务器验证加密是否可用</p>
<h3 id="第四次握手"><a href="#第四次握手" class="headerlink" title="第四次握手"></a>第四次握手</h3><p>​	服务器操作与第三次握手时客户端操作一致,发送”Change Cipher Spec”和”Encrypted Handshake Message”,如果双方都验证加密和解密没有问题,握手就正式完成</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/RSA%E5%92%8CECDHE%E5%8C%BA%E5%88%AB.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP演变和优化</title>
    <url>/2023/05/17/HTTP%E6%BC%94%E5%8F%98/</url>
    <content><![CDATA[<p>HTTP&#x2F;1.1,HTTP&#x2F;2,HTTP&#x2F;3</p>
<span id="more"></span>

<h1 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h1><p>​	相对于HTTP&#x2F;1.0使用长连接和管道传输</p>
<p>​	存在的性能瓶颈:</p>
<ul>
<li>头部不压缩,只压缩Body,首部信息越大延迟越大</li>
<li>发送重复的头部信息浪费大</li>
<li>存在响应的队头阻塞</li>
<li>没有请求优先级</li>
<li>请求只能由客户端发出,服务器只能被动响应</li>
</ul>
<h1 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h1><p>HTTP&#x2F;2.0基于HTTPS</p>
<h2 id="相对于HTTP-x2F-1-1"><a href="#相对于HTTP-x2F-1-1" class="headerlink" title="相对于HTTP&#x2F;1.1"></a>相对于HTTP&#x2F;1.1</h2><ul>
<li>头部压缩</li>
</ul>
<p>​	若同时发送多个请求且头部一样或相似,HPACK算法消除重复的部分,在客户端和服务器维护一张头信息表,发送引索来提高速度</p>
<ul>
<li>二进制格式</li>
</ul>
<p>​	报文使用二进制格式,统称为帧,分为头信息帧和数据帧</p>
<ul>
<li>并发传输</li>
</ul>
<p>​	引入Stream概念,解决了响应的队头阻塞,1个TCP连接包括多个Stream,Stream中包含多个Message,不同的Stream帧可以乱序发送,接受端根据Stream ID来组合为完整信息,HTTP&#x2F;2可以并行交错地发送请求和响应</p>
<ul>
<li>服务器可主动推送资源</li>
</ul>
<p>​	服务器和客户端都可建立Stream,服务器的Stream ID必须是偶数,客户端必须是奇数;若客户端请求一个HTML文件,但需要CSS文件来渲染,使用HTTP&#x2F;2.0就不需要再发送一次请求获取CSS,服务器主动发送CSS文件,提高效率</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>​	HTTP&#x2F;2.0解决了HTTP&#x2F;1.1的响应队头阻塞,解决了HTTP层的队头阻塞问题,但仍存在队头阻塞问题;由于HTTP&#x2F;2.0基于TCP协议,TCP必须保证接受到的字节数据完整且连续,若存在字节缺失,则后面收到的信息全部阻塞到缓冲区中,直到重新发送该缺失字节</p>
<p>​	所以一旦丢包,就会触发TCP重传,在<strong>一个TCP连接中的所有HTTP请求都必须等待该包被重传</strong></p>
<h1 id="HTTP-x2F-3-0"><a href="#HTTP-x2F-3-0" class="headerlink" title="HTTP&#x2F;3.0"></a>HTTP&#x2F;3.0</h1><p>​	HTTP&#x2F;3.0将HTTP下层协议从<strong>TCP协议改为UDP协议</strong>,通过基于UDP的QUIC协议也可以实现类似TCP的可靠性传输</p>
<p>​	QUIC有以下三个特点:</p>
<ul>
<li>无队头阻塞</li>
</ul>
<p>​	当某个流发生丢包时,只阻塞这个流,其他流不会受到影响;QUIC连接上的各Stream之间没有依赖,各自独立,因此只影响该流;</p>
<ul>
<li>更快建立连接</li>
</ul>
<p>​		在HTTP&#x2F;2.0中,TCP协议和TLS协议是分层的,先进行TCP握手再进行TLS握手,而在QUIC协议中内部包含了TLS协议,握手的目的是确认双方的<code>连接ID</code>,这个握手过程只需要1RTT,连接迁移就是基于连接ID实现的;</p>
<p>​	甚至在第二次连接时,数据包可以于QUIC握手信息一起发送,达到0RTT握手时间的效果</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/QUIC%E6%8F%A1%E6%89%8B.png"></p>
<ul>
<li>连接迁移</li>
</ul>
<p>​	基于TCP协议的HTTP通过四元组(源IP,源端口,目的IP,目的端口)确定一个连接,如当手机从WIFI切换为4G网络后,IP地址会发生变化,就会断开连接并重新连接,延迟很高,连接迁移的成本很高</p>
<p>​	对应QUIC协议,通过<strong>连接ID</strong>来确定一个连接,即使IP地址变化,只要仍保持上下文信息(连接ID,TLS密钥等),就可以”无缝”复用原连接</p>
<h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>​	QUIC是基于UDP之上的伪TCP+TLS+HTTP&#x2F;2的多路复用协议,QUIC是新协议,若网络设备不识别QUIC包,当作UDP包,此时QUIC就可能被误作为UDP包丢弃</p>
<p>​	HTTP&#x2F;3.0目前普及速度较慢</p>
<h1 id="HTTP-x2F-1-1优化"><a href="#HTTP-x2F-1-1优化" class="headerlink" title="HTTP&#x2F;1.1优化"></a>HTTP&#x2F;1.1优化</h1><p>​	以下三个方面:</p>
<ul>
<li>避免发送HTTP请求</li>
<li>需要发送HTTP请求时减少HTTP请求次数</li>
<li>减少服务器的HTTP响应的数据大小</li>
</ul>
<h2 id="1-避免发送HTTP请求"><a href="#1-避免发送HTTP请求" class="headerlink" title="1.避免发送HTTP请求"></a>1.避免发送HTTP请求</h2><p>​	在发送具有重复性的HTTP请求时,将返回结果存储到本地,即缓存技术</p>
<p>​	缓存包括强制缓存和协商缓存,与前面章节相同</p>
<h2 id="2-减少HTTP请求次数"><a href="#2-减少HTTP请求次数" class="headerlink" title="2.减少HTTP请求次数"></a>2.减少HTTP请求次数</h2><p>从三个方面:</p>
<ul>
<li>减少重定向请求次数</li>
<li>合并请求</li>
<li>延迟发送请求</li>
</ul>
<h3 id="减少重定向"><a href="#减少重定向" class="headerlink" title="减少重定向"></a>减少重定向</h3><p>​	当请求的资源从原地址转移后,服务器返回302响应码和新地址的URL,再由客户端再次发起请求,该请求也可能不是目标地址,需要再次重定向,因此重定向会降低网络性能</p>
<p>​	将重定向通过代理服务器完成,由代理服务器进行重定向操作,找到资源后向客户端返回最终的地址,就可以减少HTTP请求次数了</p>
<h3 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h3><p>​	将多个小文件请求合并为一个大请求,传输的总资源一致但减少请求次数就减少了重复发送HTTP头部</p>
<p>​	而且HTTP&#x2F;1.1是请求响应模型,发起的每个请求都是不同的TCP连接,合并请求也可以减少TCP连接数量,省去TCP握手和慢启动过程消耗的时间</p>
<p>​	合并请求带来的问题是,当大资源中的某个小资源变化,就要重新下载整个大资源</p>
<h3 id="延时发送请求"><a href="#延时发送请求" class="headerlink" title="延时发送请求"></a>延时发送请求</h3><p>​	如一个界面在屏幕中不能全部显示,就先请求能显示出来的部分,当滑动到剩余部分时,再请求剩余部分的资源,达到了减少同一时间的请求次数</p>
<h3 id="3-减少HTTP响应数据大小"><a href="#3-减少HTTP响应数据大小" class="headerlink" title="3.减少HTTP响应数据大小"></a>3.减少HTTP响应数据大小</h3><p>​	通过压缩实现,分为有损压缩和无损压缩</p>
<blockquote>
<p>虽然HTTP&#x2F;1.1可以进行优化,但优化是有上限的,因此出现了后面的HTTP&#x2F;2.0和HTTP&#x2F;3.0</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>java网络编程</title>
    <url>/2023/05/17/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<ul>
<li>C&#x2F;S模型</li>
<li>B&#x2F;S模型</li>
</ul>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
  </entry>
  <entry>
    <title>CF记录</title>
    <url>/2023/07/17/CF%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Codeforces-Round-882-Div-2"><a href="#Codeforces-Round-882-Div-2" class="headerlink" title="Codeforces Round 882(Div. 2)"></a>Codeforces Round 882(Div. 2)</h2><ul>
<li>A</li>
<li>C</li>
</ul>
<h2 id="Educational-Codeforces-Round-151"><a href="#Educational-Codeforces-Round-151" class="headerlink" title="Educational Codeforces Round 151"></a>Educational Codeforces Round 151</h2><ul>
<li>D 前缀和</li>
</ul>
<h2 id="Codeforces-Round-886-Div-4"><a href="#Codeforces-Round-886-Div-4" class="headerlink" title="Codeforces Round 886 (Div.4)"></a>Codeforces Round 886 (Div.4)</h2><h3 id="D-Balanced-Round"><a href="#D-Balanced-Round" class="headerlink" title="D - Balanced Round"></a><a href="https://codeforces.com/contest/1850/problem/D">D - Balanced Round</a></h3><ul>
<li>题意:从数组中删除最少的数,使剩下的数组中连续的两个数之间的差不超过k</li>
<li>我的解法: 通过递归,找到不合法的地方,分别抛弃左侧和右侧,记录抛弃的格式,再对剩下的进行递归,直到整个数组合法;在Test1和Test2中通过,但在Test3中超时</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recur</span><span class="params">(ll arr[],ll k,ll drop,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//剪枝</span></span><br><span class="line">    <span class="keyword">if</span>(drop&gt;=ans)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> isEnd=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//找到差值大于k的地方</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left+<span class="number">1</span>;i&lt;=right;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]-arr[i<span class="number">-1</span>]&gt;k)&#123;</span><br><span class="line">            ll leftLen=i-left;</span><br><span class="line">            ll rightLen=right-i+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">recur</span>(arr,k,drop+rightLen,left,i<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">recur</span>(arr,k,drop+leftLen,i,right);</span><br><span class="line">            isEnd=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isEnd) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, drop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cf886c</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ans=<span class="number">200000</span>;</span><br><span class="line">        <span class="type">static</span> ll arr[<span class="number">200001</span>];</span><br><span class="line">        ll n,k;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            cin&gt;&gt;arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr+<span class="number">1</span>, arr+n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">recur</span>(arr,k,<span class="number">0</span>,<span class="number">1</span>,n);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解:题意可理解为找到最长的合法区间,然后删除其他所有数字,因此可以遍历数组,找到最长的合法区间,总长度减去该区间长度即为题解</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">		<span class="built_in">sort</span>(a,a+n);</span><br><span class="line">		temp=<span class="number">1</span>;ans=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]-a[i<span class="number">-1</span>]&lt;=k)temp++;</span><br><span class="line">			<span class="keyword">else</span> temp=<span class="number">1</span>;</span><br><span class="line">			ans=<span class="built_in">max</span>(ans,temp);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;n-ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="E-Cardboard-for-Pictures"><a href="#E-Cardboard-for-Pictures" class="headerlink" title="E - Cardboard for Pictures"></a><a href="https://codeforces.com/contest/1850/problem/E">E - Cardboard for Pictures</a></h3><ul>
<li>题意:简单的二分查找</li>
<li>题解:通过二分查找即解决,出现的问题是数据过大,即使使用 longlong 可会出现越界问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeft</span><span class="params">(ll mid,ll n,ll c,ll arr[])</span></span>&#123;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        sum+=(arr[i]+<span class="number">2</span>*mid)*(arr[i]+<span class="number">2</span>*mid);</span><br><span class="line">        <span class="comment">//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">        <span class="comment">//在此处,若将判断放在循环外部,会出现越界问题,导致判断出错</span></span><br><span class="line">        <span class="keyword">if</span>(sum&gt;c)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cf886d</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n,c;</span><br><span class="line">        <span class="type">static</span> ll arr[<span class="number">200001</span>];</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll left=<span class="number">0</span>,right=<span class="number">1e9</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            mid=(right-left)/<span class="number">2</span>+left;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isLeft</span>(mid,n,c,arr)) &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;left<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Codeforces-Round-888-Div-3"><a href="#Codeforces-Round-888-Div-3" class="headerlink" title="Codeforces Round 888 (Div. 3)"></a><a href="https://codeforces.com/contest/1851">Codeforces Round 888 (Div. 3)</a></h1><h2 id="B-Parity-Sort"><a href="#B-Parity-Sort" class="headerlink" title="B - Parity Sort"></a><a href="https://codeforces.com/contest/1851/problem/B">B - Parity Sort</a></h2><ul>
<li>输入一个数组,可以交换同为偶数或奇数的两个数,问可否使数组为非递增序列</li>
<li>对一个数组排序,然后比较原数组与排序后的数组,若相同下标处不同为偶数或奇数,则</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t; cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">	<span class="type">int</span> n; cin&gt;&gt;n; <span class="type">int</span> a[n], b[n]; string ans=<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i], b[i]=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a, a+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">	<span class="keyword">if</span>(a[i]%<span class="number">2</span> != b[i]%<span class="number">2</span>)&#123;</span><br><span class="line">		ans=<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Day2项目实践|社区话题页面</title>
    <url>/2023/07/26/Day2%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5_%E7%A4%BE%E5%8C%BA%E8%AF%9D%E9%A2%98%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="基础复现"><a href="#基础复现" class="headerlink" title="基础复现"></a>基础复现</h1><h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><ul>
<li>展示话题和回帖列表</li>
<li>不考虑前端实现,只实现本地Web服务</li>
<li>话题和回帖数据使用文件存储</li>
</ul>
<h3 id="用例说明"><a href="#用例说明" class="headerlink" title="用例说明"></a>用例说明</h3><p>​	通过ER图来标识，主要有两个实体Topic和Post，其中Topic包含属性id，title，content和date而Post包括id，topic_id，content和date</p>
<h3 id="组件工具"><a href="#组件工具" class="headerlink" title="组件工具"></a>组件工具</h3><ul>
<li><a href="https://github.com/gin-gonic/gin#installation">Gin 高性能goWeb框架</a></li>
<li>Go Mod 使用以下指令:<code>go mod init</code>+ <code>go get gopkg.in/gin-gonic/gin.v1@v1.3.0</code>,指令在go.mod文件的路径下执行，若出现网络错误，则执行<code>go env -w GOPROXY=https://goproxy.cn</code>来使用国内代理</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>通过话题ID查询话题信息</li>
<li>通过话题ID查询所有该话题下的ID</li>
</ul>
<p>​	可以通过全扫描查询，为优化效率，使用索引</p>
<h3 id="功能分层"><a href="#功能分层" class="headerlink" title="功能分层"></a>功能分层</h3><p>​	本项目总体分为三层,分别为数据层repository,服务层service和控制层controller</p>
<ul>
<li>数据层:本层为最底层,定义Topic结构体,Post结构体,索引等,根据传入路径读取信息并初始化话题索引和帖子列表索引,根据话题ID查询话题信息和帖子列表</li>
<li>服务层:借助数据层提供的服务实现本层服务,在本次定义页面信息结构体和信息流结构体(用于在流程中暂存数据),通过操作信息流对象,检查传入话题ID是否合法,根据话题ID查询话题信息和帖子列表,使用信息流将查询到的数据打包为页面信息</li>
<li>控制层:借助服务层提供的服务实现数据查询和打包,定义PageData结构体,包括状态码,状态信息,页面数据等信息,根据传入的话题ID字符串查询数据,并将数据和状态信息打包发送</li>
</ul>
<h2 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h2><h4 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h4><ul>
<li>在查询时,通过postDao结构体实现单例,通过单例查询体高查询效率</li>
</ul>
<blockquote>
<p>代码地址:<strong><a href="https://github.com/YQYjin/GoProject/blob/master/src/project1_origin/repository.go">repository.go</a></strong></p>
</blockquote>
<h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><blockquote>
<p>代码地址:<strong><a href="https://github.com/YQYjin/GoProject/blob/master/src/project1_origin/Service.go">service.go</a></strong></p>
</blockquote>
<h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><blockquote>
<p>代码地址:<strong><a href="https://github.com/YQYjin/GoProject/blob/master/src/project1_origin/controller.go">controller.go</a></strong></p>
</blockquote>
<h2 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h2><blockquote>
<p>主函数代码:<a href="https://github.com/YQYjin/GoProject/blob/master/src/project1_origin/main.go">main.go</a></p>
</blockquote>
<p>核心代码解释:</p>
<ul>
<li><p><code>r := gin.Default()</code>: 这行代码创建了一个Gin的默认引擎实例，该实例用于处理HTTP请求和路由。</p>
</li>
<li><p><code>r.GET(&quot;/topic/:topicId&quot;, func(c *gin.Context) &#123; ... &#125;)</code>: 这是一个路由定义，它指定了一个处理GET请求的路由。<code>&quot;/topic/:topicId&quot;</code> 是一个路由路径，其中 <code>:topicId</code> 表示一个参数占位符，它允许在该位置匹配任何非空字符串。例如，如果请求的URL为<code>/topic/123</code>，那么<code>123</code> 将被作为 <code>topicId</code> 的值传递给后面的处理函数。</p>
</li>
<li><p><code>func(c *gin.Context) &#123; ... &#125;</code>: 这是一个匿名函数（也称为闭包），是真正处理HTTP请求的代码块。在Gin框架中，所有的请求处理函数都需要具有这样的签名，即接受一个 <code>*gin.Context</code> 类型的参数。<code>gin.Context</code> 对象封装了该HTTP请求的所有信息，并提供了许多有用的方法来处理请求和构建响应。</p>
</li>
<li><p><code>topicId := c.Param(&quot;topicId&quot;)</code>: 这行代码从请求中获取URL参数 <code>topicId</code> 的值，并将其存储在一个本地变量 <code>topicId</code> 中。<code>c.Param()</code> 方法用于提取URL中的参数值。</p>
</li>
<li><p><code>data := QueryPageInfo(topicId)</code>: 这行代码调用一个自定义的函数 <code>QueryPageInfo()</code>，并将之前获取的 <code>topicId</code> 作为参数传递给该函数。<code>QueryPageInfo()</code> 函数用于根据提供的 <code>topicId</code> 查询相应的页面信息。</p>
</li>
<li><p><code>c.JSON(200, data)</code>: 这行代码使用 <code>c.JSON()</code> 方法将处理函数的返回数据 <code>data</code> 以JSON格式作为HTTP响应返回给客户端。在这里，HTTP状态码设置为<code>200</code>，表示请求成功。</p>
</li>
</ul>
<p>可能的问题及解决:</p>
<ul>
<li>若无法找到包 gin,可以在go.mod文件所在目录下执行控制台命令: <code>go get -u github.com/gin-gonic/gin</code>即可自动下载并导入gin</li>
<li>运行后通过浏览器打开:<a href="http://localhost:8080/topic/1,%E5%8D%B3%E5%8F%AF%E6%9F%A5%E8%AF%A2%E8%AF%9D%E9%A2%98ID%E4%B8%BA1%E7%9A%84%E8%AF%9D%E9%A2%98%E4%BF%A1%E6%81%AF%E5%92%8C%E4%B8%8B%E5%B1%9E%E6%89%80%E6%9C%89%E5%B8%96%E5%AD%90%E4%BF%A1%E6%81%AF">http://localhost:8080/topic/1,即可查询话题ID为1的话题信息和下属所有帖子信息</a></li>
</ul>
<h1 id="作业实现"><a href="#作业实现" class="headerlink" title="作业实现"></a>作业实现</h1><h2 id="发布帖子"><a href="#发布帖子" class="headerlink" title="发布帖子"></a>发布帖子</h2><p>​	为了发布一个帖子,需要一个前端界面来编写并发送帖子信息,使用ajax收发报文,script脚本如下所示:</p>
<ul>
<li>通过输入框获取发布帖子的话题ID和内容</li>
<li>通过Date().getTime()获取提交表单时的时间作为发帖时间</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 监听表单提交事件</span></span><br><span class="line">        $(<span class="string">&quot;#loginForm&quot;</span>).<span class="title function_">submit</span>(<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">            event.<span class="title function_">preventDefault</span>(); <span class="comment">// 阻止表单的默认提交行为</span></span><br><span class="line">            <span class="keyword">var</span> topicId = $(<span class="string">&quot;#topicId&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">            <span class="keyword">var</span> postContent = $(<span class="string">&quot;#postContent&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">            <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(topicId + <span class="string">&quot; &quot;</span> + postContent);</span><br><span class="line">            <span class="keyword">var</span> postData = &#123;</span><br><span class="line">                <span class="attr">topicId</span>: topicId,</span><br><span class="line">                <span class="attr">content</span>: postContent,</span><br><span class="line">                <span class="attr">create_time</span>: time</span><br><span class="line">            &#125;;</span><br><span class="line">            $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/post&quot;</span>,  <span class="comment">// 替换为实际的后台处理URL</span></span><br><span class="line">                <span class="attr">data</span>: postData,</span><br><span class="line">                <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Success&quot;</span> + response);</span><br><span class="line">                    <span class="keyword">if</span> (response == <span class="string">&#x27;success&#x27;</span>) &#123;</span><br><span class="line">                       <span class="title function_">alert</span>(<span class="string">&quot;发帖成功&quot;</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="title function_">alert</span>(<span class="string">&quot;发帖失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error:&quot;</span> + error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>​	页面预览:</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%A4%BA%E4%BE%8B1.png"></p>
<p>​	设置静态文件目录,防止出现跨域,HTML文件目录为工程目录下的assets目录中</p>
<p>​	<code>r.Static(&quot;/assets&quot;, &quot;../assets&quot;)</code></p>
<p>​	此时浏览器打开<a href="http://localhost:8080/assets/post.html%E5%8D%B3%E5%8F%AF%E6%89%93%E5%BC%80post.html%E6%96%87%E4%BB%B6">http://localhost:8080/assets/post.html即可打开post.html文件</a></p>
<p>​	服务器需要接受服务器发送的信息，因此需要为添加POST方法，用于接收数据并处理;通过c.PostForm获取请求报文中相应字段的内容,并调用下层方法进行下一步处理,处理成功后返回success信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;post&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		topicId := c.PostForm(<span class="string">&quot;topicId&quot;</span>)</span><br><span class="line">		content := c.PostForm(<span class="string">&quot;content&quot;</span>)</span><br><span class="line">		create_time := c.PostForm(<span class="string">&quot;create_time&quot;</span>)</span><br><span class="line">		<span class="comment">//使用协程进行添加,防止阻塞</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			err := packPostInfo(topicId, content, create_time)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;接收到的帖子信息为:&quot;</span>, topicId, <span class="string">&quot; &quot;</span>, content, <span class="string">&quot; &quot;</span>, create_time)</span><br><span class="line">		c.JSON(<span class="number">200</span>, <span class="string">&quot;success&quot;</span>)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> HTML文件代码:<strong><a href="https://github.com/YQYjin/GoProject/blob/master/assets/post.html">post.html</a></strong></p>
</blockquote>
<h3 id="控制层方法"><a href="#控制层方法" class="headerlink" title="控制层方法"></a>控制层方法</h3><p>​	在控制层中对信息进行初步处理,将传入的字符串类型的话题ID和时间转为int64类型,并为Post类型对象,然后由服务层进行下一步处理.</p>
<ul>
<li>使用协程来执行发帖操作,防止阻塞,优化效率</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">packPostInfo</span><span class="params">(topicId <span class="type">string</span>, content <span class="type">string</span>, create_time <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">//将传入的字符串id转换为int64</span></span><br><span class="line">	topicId_int, err := strconv.ParseInt(topicId, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将时间字符串转为int64</span></span><br><span class="line">	create_time_int, err := strconv.ParseInt(create_time, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	post := &amp;Post&#123;</span><br><span class="line">		TopicId: topicId_int,</span><br><span class="line">		Content: content,</span><br><span class="line">		Date:    create_time_int,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加帖子ID(服务层方法)并进行下一步操作</span></span><br><span class="line">	err = paperPostInfo(post)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>​	在服务层中,使用单例执行添加操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">paperPostInfo</span><span class="params">(post *Post)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	err := NewPostDaoInstance().addPost(post)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h3><p>​	在数据层方法中为该帖子添加帖子ID,然后将帖子添加到帖子索引中,实现发帖</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostDao)</span></span> addPost(post *Post) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">//更新最大帖子ID</span></span><br><span class="line">	maxPostId++</span><br><span class="line">	post.Id = maxPostId</span><br><span class="line">	<span class="comment">//将帖子放入对应话题下的列表中,更新索引</span></span><br><span class="line">	<span class="comment">//更新索引时加锁,防止多线程同时写入</span></span><br><span class="line">	indexLock.Lock()</span><br><span class="line">	postIndexMap[post.TopicId] = <span class="built_in">append</span>(postIndexMap[post.TopicId], post)</span><br><span class="line">	indexLock.Unlock()</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;成功添加帖子:&quot;</span>, <span class="string">&quot;topicId:&quot;</span>, post.TopicId, <span class="string">&quot;content:&quot;</span>, post.Content, <span class="string">&quot;date:&quot;</span>, post.Date)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="本地ID生成唯一"><a href="#本地ID生成唯一" class="headerlink" title="本地ID生成唯一"></a>本地ID生成唯一</h2><p>​	为了使本地生成的ID唯一,使用自增ID的方法,在数据层中维护一个maxPostId对象,在初始化索引时找到已存在的最大帖子ID,在发布帖子时,使maxPostId增1后作为新帖子的ID,以保证本地ID生成唯一</p>
<h2 id="更新索引"><a href="#更新索引" class="headerlink" title="更新索引"></a>更新索引</h2><p>​	由于处理POST请求使用协程,可能会出现并发问题,因此在向索引表中添加内容前,为索引表加锁,添加完成后释放锁,以避免并发冲突,需要在原索引对象中添加锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	topicIndexMap <span class="keyword">map</span>[<span class="type">int64</span>]*Topic</span><br><span class="line">	postIndexMap  <span class="keyword">map</span>[<span class="type">int64</span>][]*Post</span><br><span class="line">	indexLock     sync.Mutex</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>​	<strong><a href="https://github.com/YQYjin/GoProject/tree/master/src/project1_hw">作业代码</a></strong></p>
</blockquote>
<p>​	本次在原有项目基础上实现了发帖功能,熟练了对gin框架服务器的构建和使用,也对Go语言并发处理,服务流程设计有了初步认识,对处理Go项目中出现的各种问题积累了经验.</p>
<h3 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h3><ul>
<li>导入自定义包</li>
</ul>
<p>​	在GoLand下导入自定义包,包应放置在项目目录下的src目录中,要保证包中函数能被包外调用,需要将函数首字母大写.</p>
<p>​	若向main包中导入src中的porject_hw包,需要在main包的go.mod中添加:<code>require project1_hw v0.0.0</code>以及<code>replace project1_hw =&gt; ../src/project1_hw </code>,其中  replace后的参数为包名, &#x3D;&gt;后的参数为包所在的相对路径</p>
<p>​	然后在文件中添加 <code>import &quot;project1_hw&quot;</code>即可导入该包</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
  </entry>
  <entry>
    <title>HTTPS优化</title>
    <url>/2023/05/23/HTTPS%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<span id="more"></span>

<p>155</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>Go多线程</title>
    <url>/2023/07/26/Go%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>​	多线程在一个核上运行称为并发,在多核上运行称为并行,Go语言有Goroutine,为协程,用户态,有Go语言控制,是轻量级线程,KB级别.而线程是内核态,一个线程可以运行多个协程,线程是MB级别.</p>
<ul>
<li><p>启动协程</p>
<p>使用关键字<code>go</code>+<code>函数名</code>,即可创建该函数的协程</p>
</li>
</ul>
<h2 id="通信-CSP"><a href="#通信-CSP" class="headerlink" title="通信(CSP)"></a>通信(CSP)</h2><p>​	Go提倡通过通信共享内存而不是通过共享内存来实现通信,因此要通过通道来实现不同协程间的通信,通道类似队列,先入先出.但Go也保留使用共享内存实现通信的功能,该功能需要加锁获取临界区权限,这样会发生竞争,影响并发效率</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>​	通过<code>make(chan 元素类型,[缓冲大小])</code>来创建一个通道,若不添加第二个参数则创建无缓冲通道,否则创建一个有缓冲通道,带有指定大小的缓冲区</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/%E6%9C%89%E6%97%A0%E7%BC%93%E5%AD%98%E9%80%9A%E9%81%93.png"></p>
<h2 id="生产消费模型示例"><a href="#生产消费模型示例" class="headerlink" title="生产消费模型示例"></a>生产消费模型示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	src := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	dest := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(src)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			src &lt;- i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(dest)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> src &#123;</span><br><span class="line">			dest &lt;- i * i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">//实现第一个协程生成数组,第二个协程计算数字的平方,通过通道读取结果</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dest &#123;</span><br><span class="line">		<span class="built_in">println</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>​	通过加锁来实现并发安全,通过以下方式创建变量并声明锁,然后通过<code>lock.Lock()</code>即可为该变量加锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    x <span class="type">int64</span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="WaitGroup并发同步"><a href="#WaitGroup并发同步" class="headerlink" title="WaitGroup并发同步"></a>WaitGroup并发同步</h2><p>​	为了实现线程同步,可以使用time.sleep()方法,但更好的方法是通过WatiGroup进行优化</p>
<p>​	WaitGroup用于在执行多个 goroutine 时等待它们全部完成后再继续执行主程序。协调多个 goroutine 之间的同步，以确保所有 goroutine 都已完成其任务。</p>
<p><code>WaitGroup</code> 包含以下几个主要方法：</p>
<ol>
<li><code>Add(delta int)</code>: 用于增加等待的 goroutine 的数量。通常在启动一个新的 goroutine 之前调用 <code>Add</code> 方法，将等待计数器加一。</li>
<li><code>Done()</code>: 表示一个等待的 goroutine 已完成其任务。在 goroutine 完成其工作后调用 <code>Done</code> 方法，将等待计数器减一。</li>
<li><code>Wait()</code>: 阻塞主程序的执行，直到所有的 goroutine 都调用了 <code>Done</code> 方法，并且等待计数器归零。</li>
</ol>
<h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><p>​	开发项目中要学会站在巨人的肩膀上,使用已经开发完成的组件来帮助开发,避免重复发明轮子需要导入依赖,框架等,因此需要合理地管理依赖库,目前广泛应用Go Module</p>
<p>​	依赖管理的目标是解决不同环境(项目)的依赖版本不同以及控制依赖库的版本</p>
<h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p>​	Go语言的环境变量,该目录下</p>
<ul>
<li>bin: 项目编译的二进制文件</li>
<li>pkg:项目编译的中间产物,加速编译</li>
<li>src:项目源码</li>
</ul>
<p>​	弊端是:若项目A和B依赖于同一package的不同版本,在升级过程中package函数可能发生改变,导致两个项目无法同时构建成功</p>
<h3 id="Go-Vendor"><a href="#Go-Vendor" class="headerlink" title="Go Vendor"></a>Go Vendor</h3><p>​	添加vendor,为每一个项目引入一份依赖副本,解决版本不同的问题</p>
<p>​	存在的问题是,package A和package B又依赖了不同的下一层package,而他们又不兼容,就会再次导致冲突</p>
<h3 id="Go-Module"><a href="#Go-Module" class="headerlink" title="Go Module"></a>Go Module</h3><p>​	通过go.mod文件管理依赖包版本,通过<code>go get/go mod</code>指令工具管理依赖包</p>
<p>​	依赖管理三要素:</p>
<ol>
<li>配置文件,描述依赖 — go.mod</li>
<li>中心仓库管理依赖库 — Proxy</li>
<li>本地工具 — go get和go mod</li>
</ol>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
  </entry>
  <entry>
    <title>RPC框架</title>
    <url>/2023/08/12/RPC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><p>​	远程函数调用(RPC,Remote Procedure Calls)</p>
<p>​	RPC需要解决:</p>
<ul>
<li>函数映射</li>
<li>数据转换成字节流</li>
<li>网络传输</li>
</ul>
<h2 id="1-1一次RPC的完整过程"><a href="#1-1一次RPC的完整过程" class="headerlink" title="1.1一次RPC的完整过程"></a>1.1一次RPC的完整过程</h2><ol>
<li>IDL (Interface description language)文件</li>
</ol>
<p>​	IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信</p>
<ol start="2">
<li>生成代码</li>
</ol>
<p>​	通过编译器工具把IDL文件转换成语言对应的静态库</p>
<ol start="3">
<li>编解码</li>
</ol>
<p>​	从内存中表示到字节序列的转换称为编码，反之为解码，也常叫做序列化和反序列化</p>
<ol start="4">
<li>通信协议</li>
</ol>
<p>​	规范了数据在网络中的传输内容和格式。除必须的请求&#x2F;响应数据外，通常还会包含额外的元数据</p>
<p>5.网络传输</p>
<p>​	通常基于成熟的网络库走 TCP&#x2F;UDP传输</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/2023081217004.png"></p>
<h3 id="RPC的好处"><a href="#RPC的好处" class="headerlink" title="RPC的好处"></a>RPC的好处</h3><ul>
<li>单一职责,有利于分工和运维开发</li>
<li>可拓展性强</li>
<li>故障隔离,服务整体可靠性更高</li>
</ul>
<h3 id="RPC的问题"><a href="#RPC的问题" class="headerlink" title="RPC的问题"></a>RPC的问题</h3><ul>
<li>服务宕机时应如何处理</li>
<li>调用过程中发生网络异常,如何保证消息的可达性</li>
<li>请求突增无法及时处理怎么办</li>
</ul>
<h1 id="2-分层设计"><a href="#2-分层设计" class="headerlink" title="2.分层设计"></a>2.分层设计</h1><p>​	以Apache Thrift为例</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/202308121716614.png"></p>
<h2 id="2-1编解码层"><a href="#2-1编解码层" class="headerlink" title="2.1编解码层"></a>2.1编解码层</h2><p>​	客户端和服务器依赖同一份IDL文件,生成不同语言的代码</p>
<p>​	IDL文件的数据格式有:语言特定的格式,如Java的java.io.Serializable,文本格式,如JSON,XML等,还有二进制编码格式</p>
<h3 id="2-1-1-TLV编码-二进制编码"><a href="#2-1-1-TLV编码-二进制编码" class="headerlink" title="2.1.1 TLV编码(二进制编码)"></a>2.1.1 TLV编码(二进制编码)</h3><p>​	包括字段: </p>
<ul>
<li>Tag: 标签,表示类型</li>
<li>Lenght: 长度</li>
<li>Value: 值,value也可以是一个TLV结构</li>
</ul>
<p>Tag有时可以确定长度,就不需要Lenght字段,如Tag为int64,则长度已经是固定的</p>
<h3 id="2-1-2-编码格式考量"><a href="#2-1-2-编码格式考量" class="headerlink" title="2.1.2 编码格式考量"></a>2.1.2 编码格式考量</h3><ul>
<li>兼容性:考虑兼容性问题,是否支持新增字段而不影响老的服务</li>
<li>通用性:是否跨平台,跨语言</li>
<li>性能:从时间和空间两个方面考虑</li>
</ul>
<h2 id="2-2协议层"><a href="#2-2协议层" class="headerlink" title="2.2协议层"></a>2.2协议层</h2><p>​	协议有:</p>
<ul>
<li>特殊结束符,通过一个特殊字符表示每个协议单元的结束,如HTTP以\r\n结尾</li>
<li>边长协议,以定长和不定长两部分组成,定长部分描述不定长部分的长度</li>
</ul>
<h3 id="2-2-1-协议构造"><a href="#2-2-1-协议构造" class="headerlink" title="2.2.1 协议构造"></a>2.2.1 协议构造</h3><p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/202308121737835.png"></p>
<p>​	解析时,通过MagicNumber确定协议类别,通过PayloadCodec获取编码格式,再通过解码获取Payload</p>
<h2 id="2-3网络通信层"><a href="#2-3网络通信层" class="headerlink" title="2.3网络通信层"></a>2.3网络通信层</h2><p>​	通过Sockets API</p>
<p>​	实际应用中,使用网络库来操作,简单易用,指标有:</p>
<ul>
<li>提供易用API,封装底层Socket API,连接管理和事件分发</li>
<li>功能:支持多种协议,如TCP,UDP,UDS等,可以优雅退出和具备异常处理等</li>
<li>性能:应用层buffer减少copy,高性能定时器和对象池等</li>
</ul>
<h1 id="3-关键指标"><a href="#3-关键指标" class="headerlink" title="3.关键指标"></a>3.关键指标</h1><h2 id="3-1-稳定性"><a href="#3-1-稳定性" class="headerlink" title="3.1 稳定性"></a>3.1 稳定性</h2><ul>
<li>熔断:保护调用方,防止被调用的服务影响到整个链路</li>
<li>限流:保护被调用方,防止大流量把服务压垮</li>
<li>超时控制: 避免浪费资源在不可用的节点上</li>
</ul>
<p>使用负载均衡,使服务被均匀调用;当调用失败时,通过重试来增加请求成功率</p>
<p>长尾请求:响应明显高于一般请求</p>
<p>​	通过注册中间件,来控制服务的稳定性</p>
<h2 id="3-2易用性"><a href="#3-2易用性" class="headerlink" title="3.2易用性"></a>3.2易用性</h2><p>​	易用性要保证:</p>
<ul>
<li>开箱即用:合理的默认参数,丰富的文档</li>
<li>周边工具:生产代码工具,脚手架工具等</li>
</ul>
<h2 id="3-3-扩展性"><a href="#3-3-扩展性" class="headerlink" title="3.3 扩展性"></a>3.3 扩展性</h2><p>​	要尽可能提供多的扩展点,如代码生成工具支持插件拓展</p>
<h2 id="3-4-观测性"><a href="#3-4-观测性" class="headerlink" title="3.4 观测性"></a>3.4 观测性</h2><p>​	内置观测性服务</p>
<p>​	三件套:	Log,Metric和Tracing</p>
<h2 id="3-5-高性能"><a href="#3-5-高性能" class="headerlink" title="3.5 高性能"></a>3.5 高性能</h2><p>​	目标:高吞吐,低延迟</p>
<p>​	手段:</p>
<ul>
<li>连接池</li>
<li>多路复用</li>
<li>高性能编解码协议</li>
<li>高性能网络库</li>
</ul>
<p>​	高性能的具体考量根据应用场景的不同而存在差异</p>
<h1 id="4-企业实践"><a href="#4-企业实践" class="headerlink" title="4.企业实践"></a>4.企业实践</h1><p>​	为什么要自研网络库?</p>
<p>​	原生网络库无法感知连接状态,在使用连接池时,当存在失效连接时影响连接池的复用</p>
<p>​	原生库存在goroutine暴涨的风险,影响性能</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
  </entry>
  <entry>
    <title>Web应用开发</title>
    <url>/2023/07/23/Web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="Blog开发"><a href="#Blog开发" class="headerlink" title="Blog开发"></a>Blog开发</h1>]]></content>
      <categories>
        <category>工程</category>
      </categories>
  </entry>
  <entry>
    <title>企业网络接入</title>
    <url>/2023/08/12/%E4%BC%81%E4%B8%9A%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[<h1 id="1-域名系统"><a href="#1-域名系统" class="headerlink" title="1.域名系统"></a>1.域名系统</h1><h2 id="1-1-Host管理"><a href="#1-1-Host管理" class="headerlink" title="1.1 Host管理"></a>1.1 Host管理</h2><p>​	使用Host主机表来管理域名到地址的映射</p>
<p>​	使用Host模式出现的问题:</p>
<ul>
<li>随着用户规模增长,流量和负载增加,引起负担增加</li>
<li>名称冲突</li>
<li>分发靠人工,时效性很差</li>
</ul>
<h2 id="1-2-使用域名系统"><a href="#1-2-使用域名系统" class="headerlink" title="1.2 使用域名系统"></a>1.2 使用域名系统</h2><p>关于域名空间:</p>
<ul>
<li>域名空间被组成成树形结构,通过划分zone方法进行分层授权</li>
<li>全球公共域名空间仅对应一棵树</li>
<li>根域名服务器是查询起点</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/202308121528935.png"></p>
<p>使用域名系统需要购买域名并进行配置迁移,域名需要进行备案</p>
<p>如何开放外部用户访问:租赁一个外网IP,将网址映射到该IP上,并将该IP绑定到一台物理机上,并发布公网route</p>
<h2 id="1-3-自建DNS服务器"><a href="#1-3-自建DNS服务器" class="headerlink" title="1.3 自建DNS服务器"></a>1.3 自建DNS服务器</h2><p>​	原因:内网域名解析也需要到公网获取,效率低,而且外部用户可以看到内网IP地址,容易被黑客攻击</p>
<p>​	在企业角度,搭建权威DNS即可,LocalDNS可选</p>
<h3 id="1-3-1权威DNS系统架构"><a href="#1-3-1权威DNS系统架构" class="headerlink" title="1.3.1权威DNS系统架构"></a>1.3.1权威DNS系统架构</h3><p>​	权威DNS系统架构包括:</p>
<ul>
<li>DNS Query</li>
<li>DNS Response</li>
<li>DNS Update</li>
<li>DNS Notify</li>
<li>DNS XFR</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/202308121540520.png"></p>
<p>请求时,用于先向LocalDNS发起请求,LocalDNS服务器再向我们的自建DNS服务器发起请求,最终得到IP地址</p>
<p>内网可以之间请求内部的权威DNS服务器</p>
<h2 id="2-接入HTTP"><a href="#2-接入HTTP" class="headerlink" title="2.接入HTTP"></a>2.接入HTTP</h2><h2 id="2-1-常见加密"><a href="#2-1-常见加密" class="headerlink" title="2.1 常见加密"></a>2.1 常见加密</h2><ul>
<li>对称加密,公用一份密钥</li>
<li>非对称加密,有私钥和公钥,公钥加密只能私钥解密,若使用私钥加密只能用公钥解密</li>
</ul>
<p>​	HTTPS:通信建立前使用非对称加密,通过公钥,私钥进行加密通信交换密钥,通信建立后使用对称加密,通过密钥加密通信,非对称加密速度慢,但可以安全交换密钥,对称加密速度快但无法安全交换密钥,因此使用混合加密模式</p>
<h2 id="2-2-数字证书"><a href="#2-2-数字证书" class="headerlink" title="2.2 数字证书"></a>2.2 数字证书</h2><p>​	数字证书唯一,由CA(数字证书认证机构)颁发,只要证书是可信的,公钥和私钥就是可信的,即通过数字证书验证公钥和私钥是否被伪造</p>
<p> 本质还是数字签名算法,由CA持有私钥并颁发公钥,不同的是CA颁发的公钥已事先存储在客户端中,不会在通信过程中被篡改</p>
<p>​	数字证书通过证书链认证</p>
<h2 id="2-3-接入全站加锁"><a href="#2-3-接入全站加锁" class="headerlink" title="2.3 接入全站加锁"></a>2.3 接入全站加锁</h2><p>​	背景:源站容量低,经过节点越多,丢包等问题就会越多,导致卡顿和响应慢</p>
<p>​	解决方案:</p>
<ul>
<li>增加源站容量(静态加速)</li>
<li>DCDN加速(动态加锁)</li>
<li>全站加速:增加源站容量并使用CDN</li>
</ul>
<p>​	用户首次登录抖音并注册时,使用的是动态加速DCDN</p>
<p>​	用户打开某个特定的短视频加载后观看是静态加速CDN</p>
<p>​	用户打卡头条官网进行网页浏览是静态加速CDN+动态加速CDN</p>
<h1 id="3-四层负载均衡"><a href="#3-四层负载均衡" class="headerlink" title="3.四层负载均衡"></a>3.四层负载均衡</h1><p>​	服务多而杂,只使用一台物理机接入IP会导致出现问题,而且若该物理机故障,所有服务都不可用</p>
<p>​	什么是负载均衡:</p>
<ul>
<li>基于IP+端口,利用某种算法加报文转发给某个后端服务器,实现负载均衡地落到每一个后端服务器上</li>
</ul>
<p>​	三个主要功能: 解耦VIP和RS,NAT和防攻击</p>
<h2 id="3-1-常见调度算法原理"><a href="#3-1-常见调度算法原理" class="headerlink" title="3.1 常见调度算法原理"></a>3.1 常见调度算法原理</h2><ul>
<li>RR轮查询</li>
<li>加强RR轮查询</li>
<li>最小连接</li>
<li>五元组hash</li>
<li>一致性hash</li>
</ul>
<h1 id="4-七层负载均衡"><a href="#4-七层负载均衡" class="headerlink" title="4.七层负载均衡"></a>4.七层负载均衡</h1><p>​	四层负载均衡对IP只能bind一个端口,若有多个外部站点需要使用,该如何解决</p>
<p>​	开源七层负载均衡:Nginx,模块化设计,具有较好的拓展性和可靠性,支持热部署</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/07/%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><h2 id="作业代码"><a href="#作业代码" class="headerlink" title="作业代码"></a>作业代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 数据库安全性作业</span><br><span class="line">-- 1.授权</span><br><span class="line">-- 操作整个库</span><br><span class="line">create user &#x27;U1&#x27;@&#x27;localhost&#x27; identified by &#x27;000000&#x27;;</span><br><span class="line">grant all privileges on oildepot.* to &#x27;U1&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">-- 查询整个库，修改油品类别表中油品价格 列层级</span><br><span class="line">create user &#x27;U2&#x27;@&#x27;localhost&#x27; identified by &#x27;000000&#x27;;</span><br><span class="line">grant select on oildepot.* to &#x27;U2&#x27;@&#x27;localhost&#x27; ;</span><br><span class="line">grant update(Price),select on oildepot.oil to &#x27;U2&#x27;@&#x27;localhost&#x27; ;</span><br><span class="line">-- 查询油库表、油品表、油品储量表，能插入数据到销售信息表</span><br><span class="line">create user &#x27;U3&#x27;@&#x27;localhost&#x27; identified by &#x27;000000&#x27;;</span><br><span class="line">grant select on oildepot.oil to &#x27;U3&#x27;@&#x27;localhost&#x27; ;</span><br><span class="line">grant select on oildepot.oildepots to &#x27;U3&#x27;@&#x27;localhost&#x27; ;</span><br><span class="line">grant select on oildepot.storage to &#x27;U3&#x27;@&#x27;localhost&#x27; ;</span><br><span class="line">grant insert on oildepot.sell to &#x27;U3&#x27;@&#x27;localhost&#x27; ;</span><br><span class="line">-- 插入数据到进货信息表，和修改油品储量信息表中的数据,并允许 U4 将此权限再授予其他用户</span><br><span class="line">create user &#x27;U4&#x27;@&#x27;localhost&#x27; identified by &#x27;000000&#x27;;</span><br><span class="line">grant insert on oildepot.stock to &#x27;U4&#x27;@&#x27;localhost&#x27; with grant option ;</span><br><span class="line">grant update,select on oildepot.storage to &#x27;U4&#x27;@&#x27;localhost&#x27; with grant option;</span><br><span class="line">-- 创建用户U5。登录U4，将u4的权限授予U5，并验证</span><br><span class="line">create user &#x27;U5&#x27;@&#x27;localhost&#x27; identified by &#x27;000000&#x27;;</span><br><span class="line">grant insert on oildepot.stock to &#x27;U5&#x27;@&#x27;localhost&#x27; with grant option ;</span><br><span class="line">grant update,select on oildepot.storage to &#x27;U5&#x27;@&#x27;localhost&#x27; with grant option;</span><br><span class="line">-- grant &#x27;U4&#x27;@&#x27;localhost&#x27; to &#x27;U5&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">show grants for &#x27;U4&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">-- 创建用户U6，授予权限。使U6登录后能创建视图，u6创建一个视图，视图的内容是2022年魏公村油库每个油品的销售额</span><br><span class="line">create user &#x27;U6&#x27;@&#x27;localhost&#x27; identified by &#x27;000000&#x27;;</span><br><span class="line">grant select,create view on oildepot.* to &#x27;U6&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">create view sale_view</span><br><span class="line">as select oil.ID as &#x27;油品编号&#x27;, Name as &#x27;油品名称&#x27;, asum as &#x27;销售额&#x27; from</span><br><span class="line">    (select sell.ID,sum(sell.Purchases*sell.Price*sell.Discount) as asum</span><br><span class="line">     from sell join oil on sell.ID=oil.ID</span><br><span class="line">     where Time like &#x27;2023%&#x27;</span><br><span class="line">     group by sell.ID) as a</span><br><span class="line">        join oil on a.ID=oil.ID</span><br><span class="line">   order by oil.ID desc;</span><br><span class="line">-- 用户U7，授予权限使U7能运行查询第6题中的视图</span><br><span class="line">create user &#x27;U7&#x27;@&#x27;localhost&#x27; identified by &#x27;000000&#x27;;</span><br><span class="line">grant show view,select on oildepot.* to &#x27;U7&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">-- 收回用户 U4 的权限</span><br><span class="line">revoke all on *.* from &#x27;U4&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">show grants for &#x27;U4&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建用户必须有全局CREATE USER权限</li>
<li>identified by 设置密码</li>
</ul>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER user &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27; ;</span><br><span class="line">使用CMD命令修改</span><br><span class="line">Mysqladmin -u root -p password 新密码</span><br></pre></td></tr></table></figure>

<h2 id="更改用户名"><a href="#更改用户名" class="headerlink" title="更改用户名"></a>更改用户名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME USER  u2@localhost to u1111@localhost;</span><br></pre></td></tr></table></figure>

<h2 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP USER user@host ;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/Mysql%E6%9D%83%E9%99%90.png"></p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/mysql%E6%9D%83%E9%99%902.png"></p>
]]></content>
  </entry>
  <entry>
    <title>性能修炼之道与企业实践</title>
    <url>/2023/08/02/%E6%80%A7%E8%83%BD%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E4%B8%8E%E4%BC%81%E4%B8%9A%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="针对网络库优化"><a href="#针对网络库优化" class="headerlink" title="针对网络库优化"></a>针对网络库优化</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li>存下所有Header,header数量,大小不固定</li>
<li>减少系统调用次数</li>
<li>能够复用内存</li>
<li>能够多次读,一次可能不能全部读完</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>多次读</li>
</ul>
<p>​	go net绑定一块缓冲区,读完本次后使指针回退到原位置</p>
<ul>
<li>netpoll存下全部Header和拷贝出完整的Body</li>
</ul>
<p>​	netpoll使用链表存,一个header或body在两个节点上,可以分配足够大的buffer,使header和body在一个节点上,限制最大buffer size防止损耗过大</p>
<p>​	go net对流式友好,小包性能高,netpoll中大包性能高,时延低</p>
<h1 id="针对协议的优化"><a href="#针对协议的优化" class="headerlink" title="针对协议的优化"></a>针对协议的优化</h1><h2 id="Header解析"><a href="#Header解析" class="headerlink" title="Header解析"></a>Header解析</h2><ul>
<li>找到Header Line的边界 <code>\r\n</code></li>
</ul>
<p>​	在寻找时先找到\n,再检查它前面是不是\r,比直接匹配\r\n效率高;还可以使用SIMD进一步优化,Go语言集成了SIMD优化,SIMD可以并行处理数据,可大幅提高效率</p>
<ul>
<li>快速解析</li>
</ul>
<p>​	通过Header Key的首字母快速筛查不可能的Key;针对协议中高频Header,单独特殊处理,如host单独申请空间,直接通过.host获取内容</p>
<ul>
<li>取&amp;舍</li>
</ul>
<p>​	使用核心字段快速解析,使用byte slice快速存储,可以进行内存复用,对应高频header额外存储到成员变量中;但会导致普通header性能低,且没有map结构</p>
<ul>
<li>对Header Key规范化</li>
</ul>
<p>​	使用表映射的方式进行规范化,使用表进行匹配和查找,可以获取超过的转换效率,但会导致额外的内存开销,而且映射表变更困难</p>
<h1 id="热点资源池化"><a href="#热点资源池化" class="headerlink" title="热点资源池化"></a>热点资源池化</h1><p>​	请求到达后,使用RequestContext与请求一一对应,贯穿一个请求始终,使用RequestContext池进行复用(可能类似于线程池)</p>
<p>​	使用热点资源池化可以减少内存分配,提高了内存复用,降低了GC压力,使性能提升</p>
<p>​	但导致额外的Reset逻辑,因为内存会被复用,仅在请求内有效,当超出请求生命周期可能会出现并发问题,并且导致定位困难</p>
<h1 id="企业实践"><a href="#企业实践" class="headerlink" title="企业实践"></a>企业实践</h1><ul>
<li><p>追求性能</p>
</li>
<li><p>追求易用,减少误用</p>
</li>
</ul>
<p>​	如果一味追求性能,就会舍弃一些易用性</p>
<ul>
<li>打通内部生态</li>
</ul>
<p>​	将一些通用逻辑整合到框架内部,方便不同用户使用</p>
<ul>
<li>文档建设,用户群建设</li>
</ul>
<p>​	将被问道的问题写在文档里,便用用户查阅,避免同一个问题多次解答</p>
<ul>
<li>内部HTTP框架: Hertz,达到1万+服务和3千万QPS</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>数赛准备</title>
    <url>/2023/07/31/%E6%95%B0%E8%B5%9B%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>Matlab,和队友同一版本</li>
<li>Mathpix,收费</li>
<li>AxGlyph,收费</li>
</ul>
<h1 id="找数据"><a href="#找数据" class="headerlink" title="找数据"></a>找数据</h1><ul>
<li>知网或谷歌学术平台搜索</li>
<li>国家统计局找</li>
<li>awesome-public-datasets,github项目</li>
<li>EPSDATA平台</li>
</ul>
<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><ul>
<li>缺失值<ul>
<li>缺失太多,就删除该指标,如年龄缺失40%</li>
<li>简单处理:均值,众数插补;定量数据,身高年龄等用均值;定性数据,关于性别,文化程度等,用频次最高的补,适用于对个体精度不高的数据</li>
<li>Newton插值法:使用于只追求函数值精确而不关心变化的数据,缺点是区间边缘震荡,使用性较强但不适合对求导有需求的题目</li>
<li>样条插值法:用光滑的曲线去插值,适用于精度要求高,没有突变的数据</li>
</ul>
</li>
<li>异常值<ul>
<li>去掉明显和替他数值差异很大的值,然后作为缺失值处理</li>
<li>通过正态分布3α原则判断数据值是否在(u-3α,u+3α)之内,不在则为异常值,适用于整体符合正态分布的数据,其他分布如泊松分布不适用</li>
<li>画箱型图,从小到大排序,找下四分位数Q1和上四分位数Q2,再求四分位距IQR&#x3D;Q3-Q1,一般设区间[Q1-1.5*IQR,Q3+1.5*IQR]为正常值,普遍使用于所有题目</li>
</ul>
</li>
</ul>
<h1 id="如何建模"><a href="#如何建模" class="headerlink" title="如何建模"></a>如何建模</h1><ul>
<li>比赛开始后先查文献,以他人现有成果为基础</li>
</ul>
<h2 id="论文结构"><a href="#论文结构" class="headerlink" title="论文结构"></a>论文结构</h2><ul>
<li>摘要:最重要部分,写明问题研究的问题,用了什么方法,得到什么结果和每一步的大概步骤</li>
<li>问题重述,不要复制粘贴避免查重</li>
<li>模型假设和符号说明,好的假设事半功倍,省略不必要的内容,如太阳投影长度跟自转关系大,可省略公转</li>
<li>模型建立:<ul>
<li>查资料后用自己的话复述一个简单的模型,然后根据要求再一步步修改,说清楚每个公式和变量的含义</li>
<li>求解:求解过程可以把资料上的话用自己的话复述,加上图片等</li>
<li>不同小问:不是每一问都需要一个模型,若区别不大,可以针对每一问进行改进,不需要重新建模</li>
<li>模型优缺点和改进方法,不必须</li>
<li>参考文献,注意格式</li>
<li>附录:把查到的代码重构防止查重</li>
</ul>
</li>
</ul>
<h1 id="写论文"><a href="#写论文" class="headerlink" title="写论文"></a>写论文</h1><blockquote>
<p>​	<strong><a href="https://www.bilibili.com/video/BV1Rq4y1S7S8?p=9">论文排版</a></strong></p>
</blockquote>
<blockquote>
<p>​	<strong><a href="https://www.bilibili.com/video/BV1Rq4y1S7S8?p=10">论文标题怎么写</a></strong></p>
</blockquote>
<blockquote>
<p>​	<strong><a href="https://www.bilibili.com/video/BV1Rq4y1S7S8?p=11">摘要怎么写</a></strong></p>
</blockquote>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><p>​	所有变量都是一次方</p>
<h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><p>​	至少有一个变量不是一次方,多次方,三角函数等</p>
<h1 id="多目标规划"><a href="#多目标规划" class="headerlink" title="多目标规划"></a>多目标规划</h1><p>​	题目中不止有一个目标,前面规划问题只有一个目标,比如产量最大,而多目标规划有多个目标,比如尽量使用更多生产设备和产品1产量不超过产品2的产量</p>
<p>​	要衡量每个目标的完成情况并在主观上区分三个目标的重要性</p>
<p>​	引入三个概念:正负偏差变量,绝对约束和目标约束,优先因子</p>
<ul>
<li>正负偏差变量用于衡量每个目标的完成情况</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92.png"></p>
<ul>
<li>绝对约束和目标约束</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/%E7%BB%9D%E5%AF%B9%E7%BA%A6%E6%9D%9F%E5%92%8C%E7%9B%AE%E6%A0%87%E7%BA%A6%E6%9D%9F.png"></p>
<ul>
<li>优先因子</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/%E4%BC%98%E5%85%88%E5%9B%A0%E5%AD%90.png"></p>
<p>​	目标函数中的P1,P2,P3即为优先因子,P1越大,则d1+就需要更小才能使P1*d1+ 值不变,即d1+更重要</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/202308010955892.png"></p>
<p>​	求解方法:fgoalattain函数,Lingo求解或序贯算法</p>
<ul>
<li><strong>当出现使XXX最大&#x2F;最小,同时 “尽量” XXX时,考虑使用多目标规划</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>网络交互</title>
    <url>/2023/08/12/%E7%BD%91%E7%BB%9C%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h1 id="1-网络是怎么交互的"><a href="#1-网络是怎么交互的" class="headerlink" title="1.网络是怎么交互的"></a>1.网络是怎么交互的</h1><h2 id="1-2-路由"><a href="#1-2-路由" class="headerlink" title="1.2 路由"></a>1.2 路由</h2><p>​	通过路由来接入服务器,通过配置默认路由或匹配详细路由确定路径\</p>
<ul>
<li><p>路由不一定是对称的,来回的路由路径不一定是相同的</p>
</li>
<li><p>路由工作在传输层协议</p>
</li>
<li><p>路由不更改IP地址,而是更改MAC地址来确定下一跳,找到发包口</p>
</li>
<li><p>发包需要指定网卡</p>
</li>
</ul>
<h2 id="1-3ARP协议"><a href="#1-3ARP协议" class="headerlink" title="1.3ARP协议"></a>1.3ARP协议</h2><p>​	通过ARP协议来找到下一跳的MAC</p>
<ul>
<li>通过广播并接受响应来确定下一跳的MAC地址,注意只有逻辑同网段才能发送ARP</li>
<li>ARP请求广播,ARP应答单播</li>
<li>添加设备时发送一个免费ARP,防止IP冲突</li>
</ul>
<h2 id="1-4-IP协议"><a href="#1-4-IP协议" class="headerlink" title="1.4 IP协议"></a>1.4 IP协议</h2><ul>
<li>IP地址是唯一表示,互联网通用,客户端一个,服务端也只有一个</li>
<li>IPv4不够用则通过IPv6解决</li>
</ul>
<h2 id="1-5-NAT"><a href="#1-5-NAT" class="headerlink" title="1.5 NAT"></a>1.5 NAT</h2><ul>
<li>内部使用NAT服务器,在内网中再分配地址,客户端通过NAT接入外部网络</li>
<li>NAT改变 IP地址和端口地址,避免多个内网客户端访问同一个目标地址和端口,而源端口一致导致冲突</li>
</ul>
<h1 id="2-网络传输"><a href="#2-网络传输" class="headerlink" title="2. 网络传输"></a>2. 网络传输</h1><h2 id="2-1数据包"><a href="#2-1数据包" class="headerlink" title="2.1数据包"></a>2.1数据包</h2><ul>
<li>填充完数据包后需要进行封装,按层次封装,解包顺序和封装顺序相反</li>
</ul>
<h2 id="2-2-请求DNS"><a href="#2-2-请求DNS" class="headerlink" title="2.2 请求DNS"></a>2.2 请求DNS</h2><ul>
<li>客户端发送网址的解析请求</li>
<li>DNS服务器通过递归迭代来解析网址,有根域服务器,顶级域服务器和权威服务器</li>
</ul>
<h2 id="2-3-UDP"><a href="#2-3-UDP" class="headerlink" title="2.3 UDP"></a>2.3 UDP</h2><ul>
<li>UDP本身相对简单</li>
<li>通过UDP自己实现一个协议较为困难,从根本上来讲要解决怎么保证协议可靠的问题<ul>
<li>发包每次发多少?怎么避免分片</li>
<li>怎么知道是否丢包</li>
<li>怎么权衡传输效率和质量</li>
</ul>
</li>
</ul>
<h2 id="2-4-TCP"><a href="#2-4-TCP" class="headerlink" title="2.4 TCP"></a>2.4 TCP</h2><ul>
<li><p>TCP通过三次握手建立连接,三次握手的目标是确定会话双方都可以正确发送和接受信息</p>
</li>
<li><p>TCP传输:包括sequence number表示发送方发送的序列号,acknowledge number:是发送方期望接受方下一次发送的sequence number</p>
</li>
<li><p>SYN&#x2F;FIN传输不携带数据,但会使packet seq会加1,但ACK传输不会增加packet seq</p>
</li>
<li><p>通过seq num和ack num来确定消息被成功接收</p>
</li>
<li><p>滑动窗口,流量控制</p>
</li>
</ul>
<h2 id="2-5-HTTP1-1"><a href="#2-5-HTTP1-1" class="headerlink" title="2.5 HTTP1.1"></a>2.5 HTTP1.1</h2><p>​	相对于HTTP&#x2F;1.0使用长连接和管道传输和缓存</p>
<h2 id="2-6-HTTPS"><a href="#2-6-HTTPS" class="headerlink" title="2.6 HTTPS"></a>2.6 HTTPS</h2><p>HTTPS在HTTP基础上发展而来,通过在HTTP和TCP网络层之间加入<strong>SSL&#x2F;TLS</strong>安全协议,解决了HTTP的三大风险</p>
<ul>
<li>信息加密:将信息加密,解决窃听风险;</li>
<li>校验机制:验证报文是否被篡改,解决篡改风险</li>
<li>身份证书:验证通信双方身份,解决伪装风险</li>
</ul>
<h1 id="3-网络架构如何为抖音提速"><a href="#3-网络架构如何为抖音提速" class="headerlink" title="3.网络架构如何为抖音提速"></a>3.网络架构如何为抖音提速</h1><h2 id="3-1HTTP2-0"><a href="#3-1HTTP2-0" class="headerlink" title="3.1HTTP2.0"></a>3.1HTTP2.0</h2><p>​	通过HTTP2.0来为服务提速,HTTP2.0使用多路复用来提高效率</p>
<ul>
<li>在同一个TCP连接通道中存在多个stream,以串行的形式复用,从外表来看是并发请求资源</li>
<li>存在TCP队头阻塞问题</li>
</ul>
<h2 id="3-2-QUIC-x2F-HTTP3-0"><a href="#3-2-QUIC-x2F-HTTP3-0" class="headerlink" title="3.2 QUIC&#x2F;HTTP3.0"></a>3.2 QUIC&#x2F;HTTP3.0</h2><p>​	HTTP&#x2F;3.0将HTTP下层协议从<strong>TCP协议改为UDP协议</strong>,通过基于UDP的QUIC协议也可以实现类似TCP的可靠性传输</p>
<ul>
<li><p>解决了TCP队头阻塞的问题</p>
</li>
<li><p>具有弱网优势,因为弱网环境丢包率高</p>
</li>
</ul>
<h2 id="3-3数据中心分布"><a href="#3-3数据中心分布" class="headerlink" title="3.3数据中心分布"></a>3.3数据中心分布</h2><p>​	数据分布在核心机房和边缘机房中</p>
<h2 id="3-4-动态API"><a href="#3-4-动态API" class="headerlink" title="3.4 动态API"></a>3.4 动态API</h2><p>​	通过动态API进行路径优化(DSA)</p>
<h1 id="4-网络架构如何为抖音提质"><a href="#4-网络架构如何为抖音提质" class="headerlink" title="4.网络架构如何为抖音提质"></a>4.网络架构如何为抖音提质</h1><h2 id="4-1-容灾"><a href="#4-1-容灾" class="headerlink" title="4.1 容灾"></a>4.1 容灾</h2><p>​	容灾包括故障发生,故障感知,自动切换和服务恢复</p>
<ul>
<li><p>专线容灾,在两个机房之间通过专线连接进行容灾</p>
</li>
<li><p>外网容灾,通过互联网连接两个机房</p>
</li>
<li><p>全局容灾,在解析时若发现某个机房不可用,就自动排除该机房,感知故障后,在确定另一个机房可以承担负载后,将请求自动解析到另一个机房中</p>
</li>
<li><p>主动降级容灾,预装SDK,若发生故障实现降级容灾,避免客户端访问故障机房.若场景无法嵌入SDK,就无法使用这种容灾</p>
</li>
</ul>
<h2 id="4-2故障排查"><a href="#4-2故障排查" class="headerlink" title="4.2故障排查"></a>4.2故障排查</h2><p>​	出现了容灾系统无法解决的故障,就要排查故障并处理,步骤分为:故障明确,故障止损和分段排查</p>
<h3 id="4-2-1-故障明确"><a href="#4-2-1-故障明确" class="headerlink" title="4.2.1 故障明确"></a>4.2.1 故障明确</h3><ul>
<li>出现什么故障,什么业务故障,什么接口故障等</li>
<li>故障体现在哪里</li>
<li>是否是修改导致的故障</li>
</ul>
<h3 id="4-2-2-故障止损"><a href="#4-2-2-故障止损" class="headerlink" title="4.2.2 故障止损"></a>4.2.2 故障止损</h3><ul>
<li>先止损再排查</li>
<li>有容灾就通过容灾止损,没有容灾就进行降级</li>
</ul>
<h3 id="4-2-3-分段排除"><a href="#4-2-3-分段排除" class="headerlink" title="4.2.3 分段排除"></a>4.2.3 分段排除</h3><ul>
<li>客户端排查</li>
<li>服务端排查</li>
<li>中间链路排查</li>
</ul>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
  </entry>
  <entry>
    <title>计网1</title>
    <url>/2023/07/10/%E8%AE%A1%E7%BD%911/</url>
    <content><![CDATA[<h1 id="1-1什么是Internet"><a href="#1-1什么是Internet" class="headerlink" title="1.1什么是Internet"></a>1.1什么是Internet</h1><ul>
<li><p>PDU:协议数据单元 </p>
</li>
<li><p>协议规范: 语法,语义,时序,动作</p>
</li>
</ul>
<h1 id="1-2网络边缘"><a href="#1-2网络边缘" class="headerlink" title="1.2网络边缘"></a>1.2网络边缘</h1><ul>
<li><p>网络边缘:主机,应用程序等       </p>
</li>
<li><p>网络核心:路由器,网络的网络等,作用是:<strong>数据交换的作用</strong>,使数据能被正确发送和接受</p>
</li>
</ul>
<p>​	客户端服务器模式(C&#x2F;S模型),缺点是服务器宕机时损失较大,可拓展性比较差,当请求达到一定阈值时效率断崖式下降</p>
<p>​	对等模式(peer to peeer),很少或者没用专门的服务器,每个节点既是客户端又是服务器,可拓展性较好</p>
<h2 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h2><p>TCP下层传输提供的服务是不可靠的,TCP通过自身使其对上层提供的服务是可靠的</p>
<ul>
<li>可靠地,按顺序地传输数据<ul>
<li>确认接受到的数据,数据损坏时重传,不错不丢不重复不失序</li>
</ul>
</li>
<li>流量控制<ul>
<li>控制发送数据的速度,协调发送方和接受方的速度</li>
</ul>
</li>
<li>拥塞控制<ul>
<li>网络拥塞时降低发送速度</li>
</ul>
</li>
</ul>
<h1 id="1-3网络核心"><a href="#1-3网络核心" class="headerlink" title="1.3网络核心"></a>1.3网络核心</h1><h2 id="1-线-电-路交换"><a href="#1-线-电-路交换" class="headerlink" title="1.线(电)路交换"></a>1.线(电)路交换</h2><ul>
<li>线路交换独享资源,独占一条线路,建立连接后可以保证性能,但若没有数据发送,就会浪费改线路资源</li>
<li>常用于传统电话等</li>
<li>不适合在计算机之间通信,因为计算机通信具有很强的突发性</li>
</ul>
<p>线路交换的每一条线路是通过分割带宽实现的,分割方式有 频分,时分,波分(光通信)</p>
<ul>
<li>频分(FDM)是分配线路中的可通信频率,信号的不同频率分为不同的线路</li>
<li>时分(TDM)是分配时间片,将一个周期分割,每一部分代表一个线路</li>
<li>波分(WDM)分割波段,,每个线路使用一个小波段,在光通信时使用</li>
</ul>
<h3 id="计算传输时间"><a href="#计算传输时间" class="headerlink" title="计算传输时间"></a>计算传输时间</h3><p>T&#x3D;建立连接所需时间+发送时间(文件大小&#x2F;带宽)+传播延时(物理信号在线路中传输时间,距离较小时可忽略)</p>
<p>一个bit在传输中持续的时间&#x3D; 发送时间(1bit&#x2F;带宽)+传输延时(距离&#x2F;光速)</p>
<h2 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2.分组交换"></a>2.分组交换</h2><ul>
<li>线路资源共享,按需使用,一旦使用就使用全部带宽</li>
<li>以分组为单位进行存储-转发方式,到达一个节点后线先存储到该节点后再发送到下一个节点,最终传送到目标主机</li>
<li>若不使用存储转发,那么会占用主机到目标主机之间的全部线路,造成浪费,使用存储-转发方式,则只占用两个节点间的线路</li>
</ul>
<h3 id="计算传输时间-1"><a href="#计算传输时间-1" class="headerlink" title="计算传输时间"></a>计算传输时间</h3><p>假设带宽为R bps,分组大小为L bits,主机之间有n个节点</p>
<p>T&#x3D;(n+1)*(L&#x2F;R)…….n个节点需要n+1次存储转发,存储时间和转发时间只用计算一次,因为发送和接收是同时进行的</p>
<h3 id="排队延迟和丢失"><a href="#排队延迟和丢失" class="headerlink" title="排队延迟和丢失"></a>排队延迟和丢失</h3><p>若到达速率大于链路的输出速率,分组将排队等待传输,若路由器(节点)缓存已慢,则后续分组后被抛弃</p>
<h3 id="网络核心关键功能"><a href="#网络核心关键功能" class="headerlink" title="网络核心关键功能"></a>网络核心关键功能</h3><ul>
<li>路由:决定分组采用的原到目标的路径(路由算法)，路由表会不断变化，导致路径也发生变化</li>
<li>转发:将分组从路由器的输入链路转移到输出链路</li>
</ul>
<p>​	分组交换使用统计多路复用,划分时间片没有固定的模式,根据实际情况进行划分,与时分复用的区别是时分使用固定的划分方式</p>
<h3 id="数据报（datagram）和虚电路（virtual-circuit）"><a href="#数据报（datagram）和虚电路（virtual-circuit）" class="headerlink" title="数据报（datagram）和虚电路（virtual circuit）"></a>数据报（datagram）和虚电路（virtual circuit）</h3><p>数据报：</p>
<ul>
<li>在通信前无需建立连接，有数据就传输</li>
<li>每一个分组都独立路由，若路径不一样，可能失序</li>
<li>路由器根据分组的目标地址进行路由，路由不维护主机间的通信</li>
</ul>
<p>虚电路：</p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/%E8%99%9A%E7%94%B5%E8%B7%AF.png"></p>
<ul>
<li><p>通过查虚电路表确定路径，两个主机在通信前需要建立虚电路，确定虚电路表项，虚电路号也可能变化</p>
</li>
<li><p>虚电路需要维护两主机间的连接</p>
</li>
</ul>
<h1 id="1-4接入网和物理媒体"><a href="#1-4接入网和物理媒体" class="headerlink" title="1.4接入网和物理媒体"></a>1.4接入网和物理媒体</h1><ul>
<li>接入方式:<ul>
<li>住宅接入网络: modem调制解调器,DSL,ADSL,线缆网络(FDM,共享带宽)</li>
<li>单位接入网络(学习,公司等)</li>
<li>无线接入网</li>
</ul>
</li>
</ul>
<h1 id="1-5Internet结构和ISP"><a href="#1-5Internet结构和ISP" class="headerlink" title="1.5Internet结构和ISP"></a>1.5Internet结构和ISP</h1><ul>
<li><p>设备通过接入ISP接入互联网,接入ISP都是互联的</p>
</li>
<li><p>每个接入ISP都连接到全局ISP,不同运营商有不同的全局ISP,不同的全局ISP再连接到一起,形成网络的网络</p>
</li>
</ul>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构:"></a>网络结构:</h2><ul>
<li><p>中心:第一层ISP,国家或国际覆盖,速率极高,与其他一层ISP对等连接或通过IXP相连,与大量第二层ISP和其他客户网络不对等连接</p>
</li>
<li><p>中心通过多层下级ISP连接到Local ISP到达客户</p>
</li>
</ul>
<h2 id="ISP连接方式"><a href="#ISP连接方式" class="headerlink" title="ISP连接方式:"></a>ISP连接方式:</h2><ul>
<li>POP: 高层ISP面向客户网络的接入点,非对等连接,涉及费用结算.一个低层ISP可接入多个高层ISP</li>
<li>对等接入: ISP对等连接,不涉及费用结算</li>
<li>IXP:多个对等ISP的互联互通处,对等连接,通常不涉及费用结算</li>
<li>ICP专网,同时和各级ISP连接</li>
</ul>
<h1 id="1-6分组延迟-丢失和吞吐量"><a href="#1-6分组延迟-丢失和吞吐量" class="headerlink" title="1.6分组延迟,丢失和吞吐量"></a>1.6分组延迟,丢失和吞吐量</h1><ul>
<li>分组丢失:分组到达速率超过链路输出能力,节点已满,后续到达的节点被丢弃</li>
<li>分组延迟:在节点中等待被发送的时间,排队</li>
</ul>
<h2 id="四种延迟"><a href="#四种延迟" class="headerlink" title="四种延迟"></a>四种延迟</h2><ol>
<li><p>处理延迟:检查是否出错(bit级差错),以及根据数据头部决定数据发送的路径</p>
</li>
<li><p>排队延迟:到达节点到从节点发送的延迟</p>
<ul>
<li>流量强度I&#x3D;La&#x2F;R (R:带宽,L:分组的大小,a:单位时间内要通过链路的分组数量)</li>
</ul>
</li>
<li><p>传输延迟:将分组发送到链路上的时间,由带宽和分组大小决定</p>
</li>
<li><p>传播延迟:物理信号在链路中的传播时间,由链路长度和传播速度决定</p>
</li>
</ol>
<p>每一跳的总时间&#x3D;处理延迟+排队延迟+传输延迟+传播延迟</p>
<h2 id="延迟检测"><a href="#延迟检测" class="headerlink" title="延迟检测"></a>延迟检测</h2><ul>
<li>每个分组有TTL(time to leave)存活时间,每到一个节点减一,减为0时抛弃并向主机发送ICMP控制报文</li>
<li>检测延迟时,将TTL设为1可以检测第一个节点的延迟,设为2可以检测第二个等等,就可以得到往返延迟\</li>
<li>如何判断结束检测:检测次数足够大使可以到达目标主机,设置特殊的端口,到达对方主机时,发送ICMP报文,报告端口被占用无法接受数据,即目标端口不可达,就可以判断检测结束</li>
</ul>
<h1 id="1-7协议层次和服务模型"><a href="#1-7协议层次和服务模型" class="headerlink" title="1.7协议层次和服务模型"></a>1.7协议层次和服务模型</h1><p>​	层次化模型,每一层提供多个服务,通过层间接口向上层提供服务</p>
<ul>
<li>服务:低层实体向上层实体提供它们之间通信的能力</li>
<li>原语:上层使用下层服务的形式,高层使用下层的服务,低层向上层提供服务都通过服务访问原语进行交互</li>
<li>服务访问点SAP:下层实体支撑上层多个实体,SAP用于区分不同的上层实体</li>
</ul>
<h2 id="数据单元DU"><a href="#数据单元DU" class="headerlink" title="数据单元DU"></a>数据单元DU</h2><p>上层发送SDU(服务数据单元),通过SAP到达本层,把SDU加上本层的头部,形成本层PDU(协议数据单元)</p>
<p>若SDU较大,则将SDU分解成为小部分,各自加上本层的头部,形成本层PDU</p>
<p>若SDU较小,将多个SDU合并,加上本层头部,形成本次PDU</p>
<h2 id="分层处理的好处"><a href="#分层处理的好处" class="headerlink" title="分层处理的好处"></a>分层处理的好处</h2><ul>
<li>分而治之,结构清晰,大问题分解为小问题,便于独立设计和解决</li>
<li>保持接口不变,每一层可以在不影响其他层的情况下进行升级或改变</li>
</ul>
<p>问题:</p>
<ul>
<li>分层后,子系统间需要交换信息,效率会降低</li>
</ul>
<h2 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h2><ul>
<li>物理层: 单位 bit ,将数据转换为物理信号或反转,发送和接收</li>
<li>链路层: 基于物理层提供的服务,传输以 frame 帧为单位的数据,将bit组合成帧,<strong>在相邻两点间传输</strong>,</li>
<li>网络层: 基于链路层提供的服务,以 分组 为单位提供源主机和目标主机的<strong>端到端</strong>(非相连)之间的传输,IP协议</li>
<li>传输层:基于网络层,把数据进行<strong>进程间的区分</strong>,把网络层不可靠的服务通过TCP向上层提供可靠的服务(或其他协议如UDP)</li>
<li>应用层:基于传输层,实现网络应用,如FTP,HTTP等</li>
</ul>
<h2 id="ISO-x2F-OSI参考模型"><a href="#ISO-x2F-OSI参考模型" class="headerlink" title="ISO&#x2F;OSI参考模型"></a>ISO&#x2F;OSI参考模型</h2><ul>
<li>相对于上述层次,在应用层和传输层之间增加了表示层和会话层</li>
<li>互联网协议栈没有这两层,若需要则通过应用自身实现</li>
</ul>
<h2 id="封装和解封装"><a href="#封装和解封装" class="headerlink" title="封装和解封装"></a>封装和解封装</h2><p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85.png"></p>
<ul>
<li>网络接口层指连接链路层</li>
<li>数据从应用经过每一层时,都添加该层的头部,标志各自的信息,进行封装</li>
<li>解封装时根据头部的信息,将数据分配给响应的目标</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计网2</title>
    <url>/2023/07/14/%E8%AE%A1%E7%BD%912/</url>
    <content><![CDATA[<h1 id="2-1-应用原理"><a href="#2-1-应用原理" class="headerlink" title="2.1 应用原理"></a>2.1 应用原理</h1><p>可能的应用架构:</p>
<ul>
<li>C&#x2F;S模式<ul>
<li>可拓展性差</li>
</ul>
</li>
<li>对等模式(p2p) 在该架构中也有客户端和服务器之分,但可以既作为客户端又作为服务器<ul>
<li>管理困难</li>
</ul>
</li>
<li>混合模式</li>
</ul>
<p>用户连接到服务器时,在服务器注册自己的IP来标识自身</p>
<h2 id="分布式通信"><a href="#分布式通信" class="headerlink" title="分布式通信"></a>分布式通信</h2><h3 id="进程标识和寻址问题"><a href="#进程标识和寻址问题" class="headerlink" title="进程标识和寻址问题"></a>进程标识和寻址问题</h3><ul>
<li><p>标识应唯一来标识自己,且包含地址信息</p>
</li>
<li><p>需要: 主机IP,协议UDP&#x2F;TCP,端口port;进程之间可以通过两个端节点标识</p>
</li>
</ul>
<h3 id="传输层-应用层的服务提供"><a href="#传输层-应用层的服务提供" class="headerlink" title="传输层-应用层的服务提供"></a>传输层-应用层的服务提供</h3><ul>
<li>(地点)通过层间SAP(TCP&#x2F;IP:socket),(形式)调用应用程序接口API(TCP&#x2F;IP: socket API),来调用下层提供的服务</li>
<li>层间接口需要携带:<ul>
<li>1.要传输的报文SDU;2.来源:源进程的IP+TCP&#x2F;UDP和端口;3.目标:对方的IP+TCP&#x2F;UDP和端口</li>
</ul>
</li>
<li>传输层实体根据层间接口的信息对数据进行封装,数据+头部</li>
<li>若每次都传输上述数据,对于频繁进行数据交换的进程会造成数据冗余(不必要的收发方标识),使用Socket来解决该问题,建立TCP socket,使进程间通信持续一段时间,数据穿过层间接口时只需标识IP和TCP端口,使穿过层间接口的信息量最小,代表是本地四元组标识(源IP,源port,目标IP,目标port),不必在每一个报文发送时都指导该四元组</li>
<li>UDP socket,不需要建立连接,因此只用一个整数表示本应用实体的表示,但传输报文时需提供对方IP和port,传输时需要三个信息:报文,UDP socket,对方IP和port</li>
<li>UDP使用二元组(IP,port)表示,只用标志目标,不需要表示自身</li>
</ul>
<h3 id="如何使用下层服务-实现进程之间交换报文"><a href="#如何使用下层服务-实现进程之间交换报文" class="headerlink" title="如何使用下层服务,实现进程之间交换报文"></a>如何使用下层服务,实现进程之间交换报文</h3><p>​	定义应用层协议:报文格式,解释,时序等,编制程序使用OS提供的API调用下层服务,定义了在不同端系统上的应用进程如何交换报文</p>
<h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><ul>
<li>数据丢失率</li>
<li>延迟</li>
<li>吞吐</li>
<li>安全性</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ol>
<li>可靠的传输服务;</li>
<li>流量控制;</li>
<li>拥塞控制;</li>
<li>面向连接;</li>
</ol>
<p>但不能提供时间保证,最小吞吐保证和安全</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ol>
<li>不可靠数据传输服务</li>
<li>不提供:流量控制,拥塞控制,时间,带宽保证,连接</li>
<li>UDP速度快,延迟低,IP也不提供上述服务,但只能区分主机到主机,不能区分进程</li>
</ol>
<p>TCP和UDP都不进行加密,通过明文传输,SSL在TCP上实现,提供加密TCP连接,保证安全性,完整性检测,端到端鉴别</p>
<h1 id="2-2-Web-and-HTTP"><a href="#2-2-Web-and-HTTP" class="headerlink" title="2.2 Web and HTTP"></a>2.2 Web and HTTP</h1><h2 id="URL-通用资源定位符-唯一标识"><a href="#URL-通用资源定位符-唯一标识" class="headerlink" title="URL:通用资源定位符,唯一标识"></a>URL:通用资源定位符,唯一标识</h2><p>格式:协议名+用户+口令+主机名+路径名+端口号</p>
<p>协议确定是用http还是ftp等协议,匿名访问可以省略用户名和口令,协议有默认端口号,非特殊情况不需要指定</p>
<h2 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP:超文本传输协议"></a>HTTP:超文本传输协议</h2><ul>
<li>Web应用层协议</li>
<li>采用C&#x2F;S模型</li>
</ul>
<h2 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h2><p>一个小的分组从客户端到服务器再回到客户端的时间(忽略传输时间)</p>
<p>一个RTT用来发起TCP连接,再有一个RTT用来HTTP请求并等待HTTP响应</p>
<p>总的文件传输时间: 2个RTT加上传输时间</p>
<h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>若有10个URL,非流水线处理为发出一个请求,收到响应后再发送下一个请求</p>
<p>而流水线形式为所有URL都发送,不需要等待前一个返回再进行下一个</p>
<h2 id="提交表单的形式"><a href="#提交表单的形式" class="headerlink" title="提交表单的形式"></a>提交表单的形式</h2><ul>
<li>post方式,网页通常包括表单输入,包含在实体主体中的输入被提交到服务器</li>
<li>URL方式,通过GET方法获取</li>
</ul>
<p>还有HEAD,PUT,DELETE等,不同HTTP版本也有区别</p>
<h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h2><p>​	不访问原始服务器就满足需求,加快速度,减少服务器负担,28原理,80%的人访问20%的资源,将这些资源缓存,可以提高效率.缓存对于原始服务器是客户端,而对于用户则作为服务器</p>
<p>​	缓存示例:</p>
<p>​                                                  	<img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/%E7%BC%93%E5%AD%98%E7%A4%BA%E4%BE%8B.png"></p>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/%E7%BC%93%E5%AD%98%E7%A4%BA%E4%BE%8B3.png"></p>
<p>增大带宽以减少排队等待时间,但费用增加</p>
<p>具体讲解:P14 1:11:0</p>
<h1 id="2-5-DNS"><a href="#2-5-DNS" class="headerlink" title="2.5 DNS"></a>2.5 DNS</h1><p>​	域名解析系统,最重要的功能是将提供的域名(或别名)解析为IP地址,运行在UDP协议的53号端口上,解析时,从顶到下开始,从根名字服务器到顶级域服务器再向下,直至IP地址</p>
<h2 id="层次化"><a href="#层次化" class="headerlink" title="层次化"></a>层次化</h2><ul>
<li><p>通过层次化命名,解决重名问题,NDS采用层次树状结构命名</p>
</li>
<li><p>将Internet分为几百个顶级域,顶级域分为通用的(.com;.edu)和国家的(.cn .us)</p>
</li>
<li><p>每个域下再化为多个子域</p>
</li>
<li><p>叶子节点是主机</p>
</li>
</ul>
<p>​	一个域管理其下的子域,域与物理网络无关,域的划分是逻辑上的而不是物理上的</p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>​	问题:可靠性问题(单点故障),扩展性问题(通信容量),维护问题</p>
<p>​	TLD服务器(顶级域服务器),负责顶级域名和所有国家级顶级域名,如Network solutions公司维护 com TLD服务器</p>
<p>​	服务器通过资源记录维护:域名-IP地址的映射关系,位置在服务器的分布式数据库中,格式为RR格式,包括以下字段:</p>
<ul>
<li>Class:资源类型,对应Internet,值为IN,即DNS不止处理互联网内容</li>
<li>TTL:资源生存时间(对于自身的资源,TTL为无限大,而对于从其他服务器获取的资源,则TTL是一个有限值,即作为缓存的生存时间), </li>
<li>Domain_name: 存储域名到IP地址的映射关系 </li>
<li>Value:值</li>
<li>Type:记录资源类别,值有 A,CNAME,NS,MX</li>
</ul>
<p>​	解析大致过程:本地调用解析器,解析器向名称服务器发送请求(已预先配置好名称服务器的地址),服务器返回响应信息.若local server没有缓存信息,从下往上走到有信息的服务器(最高到根DNS服务器),再从有信息的服务器向下查询,最后返回结果.</p>
<p>​	DNS查询和响应报文给格式相同</p>
<h1 id="2-6-P2P"><a href="#2-6-P2P" class="headerlink" title="2.6 P2P"></a>2.6 P2P</h1><p>​	C&#x2F;S模式中,下载时间受服务器上载时间和客户端下载时间限制,总下载时间为两者中的最大值,由于服务器上载带宽有限,随着请求增多,效率会快速下降 </p>
<p>​	P2P中随着请求增加,Peer节点数也会增加,下载时间的增加非常缓慢,效率大于C&#x2F;S模式,高度动态,难以管理</p>
<h2 id="管理模式"><a href="#管理模式" class="headerlink" title="管理模式"></a>管理模式</h2><h3 id="非结构化P2P"><a href="#非结构化P2P" class="headerlink" title="非结构化P2P"></a>非结构化P2P</h3><ul>
<li>相互通信间的peer节点间构成覆盖网,两个节点间形成一条边,是逻辑上的,非物理的,节点间的关系是任意的</li>
<li>集中化目录:目录服务器中存储集中化目录,通过查询集中化目录建立连接,节点上线或下线时需要向服务器报告,并说明自身存储的资源,存在单点故障问题</li>
<li>完全分布式:没有某个节点维护其他节点信息,没有中心服务器;泛洪查询:查询时,先查询自身邻居,邻居再向邻居的邻居查询,有资源的节点应答,通过设置TTL限制查询距离</li>
<li>混合式:peer间划分为组,组长之间对等,组员向组长发出查询,若组内有,则从组内获取,若组内没有,则组长向其他组长发出查询,组长通过哈希值来唯一标识文件</li>
<li>BitTorrent:请求过多时,不是先来后到来分配,而是每个周期评估每个节点对自身的贡献(即该节点向自己提供过资源),先疏通贡献高的节点,再向后改为随机选择节点</li>
</ul>
<h3 id="结构化P2P"><a href="#结构化P2P" class="headerlink" title="结构化P2P"></a>结构化P2P</h3><ul>
<li>节点之间不是任意的,维护的是树状,环状等结构,对每个节点唯一标识,通过节点间的关于可以快速查询</li>
<li>了解即可</li>
</ul>
<h1 id="2-7-CDN"><a href="#2-7-CDN" class="headerlink" title="2.7 CDN"></a>2.7 CDN</h1><p>​	如何向大量用户提供互联网杀手级业务(带宽占用大,如视频业务等),如何满足异构性(不同的用户的能力不同,如有线网无线网,设备处理能力等)</p>
<ul>
<li>压缩</li>
<li>流化技术</li>
</ul>
<p>​	靠单一服务器提升带宽无法解决该问题,有距离远,单点故障,流量浪费(重复资源)</p>
<p>​	通过CDN实现,全网部署缓存节点,预先缓存,为用户就近提供服务,可以将CDN服务器深入部署到接入网(local isp内部),数量多接近用户但管理困难,另一种是部署在少数(10个左右)关键位置,如距离数据中心机房距离近(距离1st ISP距离近),也可以提供较好的服务</p>
<p>​	OTT挑战:在拥塞的互联网上复制内容,从哪个CDN节点获取,CDN中存储了什么内容,用户会做出什么请求</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计网:传输层</title>
    <url>/2023/07/24/%E8%AE%A1%E7%BD%91%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="1-多路复用"><a href="#1-多路复用" class="headerlink" title="1.多路复用"></a>1.多路复用</h1><ul>
<li>TCP 报文通过携带 源IP,源Port,目标IP和目标Port,TCP使用4元组的形式发送信息,实现复用和解复用</li>
<li>UDP 报文通过一个cad,指向目标端口和IP等信息,自身端口和IP存储在socket中</li>
<li>UDP复用:即使报文的源IP和端口不同,都会被发送到目标IP和端口,无连接</li>
<li>发送方多路复用:从多个套接字接收来自多个进程的报文,根据套接字对应的IP地址和端口号对报文进行封装</li>
<li>接收方解复用:根据报文头部信息的IP地址和端口号将报文段发送给正确的套接字和对应的进程</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP的好处:</p>
<ul>
<li>不建立连接,延迟低</li>
<li>简单</li>
<li>报文段头部很小,减少开支</li>
<li>无拥塞控制和流量控制,可以尽可能快地发送报文</li>
</ul>
<p>​	UDP校验和,检测差错,发送方将报文段内容视作16bit整数,校验和为报文段的加法和(1的补运算),发送方将校验和放在UDP的校验和字段,接收方计算并比较校验和,不一致则出现差错,但一致也可能出现差错,如残存错误</p>
<p>​	检验和时,若有进位,则进位回滚,校验和是两个16bit整数相加,进位回滚后的反码</p>
<h1 id="2-可靠数据传输-rdt-原理"><a href="#2-可靠数据传输-rdt-原理" class="headerlink" title="2.可靠数据传输(rdt)原理"></a>2.可靠数据传输(rdt)原理</h1>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>青训营HTTP</title>
    <url>/2023/08/01/%E9%9D%92%E8%AE%AD%E8%90%A5HTTP/</url>
    <content><![CDATA[<h1 id="HTTP介绍"><a href="#HTTP介绍" class="headerlink" title="HTTP介绍"></a>HTTP介绍</h1><p>​	HTTP即超文本传输协议(Hypertext Transfer Protocol)马,超链接,图片,视频等都属于超文本##</p>
<h2 id="为什么需要协议"><a href="#为什么需要协议" class="headerlink" title="为什么需要协议"></a>为什么需要协议</h2><ul>
<li>需要明确的边界,信息的开始和结束</li>
<li>能够携带信息,包括什么信息,信息的类型等</li>
</ul>
<h2 id="协议里有什么"><a href="#协议里有什么" class="headerlink" title="协议里有什么"></a>协议里有什么</h2><ul>
<li><p>请求行&#x2F;状态行</p>
<ul>
<li>请求行包括方法名(GET,POST等),URL和协议版本</li>
<li>状态行包括协议版本,状态码,状态码描述等</li>
</ul>
</li>
<li><p>请求头&#x2F;相应头</p>
</li>
<li><p>请求体&#x2F;相应体</p>
</li>
</ul>
<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>​	客户端业务层-&gt;中间件层-&gt;协议编码解码层-&gt;传输层-&gt;服务器传输层</p>
<p>​	服务器传输层-&gt;编码解码层-&gt;路由层-&gt;中间件层-&gt;服务器业务层-&gt;</p>
<h2 id="HTTP的演化"><a href="#HTTP的演化" class="headerlink" title="HTTP的演化"></a>HTTP的演化</h2><h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>​	相对于HTTP&#x2F;1.0使用长连接和管道传输</p>
<p>​	存在的性能瓶颈:</p>
<ul>
<li>头部不压缩,只压缩Body,首部信息越大延迟越大</li>
<li>发送重复的头部信息浪费大</li>
<li>存在响应的队头阻塞</li>
<li>没有请求优先级</li>
<li>请求只能由客户端发出,服务器只能被动响应</li>
</ul>
<h3 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p>HTTP&#x2F;2.0基于HTTPS</p>
<h4 id="相对于HTTP-x2F-1-1"><a href="#相对于HTTP-x2F-1-1" class="headerlink" title="相对于HTTP&#x2F;1.1"></a>相对于HTTP&#x2F;1.1</h4><ul>
<li><p>头部压缩</p>
</li>
<li><p>二进制格式</p>
</li>
<li><p>并发传输</p>
</li>
<li><p>服务器可主动推送资源</p>
</li>
</ul>
<p>​	服务器和客户端都可建立Stream,服务器的Stream ID必须是偶数,客户端必须是奇数;若客户端请求一个HTML文件,但需要CSS文件来渲染,使用HTTP&#x2F;2.0就不需要再发送一次请求获取CSS,服务器主动发送CSS文件,提高效率</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>​	HTTP&#x2F;2.0解决了HTTP&#x2F;1.1的响应队头阻塞,解决了HTTP层的队头阻塞问题,但仍存在队头阻塞问题;由于HTTP&#x2F;2.0基于TCP协议,TCP必须保证接受到的字节数据完整且连续,若存在字节缺失,则后面收到的信息全部阻塞到缓冲区中,直到重新发送该缺失字节</p>
<p>​	所以一旦丢包,就会触发TCP重传,在<strong>一个TCP连接中的所有HTTP请求都必须等待该包被重传</strong></p>
<h2 id="HTTP-x2F-3-0"><a href="#HTTP-x2F-3-0" class="headerlink" title="HTTP&#x2F;3.0"></a>HTTP&#x2F;3.0</h2><p>​	HTTP&#x2F;3.0将HTTP下层协议从<strong>TCP协议改为UDP协议</strong>,通过基于UDP的QUIC协议也可以实现类似TCP的可靠性传输</p>
<p>​	QUIC有以下三个特点:</p>
<ul>
<li><p>无队头阻塞</p>
</li>
<li><p>更快建立连接</p>
</li>
<li><p>连接迁移</p>
</li>
</ul>
<h1 id="HTTP框架的设计与实现"><a href="#HTTP框架的设计与实现" class="headerlink" title="HTTP框架的设计与实现"></a>HTTP框架的设计与实现</h1><h2 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h2><p>​	HTTP协议专注于OSI七层网络的第四层往上,应用层,表示层和会话层,即TCP&#x2F;IP四层概念模型的应用层</p>
<p>​	分层设计:高内聚,低耦合,易复用和高拓展性</p>
<p>​	一个切实可行的复杂系统势必是从一个切实可行的简单系统发展而来的。从头开始设计的复杂系统根本不切实可行，无法修修补补让它切实可行。你必须由一个切实可行的简单系统重新开始。</p>
<h2 id="应用层设计"><a href="#应用层设计" class="headerlink" title="应用层设计"></a>应用层设计</h2><ul>
<li>提供合理的API<ul>
<li>可理解性:使用ctx.Body(),不要用ctx.BodyA(),A意义不明</li>
<li>简单性</li>
<li>冗余性</li>
<li>兼容性</li>
<li>可测性</li>
<li>可见性</li>
</ul>
</li>
</ul>
<h2 id="中间件设计"><a href="#中间件设计" class="headerlink" title="中间件设计"></a>中间件设计</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li>配合 Handler实现一个完整的请求处理生命周期</li>
<li>拥有预处理逻辑与后处理逻辑</li>
<li>可以注册多中间件</li>
<li>对上层模块用户逻辑模块易用</li>
</ul>
<h3 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h3><p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/202308011459349.png"></p>
<ul>
<li>中间件类似调用函数</li>
<li>用户不主动调用下一个处理函数则自动调用,帮助index递增</li>
<li>令index为最大值就可以中值调用</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/YQYjin/blogcdn@master/imgs/202308011503930.png"></p>
<ul>
<li>若不在一个调用链上,需要手动调用Next</li>
</ul>
<h2 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h2><p>​	框架路径实际上就是为URL匹配相应的处理函数,比如静态路由,参数路由,匹配HTTP方法等.</p>
<ul>
<li>用map实现路由,只适用于静态路由</li>
<li>用前缀匹配树优化等</li>
</ul>
<p>如何匹配HTTP方法?</p>
<ul>
<li>构建map,外层map使用Method(string)作为key,路由树作为value,然后在路由树中寻找</li>
</ul>
<h2 id="协议层设计"><a href="#协议层设计" class="headerlink" title="协议层设计"></a>协议层设计</h2><ul>
<li>抽象出合适的接口</li>
</ul>
<h2 id="网络层设计"><a href="#网络层设计" class="headerlink" title="网络层设计"></a>网络层设计</h2><ul>
<li>BIO:阻塞</li>
<li>NIO:非阻塞:netpoll,网络库管理buffer</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>高质量代码</title>
    <url>/2023/07/29/%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="高质量代码"><a href="#高质量代码" class="headerlink" title="高质量代码"></a>高质量代码</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>正确可靠,简洁清晰,易读易维护</p>
</li>
<li><p>简单性:消除多余的复杂性,以简单清晰的逻辑编写代码</p>
</li>
<li><p>可读性:代码是给人看的,编写可维护的代码第一步是确保代码可读</p>
</li>
<li><p>生产力:团队整体效率</p>
</li>
</ul>
<h2 id="编写规范"><a href="#编写规范" class="headerlink" title="编写规范"></a>编写规范</h2><ul>
<li>代码格式化:推荐使用gofmt或goimports自动格式化工具来格式化代码</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>解释代码作用</li>
<li>解释代码是如何做的</li>
<li>应解释代码实现原理</li>
<li>应解释代码为什么这么实现</li>
<li>解释代码限制条件,在什么情况下会出错</li>
<li>公共符号必须要注释,所有库函数必须注释</li>
</ul>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li><p>变量</p>
<ul>
<li><p>简洁胜于冗长</p>
</li>
<li><p>缩略词全大写,但当其位于变量开头且不需要导出时,应使用全小写</p>
</li>
<li><p>变量距离其被使用的地方越远,则需要携带越多上下文信息,使得在不同地方可以辨别出其含义</p>
</li>
</ul>
</li>
<li><p>函数名</p>
<ul>
<li><p>函数名不携带包名上下文信息</p>
</li>
<li><p>函数名尽量简短</p>
</li>
<li><p>若函数功能和包名有差异,应当体现在函数名中</p>
</li>
<li><p>如在http包中,将函数命名为Serve要优于ServerHTTP,因为包名已经体现HTTP了</p>
</li>
</ul>
</li>
<li><p>包名</p>
<ul>
<li>只包含小写字母,不包含下划线等字符</li>
<li>不要与标准库同名</li>
<li>不要使用常用变量名作为包名</li>
<li>使用单数形式而不是复数</li>
<li>谨慎使用缩写,使用缩写要是公认的,不出现歧义</li>
</ul>
</li>
<li><p>控制流程</p>
<ul>
<li>避免if else嵌套,避免不需要的判断</li>
<li>尽量保持正常代码路径为最小缩进,优先处理非正常情况,应尽早返回或继续循环减少嵌套,每步处理一个异常,然后再处理其他异常,而不是一直if else嵌套判断</li>
</ul>
</li>
<li><p>错误和异常处理</p>
<ul>
<li><p>可以使用fmt.Errorf中的%w关键字来关联错误信息</p>
</li>
<li><p>判断错误是否是特定错误,使用errors.Is</p>
</li>
<li><p>在错误链上获取特定错误,使用errors.As</p>
</li>
<li><p>不建议在业务代码中使用panic,若问题可以屏蔽,建议使用error</p>
</li>
<li><p>在程序启动界面,如init和main中,可使用panic</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
  </entry>
</search>
