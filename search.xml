<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>NEXT主题使用说明</title>
    <url>/2022/10/24/NEXT%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a><center>MarkDown</center></h1><h2 id="基本信息配置"><a href="#基本信息配置" class="headerlink" title="基本信息配置"></a>基本信息配置</h2><p>Markdown最上方<code>---</code>分割区域Next预定义参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td>博客名</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
<td>更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类</td>
<td></td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章网址</td>
<td></td>
</tr>
<tr>
<td>excerpt</td>
<td></td>
<td></td>
</tr>
<tr>
<td>disableNunjucks</td>
<td></td>
<td></td>
</tr>
<tr>
<td>lang</td>
<td>语言</td>
<td></td>
</tr>
</tbody></table>
<p>tags和categories等可以设置多个值：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag2</span>	</span><br></pre></td></tr></table></figure>

<p>该方法会使tag2成为tag1的子标签，要设置同级标签，应用一下方式，其中父标签1,2,3是同级标签，categories分类标签同理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签1</span>, <span class="string">子标签1</span>]</span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签2</span>, <span class="string">子标签2</span>]</span><br><span class="line"> <span class="bullet">-</span> [<span class="string">父标签3</span>]</span><br></pre></td></tr></table></figure>

<h1 id="日程表"><a href="#日程表" class="headerlink" title="日程表"></a>日程表</h1><p>由于使用type&#x3D;”schedule”	时无法正确显示Markdown，所以将type改为about</p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>使用本地插入时，绝对路径和相对路径都无法加载图片，所以采用图床的方式插入图片，<a href="https://sm.ms/">SM.MS</a>，上传图片后以网络链接的形式插入图片</p>
]]></content>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟与高精度</title>
    <url>/2022/10/26/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="A-B-Problem"><a href="#A-B-Problem" class="headerlink" title="A*B Problem"></a><center>A*B Problem</center></h1><p>题目：输入A，B，求A*B的值</p>
<p>若A的长度为n，B的长度为m，则A*B的长度&lt;&#x3D;n+m,由此确定结果数组的长度。模拟进行A*B运算，B由低到高每一位与A的每一位相乘，由于I，j从0开始，故可以用i+j确定每位相乘的结果是结果数组的第几位。</p>
<p>进行运算前先把输入的A，B逆序以便于计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* numA = <span class="keyword">new</span> <span class="type">int</span>[a.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="type">int</span>* numB = <span class="keyword">new</span> <span class="type">int</span>[b.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="type">int</span>* res = <span class="keyword">new</span> <span class="type">int</span>[a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">		res[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); ++i) &#123;	<span class="comment">//倒序把字符串转换为数字数组</span></span><br><span class="line">		numA[i] = a[a.<span class="built_in">length</span>() - i - <span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">		numB[i] = b[b.<span class="built_in">length</span>() - i - <span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; b.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">			res[i + j] += numA[i] * numB[j];</span><br><span class="line">			<span class="keyword">if</span> (res[i+j]&gt;<span class="number">9</span>) res[i + j+<span class="number">1</span>] += res[i + j]/<span class="number">10</span>;</span><br><span class="line">			res[i + j] = res[i + j] % <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">false</span>;	<span class="comment">//是否已去除前面的0</span></span><br><span class="line">	<span class="keyword">for</span> (i = a.<span class="built_in">length</span>() + b.<span class="built_in">length</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;	<span class="comment">//输出</span></span><br><span class="line">		<span class="keyword">if</span> (res[i])	flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (flag)	cout &lt;&lt; res[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flag) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;	<span class="comment">//如果全是0，输出一个0</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] numA;</span><br><span class="line">	<span class="keyword">delete</span>[] numB;</span><br><span class="line">	<span class="keyword">delete</span>[] res;</span><br></pre></td></tr></table></figure>

<h1 id="N！之和问题"><a href="#N！之和问题" class="headerlink" title="N！之和问题"></a><center>N！之和问题</center></h1><p>求解阶乘之和</p>
<p>就是把高精乘和高精加结合起来，但在处理高精乘进位时，应该把所有的位数遍历一遍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">90</span>; ++j) &#123;</span><br><span class="line">	<span class="keyword">if</span> (now[j] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">		now[j + <span class="number">1</span>] += now[j] / <span class="number">10</span>;</span><br><span class="line">		now[j] %= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若使用判断的方法，可能会出现这一位不大于9但下面的位大于9的情况，造成出错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(now[count]&gt;<span class="number">9</span>)&#123;	<span class="comment">//进位</span></span><br><span class="line">	now[count + <span class="number">1</span>] += now[count] / <span class="number">10</span>;</span><br><span class="line">	now[count] %=  <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2022/11/06/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><center>二叉树</center></h1><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a><center>遍历</center></h2><p>前序遍历 <code>根-左-右</code>		中序遍历 <code>左-根-右</code>		后序遍历 <code>左-右-根</code></p>
<p><img src="https://s2.loli.net/2022/11/06/FrwMeBjslUpYDuH.png" alt="二叉树图.png"></p>
<p>前序遍历A-B-D-F-G-H-I-E-C</p>
<p>中序遍历F-D-H-G-I-B-E-A-C</p>
<p>后序遍历F-H-I-G-D-E-B-C-A</p>
<p>对二叉树进行遍历，前序和中序用栈而后序用两个栈实现从最后开始输出</p>
<p><em>先序遍历代码实现：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历 非递归先序遍历 头=&gt;左=&gt;右</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk;	<span class="comment">//定义一个栈</span></span><br><span class="line">		stk.<span class="built_in">push</span>(head);</span><br><span class="line">		<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			head = stk.<span class="built_in">top</span>();</span><br><span class="line">			stk.<span class="built_in">pop</span>();</span><br><span class="line">			cout &lt;&lt; head-&gt;val &lt;&lt; endl;	<span class="comment">//处理语句</span></span><br><span class="line">			<span class="keyword">if</span> (head-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>中序遍历代码实现</em>	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归中序遍历	左=&gt;头=&gt;右</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk;</span><br><span class="line">		<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()||head!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk.<span class="built_in">push</span>(head);</span><br><span class="line">				head = head-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				head = stk.<span class="built_in">top</span>();</span><br><span class="line">				cout &lt;&lt; head-&gt;val &lt;&lt; endl;</span><br><span class="line">				stk.<span class="built_in">pop</span>();</span><br><span class="line">				head = head-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>后序遍历代码实现：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归后序遍历	左=&gt;右=&gt;头 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">posOrderUnRecur</span><span class="params">(BinaryTree* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk1;</span><br><span class="line">		stack&lt;BinaryTree*&gt; stk2;</span><br><span class="line">		stk1.<span class="built_in">push</span>(head);</span><br><span class="line">		<span class="keyword">while</span> (!stk1.<span class="built_in">empty</span>()) &#123;	<span class="comment">//弹出时不操作而是放入另一个栈中</span></span><br><span class="line">			head = stk1.<span class="built_in">top</span>();</span><br><span class="line">			stk2.<span class="built_in">push</span>(head);</span><br><span class="line">			stk1.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk1.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				stk1.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!stk2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			cout &lt;&lt; stk2.<span class="built_in">top</span>()-&gt;val &lt;&lt; endl;</span><br><span class="line">			stk2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		对三种遍历结果进行观察，前序的最前边是头节点，而后序的最后一个是头节点，然后根据中序遍历的结果可以进行二叉树复原，但只有前序和后序是无法复原的。</p>
<h2 id="祖先"><a href="#祖先" class="headerlink" title="祖先"></a><center>祖先</center></h2><h4 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h4>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
